[{"title":"iOS多组件App皮肤配置方案及实践","date":"2022-10-15T15:34:16.000Z","url":"/ios/ios-skin-bundle/","tags":[["换肤","/tags/换肤/"]],"categories":[[" ",""]],"content":"应用换肤是常见的需求了，项目工程需要将设计资源的颜色、字体、图片等设计元素使用皮肤文件进行配置管理。本方案主要以项目支持马甲包资源管理、样式配置为主。 核心需求点： 马甲包开发支持，方便马甲包进行样式配置（区分）及资源包集成； 皮肤包功能，支持动态下载皮肤包（比如节日包），并应用到App上； 皮肤热更新，支持后台推送、App实时更新样式； 优先支持需求点1、2，需求点2、需求点3需后台配合支持。 代码开发快速上手请见「[配置格式说明]」及「[快速上手]」。 样式配置配置格式说明目前使用json作为配置文件格式。 目前暂定，应用全局配置使用主皮肤包中的appstyle.json，业务配置可自定somemodule.json。应用全局配置具有较为固定的key、默认会在App启动后读取配置应用到全局UI上，业务配置按需自定。 分割为多个配置文件，一则减少单次IO访问阻塞时间，二则隔离各业务配置、减少冲突。 以下为示例配置文件。每个key是业务id，也就是带义务意义的key。单个配置文件内应保证key的唯一性。 颜色配置格式颜色的配置格式包括三种： String 纯色配置。支持#RGB、0xRGBA、#RRGGBB、RRGGBBAA等格式的颜色配置，与UIColor+YYAdd.h保持一致。通常情况默认使用#RRGGBB即可。 因UI规范未定，后续可能有变动。 Object 渐变色配置。主要包括3个key的配置： colors: Array，元素同上述1的String格式 locations: Array，元素为Float格式，取值范围[0, 1] style：Int，可选0/1/2/3，请参考GradientStyle的取值，可拓展。 属性意义可参考CAGradientLayer。 Array 渐变色配置，即第2种格式的简化版，只使用colors进行配置。默认locations为均分，即均匀渐变，style为GradientStyleLeftToRight。 字体配置格式字体的配置格式包括三种： Float 通过字号配置，将使用皮肤包「全局配置」中的字体（或系统字体）。 ⚠️请注意是Float格式，若配置为String格式，运行期Debug模式会断言失败、提示修改。 Object 可指定三个key进行配置： fontName: String 字体名称 fontSize: Float 字号大小，必选 fontWeight: String 字重，可选：light/regular/medium/semibold/bold 请注意fontSize为必要的配置。若不提供fontName则同上述1处理。 ⚠️请注意fontWeight 字重仅为系统字体提供，约等同于[UIFont boldSystemFontOfSize:$size]此类用途。 String 提供便捷的配置格式，字体名称及字号大小，以逗号,分割，示例如”PingFangSC-Medium,16”。 ⚠️请注意需要名称、字号同时配置，如仅配置”16”字号会断言失败。 默认情况下，App使用皮肤包配置的全局字体，因此业务如无特别需求，使用第一种方式指定字号即可。 图片配置格式图片的配置目前仅一种，key: imageName。 其他配置其他不属于资源配置，但可能增加接口支持的，比如某些常见的UI控件的配置属性，主要是统一、方便使用。 待定。 全局样式配置全局样式主要包括App主色、默认字体、导航栏等全局性页面容器等外观配置。 App主色对应视觉UI规范的主色配置，配置文件中由primaryColor指定，纯色。 App默认字体配置文件中的primaryFont进行指定。支持加载皮肤包携带字体，指定字体名称以在App中全局配置使用（代码需配置），比如可以从PingFang字体切换为自定义字体等。 请确保字体为系统字体，或App内置字体，或皮肤包内置字体。皮肤包内置字体可通过”appstyle.json”配置fonts指定需加载的字体文件。 皮肤包加载时，默认会搜索皮肤包中ttf后缀的字体进行加载。 若不指定primaryFont，则使用系统默认字体。 导航栏导航栏的视觉配置，主要包括：（待定） 导航栏背景色/图片：navigationColor、navigationBgImage 导航栏标题颜色：navigationTitleColor 导航栏标题字体：navigationTitleFont 导航栏返回按钮图片：navigationBackImage 见下方json配置文件定义。 tabBartabBar的视觉配置，主要包括：（待定） tabBar背景色/图片 tabBar文案字体 tabBar文案颜色 建议修改或开发TabBarController，以支持由内容页面提供响应tab的tabBarIcon图片及文案。 皮肤包中全局配置文件（appstyle.json） registerFonts是配置需要动态注册的字体。也可不配置，程序可配置自动搜索皮肤包中的ttf字体文件进行加载。 全局配置文件支持拓展，但通常情况会进行字段限定（比如与设计出的规范文档对齐），并保持稳定。 业务定制样式配置默认支持（或可支持）UIView及常见控件的样式属性可配置。特殊需支持的配置需求，需要控件支持配置，如未支持需安排开发。 目前GradientButton、GradientLabel已提供渐变背景、渐变文字支持。 皮肤包资源构成皮肤包的配置及资源，在SkinBundle组件中可以配置在Assets目录下。 如下图示是以项目区分的资源构成： 资源皮肤资源包括字体文件（ttf）、图片（png/jpg）、图片集xcassets、Lottie资源、音频mp3，以及皮肤包的配置文件，都属于皮肤包资源。 目前支持集成的文件后缀包括：xib,png,xcassets,svg,ttf,json,xml,plist,mp3。如果新增需要更新皮肤包组件描述。 共有资源考虑到目前项目间可能存在大量相同的资源，资源包支持在将其放置在Common目录下，目录结构及文件类型支持保持一致。非必要配置。 项目特有资源皮肤包工程可自定义项目资源目录，现有App1/App2/App3等（如上目录结构树所示）。 皮肤包最终会以Skin.bundle资源包的形式集成到主项目中，一般情况下在.app路径下。 图片可以添加在xcassets资源集或images目录下。images目录可以划分目录管理图片资源。 皮肤包集成基于pod组件进行集成。使用方式说明请见「快速上手」部分。 主皮肤包跟随SkinBundle进行集成即可。 组件资源包此组件，特指项目的Component类组件，通常为业务组件。业务组件如需要区分马甲包进行样式配置，可以添加配置文件到组件资源包中，业务上使用方法除指定component外几乎一致。 若业务组件需要区分资源包，请业务组件自行安排集成，比如通过subspec方式来区分项目集成亦可。 皮肤包更新需要将主皮肤包映射到沙盒中。支持全量更新或增量更新，具体策略，涉及资源包版本管理、补丁包制作及更新包等细化逻辑。以下说明方案思路。 资源包更新管理后台管理后台支持资源包上传（托管）、版本化及差分包生成等。主要为后端内容，差分/补丁制作工具与客户端保持统一即可，此处不赘述。 皮肤包版本约束包括主应用最低版本要求、主皮肤包版本、差分包版本及对应主皮肤包版本等版本信息。 全量更新主要流程： 皮肤包zip上传到文件托管服务； 客户端与后台进行配置版本同步，同步策略两端协商即可。比如可以App定期启动后拉取配置版本，也可以服务端推送或其他手段进行同步； 客户端版本比对能力，客户端按需下载皮肤包文件； 客户端更新皮肤包映射关系，触发皮肤热更新等； 增量更新增量更新包括两部分：差分包（补丁包）制作、差分包应用（集成）。 差分包制作 差分包的制作需要使用diff工具，具体的选择看需要。目前bsdiff和bspatch是一套常用的工具，可以参考使用。考虑进一步性能优化情况下，可再考虑其他diff工具的组合使用。 差分包集成 通常是阶梯式进行diff应用。 客户端在拉取到皮肤包配置后，根据应用版本及资源版本自行判断是否适用全量更新或增量更新； 确定增量更新后，递归下载所需的增量包； 递归、阶梯式应用增量包到全量包生成新的全量包，直到生成目标资源包结束； 客户端更新皮肤包映射关系，并触发皮肤热更新。 皮肤热更新包含两部分： 热切换 主要是指客户端需要支持配置更新（全部或个别）后，在App侧能直接生效。具体实现方式，可通过观察者模式或闭包缓存的方式实现。 对业务开发使用无影响。 热更新 主要是指客户端需要及时获知配置及资源包的更新，比如轮询，比如服务端推送等多种手段都可实现，此处亦不赘述。 快速上手 Podfile添加依赖SkinBundle 默认集成项目的资源包，相关项目或希望调试其他资源包时，需指定对应的subspec 或有需要可以将资源包抽离为独立的pod组件，将资源托管到静态服务。 使用支持配置的控件 Swift版的接口，控件的可配置属性约束在style的域下所支持的属性。 目前对UIView、UILabel等基础控件进行属性配置的支持（持续更新中）。 定制配置目前主要包括GradientButton及GradientLabel主要提供渐变背景及渐变文字的支持。"},{"title":"how-arc-working","date":"2022-09-23T12:29:46.000Z","url":"/ios/ios-how-arc-working/","tags":[["ARC","/tags/ARC/"]],"categories":[[" ",""]],"content":"我们都知道ARC是苹果通过编译器在编译期支持的功能。但要问编译器对ARC是怎么支持的，很多人大概率说不出所以然来。 Objective-C的内存管理依靠引用计数，在对象被持有时增加计数，在对象被原持有对象释放的时候减少计数。在ARC之前，开发者是需要牢记retain跟release的。 我们来看一个示例程序： 我们通过Clang前端来检查编译各阶段的情况。 clang -fobjc-arc -framework Foundation -fmodules -fsyntax-only -Xclang -ast-dump hello.m 输出AST： 在输出的AST中我们能找到与ARC相关的内容非常少，也没有看到插入objc_storeStrong等符号。唯一相关的是ARCConsumeObject。 clang -fobjc-arc -framework Foundation -S -emit-llvm hello.m生成IR代码： clang -fobjc-arc -framework Foundation -S hello.ll -o hello.s生成汇编： 我们可以看到在AST阶段其实编译器并没有插入ARC相关代码，但在IR阶段便插入了`@llvm.objc.storeStrong（即汇编的_objc_storeStrong）。所以唯一的线索是ARCConsumeObject`。 顺着这条线索，我们查阅到了： llvm-project/clang/lib/Sema/SemaExprObjC.cpp 中的Sema::CheckObjCConversion。 正是ARC处理之处。我直接把这部分代码贴在下面： 总结一句话就是说，ARC是编译器在AST之后、生成IR中间代码之前插入的代码。"},{"title":"iOS启动任务管理","date":"2022-09-20T15:31:38.000Z","url":"/ios/ios-launch-task/","tags":[["优化","/tags/优化/"],["启动","/tags/启动/"]],"categories":[[" ",""]],"content":"重新造轮子，写一个不阻塞启动过程的带优先级、依赖管理的启动任务管理器。 就目前iOS的客户端项目架构，组件化、面向接口基于IoC的模块化，越来越成为共识。模块的初始化、加载，及服务注册都需要合理地管理起来，同时要避免+load方法内预处理引入不必要的启动耗时。 目前一种可选的做法是，将任务/模块信息写入Mach-O的Section中，在合适时机读取使用。一般通过__attribute__((used, section(&quot;__DATA,&quot;)))即可将数据写入指定的Section。 以上两种是常见的两种数据格式，前者好处在于简便，后者好处在于性能。 完善后将开源。"},{"title":"一次iOS启动优化实践与启示","date":"2022-09-16T14:02:27.000Z","url":"/ios/ios-launch-optimzation-a-case/","tags":[["性能","/tags/性能/"]],"categories":[[" ",""]],"content":"启动耗时是客户端品质的核心指标之一。 一个团队对产品性能的关注，首先体现在App的启动体验上。 本文以近期一次启动优化的案例（P50及平均启动耗时下降45%），来看看那些性能问题可以如何解决，以及对我们日常开发的一些启示。 在本次的优化实践中，我们的目标分为两项： App实现启动速度监控 App启动时间减少30% 其中，目标1旨在实现App启动速度监控上线，将用户端App启动过程分阶段（pre-main/post-main）耗时监控上报，跟踪用户端实际性能数据；目标2旨在通过代码优化等手段，实现App整体启动时间减少30%，提升用户体验。 前置知识启动的过程，按照WWDC2019上的定义，分为以下几个阶段： System Interface：加载可执行文件，依据LoadCommands加载ld，dyld根据动态库依赖关系加载系统动态库、项目动态库，并进行rebase/binding修正符号符号指针； Runtime Init：语言runtime的加载、静态初始化方法； UIKit Init：程序main入口方法执行，初始化UIApplication，接入系统事件（和Runloop）及UIKit； Application Init：调用application:didFinishLaunchingWithOptions，之后调用applicationDidBecomeActive:； Initial Frame Render：首帧页面构建，首帧渲染； Extended：App进入前台，响应事件。 我们一般使用从进程创建到首帧渲染完成的时间来衡量启动时间（MetricKit也以首帧时间为基准）。以客户端的开发指引来说，基于用户体验考虑，各种启动类型的最大可接受的时间为： 冷启动应少于5s 热启动应少于1.5s 这是一个宽泛的底线目标。 基本过程我们的优化工作主要按以下两个基本过程进行： 性能检测、监控 性能优化 性能检测主要包括Instruments测试以及代码插桩埋点两种方式。我们使用Instruments测试的基准环境是： （冷）启动全阶段时间，从icon点击（进程创建）到首帧渲染完成； 基准测试设备，选择iPhone 8或目前仍在生产线的iPhone 11（以下Instruments的测试如未说明均指iPhone 11上的测试结果）； 已登录状态启动进入首页作为主要测试场景； 对于冷启动的测试，苹果的建议是关闭设备后晾个2-3分钟再重启。 性能优化方面，我们按阶段及重点任务进行： 加载阶段优化 静态初始化阶段优化 启动任务分级优化 耗时函数优化 主线程阻塞优化 性能检测一般来说，建立量化指标是进行优化的前置工作。App启动性能的检测我们可以分为两个方面，一是开发阶段的性能测量，二是线上的性能监控。其中开发阶段的性能测量，又以Instruments工具作为主要、常见的手段。再配合代码插桩等手段进行埋点，我们可以得到一个较全面的App启动数据。 Instruments性能检测Instruments新增的App Launch工具相当于集成了Time Profiler、System Trace等工具的整合。 App Launch的测量主要包括启动过程各阶段的耗时测量、主线程阻塞检测及分析、PageFault页面中断分析等。这些都是常见内容，本文不再细述，我们直接列举一些检测到的结果或问题来实例分析： 整体的耗时 时间消耗： 初始化（premain） 启动初始化 475ms 系统接口初始化 1.9s（system interface initialization） 静态运行时初始化 350ms（static runtime initialization） 启动阶段（main后） UIKit初始化 60ms didFinishLaunchingWithOptions 1.15s 首帧渲染 102ms 优化前Instruments整体达到了3.8-4.0s（iPhone 11/iOS 15.0，设备下同）。 从预埋的数据监控，线上的数据表现有点难看（大概20w的数据） 版本 均值 P50 P90 P95 std X.0.1 3179.2 2406.0 6165.0 7894.0 2664.6 90分位的数据是6165ms，这说明有10%以上的用户的启动耗时在6s以上，这已经超出我们正常体验的5s的可接受范围了。事实上，后来在排查并发锁问题的时候去检索线上数据，发现有较多低性能设备（375x667/414x736）出现了较多更超预期的启动时间，比如post-main阶段可能超过10s，让我一度怀疑是否埋点数据上报问题。 Page Fault的影响二进制重排目前变成了启动优化绕不过去的优化手段之一，我们在优化过程中也特别留意了这方面相关的性能数据。 如上图，整个冷启动阶段测试到的数据是，File Backed Page in: 8269，耗时1.71s。而直接重新Profile热启动后，File Backed Page in的数据是是3908次，468ms。热启动测试不准，一方面也是因为在有缓存情况下，Page Fault有较大影响。 综合分析 Instruments的性能检测需要结合Time Profiler、多线程状态、内存、系统日志等手段进行综合分析，尤其对于一些非稳定出现的问题。 有一点需要注意的，iOS 15之后加载器已经更新为dyld4。dyld本来支持DYLD_PRINT_STATISTICS、DYLD_PRINT_STATISTICS_DETAIL等参数来输出日志，但dyld4之后这些日志打印都被取消了（有个别如DYLD_PRINT_APIS还保留）。事实上，dyld4已经删除/屏蔽了原来的api_logs的调用，同时改由进程的安全策略去控制是否Log了，有需要可以了解DYLD_AMFI_FAKE。同时需要注意的是，dyld的日志输出也是很消耗性能的，即使是使用dyld3，我们在分析耗时方法过程中最好关闭这些Log输出能力，减少干扰。 dyld3日志引起的耗时 另外实践中，在Instruments的线程堆栈采样中，dyld4的一些方法也无法完整符号化。比如 我们仅仅是知道此处触发了动态库的载入，但具体什么库怎么触发的毫无线索。但在dyld3下我们可以看到较完整的堆栈信息，如下所示可看到是触发了Accessibility的动态库载入： 对照工程源码，发现原来有些业务进行了accessibilityLabel的配置。 还有需要提一点的是，目前Xcode已经支持 os_signpost 进行日志打点，对于我们组件化的一些耗时统计也可以在Instruments上直观地看到。这在一些特殊需要的场景下我们可以更方便地结合Time Profiler等其他工具进行分析，找出性能瓶颈。 源码层面性能监测源码层面的性能测试，主要包括启动阶段耗时的监测、耗时方法的分析等。 启动阶段耗时在这次案例中，我们主要获取进程创建时间、main开始执行时间、didFinishLaunching时间及首帧渲染完成时间。 进程创建时间，我摘录了段代码如下，都是业内公开的代码了： 但根据实测以及线上上报的数据来看，查询到的进程创建时间的数据可能会出现一些明显非法数据，比如大于10,000ms的数据。另外一个可复现的场景，即设备重启后，查询到的进程创建数据，要比点击icon的时间要早数秒。目前对这种情况尚无法定位问题，主要是设定规则过滤了非法数据，如果有同学有这方面处理经验可以分享下。 首帧渲染时间，主要根据iOS上CoreAnimation的工作原理，相当于hook了CATransaction提交后的时机（其他hook方法同理） 源码层面的埋点统计要比Instruments的数据要小，一方面调试进程attach到app进程有时间损耗，另一方面Release版源码一般有屏蔽逻辑及更多的编译优化。但不影响我们分别进行性能检测。在本次案例中也是每个优化步骤都控制变量，可以通过测试数据的比对明确优化内容的效果。 耗时方法分析 通过hook底层方法（objc_msgSend）可以插桩记录方法的耗时。其中以Facebook的基于fishhook的方式为常见。 在 Mach-O 中，有 Bind 和 Lazy Bind 的两种符号绑定的表，基于 fishhook 的 Hook，是通过修改__la_symbol 和 __nl_symbol 两个符号表中被hook的符号的指针，后续便可以直接通过 __la_symbol_ptr 找到函数地址直接调用，在替换的方法中进行插桩。 通过耗时方法分析，我们可以dump出启动过程中长耗时的方法列表，分析确认需要优化的代码。也可以按需定制策略对线上运行情况进行采样采集。以下是排查到的耗时的一个示例。 实测我们看到的大部分情况排查到的耗时方法，是可以跟Time Profile采样到的线程堆栈对应的。 一些低性能问题 XPC性能问题 XPC的调用，是引起性能问题的一个重要场景，比如下述的堆栈显示的是我们cacheHeader方法引起的XPC调用。比照代码可以发现实际是一个设备UUID的接口对Keychain的访问引发的。 除了Keychain的读写访问，还有比如通知中心、UserDefaults、PasteBoard等接口访问都可能触发XPC的调用 Webview 很多应用喜欢在应用启动时初始化一个WKWebview（或已废弃的UIWebview），可能是用来同步UA信息。WKWebview的初始化及JS脚本执行是很耗时的操作。 并发锁等待 对于有多线程读写需求的数据，为了数据的一致性，我们一般会对临界代码的访问进行加锁处理。这体现在很多场景，比如观察者模式Observer的读写一般需要加锁；比如共享资源的读写需要加锁，很常见的就是SQLite数据库的读写就有文件锁；比如很多日志库的实现也会加锁。 并发处理需求的处理，在目前都是有加锁需要的。但排查甄别这类问题却是相对麻烦的事情，一是因为并发场景不一定好复现，二是锁等待时间比较随机。 在本次的案例中，我们发现有几个场景导致锁等待的。 凌乱的递归锁这个项目的历史遗留原因，在一个Service中介者的实现上，有比较多问题。列一下伪代码： 因为要支持多线程访问，读写serviceMap需要加锁。而在Service的初始化过程中，会向ServiceCenter注册遵循不同proto的Client，而ServiceCenter对clientMap的读写也是需要加锁的。所以ServiceCenter是需要递归锁的，项目里面使用的是@synchronized。暂且不论锁的性能问题，并发情况下这段逻辑上是可能会引起锁等待的。 Mars日志库异步写入Mars是一个基于mmap方案的日志库。Mars的总体的流程分为3个步骤：a. 日志格式化b. 写入缓存c. 达到阈值后通知后台线程写入文件 XloggerAppender::Write方法在异步写入的情况下是如下代码： 可以看到也加了互斥锁，并且是在发起线程上进行压缩、加密后写入缓存的，算是一个耗时操作。日志的多线程使用也是避免不了，项目中可能在网络回调、数据库读写回调、各种业务代码中都可能有，有一定的几率引发锁等待。 主线程大量I/O 列举一些：a. 图片资源读取b. 配置读取c. KV存储同步读写 这些场景都非常常见，很可能也是你们项目中的性能杀手。 优化根据行业过往的经验及苹果的建议，我们有一些常见的优化方法和策略。 加载阶段优化 苹果给出的建议是，减少对外部框架和动态库的依赖。 我们可以实际操作的一些优化： 减少不必要的系统库依赖； 集成二、三方库时尽量使用静态库进行集成； 删除冗余代码； 系统框架在不同App间大部分是共享的，对于__TEXT段等都不需要从文件重新加载，因此系统库的加载的开销是比较少的。我们从示例中Networking的加载可以了解。 第二点借助CocoaPods很容易实现，可以组件静态库化，也可以指定:linkage为static。对于极致的优化，可以对一些只能动态库集成、但非启动过程中必需的三方库，可以进行包装进行动态载入。第三点删除冗余代码，一些比较简便的方式就是通过比对Mach-O文件中clslist与classref的差集来分析。 因为iOS13之后dyld3的启动闭包优化，以及设备性能提升，存在较大比例的热启动的情况。从我们后来的检测数据来看，加载阶段的优化在线上平均表现是比较一般的。 静态初始化阶段优化 静态初始化部分的耗时，通常来源于三部分： C++静态构造函数 Objective-C +load 方法 标记为clang属性_attribute((constructor))函数 对于一般的项目我们着手处理的更多的是+load方法的优化。因为+load方法的执行时机比main函数更早，实际上是可以用来做一些预处理工作的。但因为iOS开发的早期一些错误的范例，以及开发的一些惰性，导致了+load方法的滥用甚至是错误使用。 一些错误的使用范例： +load方法内部实际调用了UIKit相关的接口，又触发了UIKit的一些加载及初始化方法。 通常来说，在没有其他优化手段时，我们可以考虑将部分+load方法中逻辑迁移到+initialized中，附一下两个方法的接口说明：+load +initialized 实际上很多这些预处理的任务，比如组件化后的一些服务或业务模块的加载、初始化工作，可以调整到首帧甚至更晚的实际进行。对于这些LaunchTask任务我们可以管理起来，既避免在静态初始化阶段通过+load方法这些方式引入耗时，又能指定优先级及依赖关系，让启动过程或者说App的模块/服务化都更加清晰。实践上，我们会将模块/服务任务的注册/映射信息，写入到Mach-O的自定义Section中，具体会在后面文章进行介绍。 启动任务分级优化 启动过程，我们可以划分为didFinishLaunch、afterFirstFrame等几个阶段。在UIApplicationDelegate回调时，我们可以建立应用任务时序、优先级的管理，同上面提到的LaunchTask，不赘述。 耗时函数优化 在分析到项目的耗时方法后，我们需要具体的进行优化，比如缓存是一种常见的优化策略，又比如减少内存操作等。可以举一些案例。 比如前面提到的通过WKWebView查询UA的功能，考虑到UA生成逻辑的变更频率，完全可以增加多级缓存，可以大幅减少这个方法的耗时。 又比如项目中有个ListViewModel的类有这么一个属性： 这个blueRoomList在tableView的回调被频繁调用，用来查询count或某个element。针对这个情况，我们的优化可以对ListViewModel增加提供外部接口，避免这个copy操作。 主线程阻塞优化 主线程阻塞一般是锁、I/O或XPC引起的。 对于锁的问题，一方面如果是高频的并发情况，可以选择锁的替换方案，比如使用读写锁、使用dispatch队列等。对于递归锁，根据benchmark，NSRecursiveLock性能是比较低的，一个可选的方案是支持递归的pthread_mutext_t。另一方面，则需要避免死锁的逻辑，我们最好是限制临界区代码的范围，比如上述提到的ServiceCenter的案例中，如果我们只对serviceMap读写部分加锁，将Service的初始化过程中的无关逻辑移出加锁范围，可以大幅减少我们死锁的问题。 I/O的优化，对于启动过程必须的图片资源，我们可以进行预加载。UIImage的加载是支持并发的。还有启动图缓存的使用，既避免资源加载的阻塞，又在视觉效果上可以较好地过渡，在异步加载资源方面是可以有效改善用户体验的。 主线程阻塞的问题一般隐藏性比较深，尤其是不稳定重现的问题，需要我们根据实际情况处理，这里不再赘述。 首帧渲染优化 用苹果的建议，一句话是“降低初始视图的复杂性”。总的来说，首帧渲染涉及到我们对应用页面栈的管理、服务的加载逻辑、业务架构、UI渲染优化等，总体上是涉及到项目架构的。这些都需要专题解决，所以这里也只能一笔带过。 在不大改动架构的前提下，我们也可以注意一些小技巧，比如，I/O的管理及缓存的使用。图片作为我们很常见的视觉元素，图片加载和图片缓存有合理的管理策略，是能有效改善应用性能的。 二进制重排 二进制重排主要是考虑程序运行过程中对指令读取过程中Page Fault引起的性能问题。主要的方法是通过clang插桩记录启动过程中的访问的符号信息，生成一个orderfile，以便编译器在链接时调整顺序。Page Fault之前已有博客讨论了，orderfile的生成目前也是成熟方法了（可以直接使用YCSymbolTracker），只是需要注意+load方法以及效率问题。我对YCSymbolTracker有个小小的patch，后续会提pr过去。此处不再赘述。 优化结果这一次的优化，我们分了两期上线，x.0.1是优化前版本，x.0.2主要上线除启动任务分级、主线程卡顿之外的其他优化处理，x.0.3补充提交了这两个优化。最终的效果如下： 版本 均值 P50 P90 P95 std X.0.1 3179.2 2406.0 6165.0 7894.0 2664.6 x.0.2 3130.0（0.98） 2096.0（0.87） 6470.0 8850.0 3126.3 X.0.3 1737.9（0.55） 1306.0（0.54） 3301.0 4539.0 1665.7 （蓝色是优化前版本x.0.1，橙色是x.0.2，红色是x.0.3） 可以看到，x.0.3版本优化后，启动的的中位时间从2.41s下降为1.31s，平均时间从3.18s下降为1.74s，P90下降为3.30s。这说明就该项目而言，主线程阻塞问题对某些设备有很大影响。但如上文提到的，二进制重排，出乎意料的是，在平均效果表现上一般。可能是启动闭包以及的优化。 1.31s的效果也不算理想，对于尚包含大量不规范的数据库操作、KV存储等逻辑的项目，这已经在预期中了。而更深度的优化，只能在应用页面栈管理、服务加载逻辑、业务架构、UI渲染优化等方面继续深耕。 总结任何时候，问题比答案更重要，提出问题需要勇气，找到问题需要努力。对技术路上开放、分享、开源、营造社区氛围的技术er们，Respect。"},{"title":"YCSymbolTracker打个小补丁","date":"2022-09-15T03:19:59.000Z","url":"/iOS/YCSymbolTracker-patch/","tags":[["优化","/tags/优化/"]],"categories":[[" ",""]],"content":"YCSymbolTracker是一个通过clang插桩记录应用启动过程中发起的方法。 添加了加锁逻辑以及重复项目过滤。"},{"title":"苹果新闻及更新公告（updated）","date":"2022-06-12T14:30:28.000Z","url":"/ios/apple-news/","tags":[["ios","/tags/ios/"],["公告","/tags/公告/"]],"categories":[[" ",""]],"content":"现已推出 WeatherKit 订阅 - 2022 年 9 月 12 日WeatherKit 通过丰富的数据为您的 App 和服务带来有效可信的天气信息，帮助人们获取最新预报，未雨绸缪地做好安全措施。您可以通过适用于特定平台的 Swift API，在用于 iOS 16、iPadOS 16、macOS 13、Apple tvOS 16 和 watchOS 9 上的 App 中轻松使用 WeatherKit；也可以通过 REST API 在任何其他平台上使用。Apple Developer Program 会员资格包含每月最多 50 万次 API 调用。现在，帐户持有人还可以在 Apple Developer App 中订阅更多的 API 调用。详见开始使用 WeatherKit 实时活动现已推出 Beta 版本 - 2022 年 7 月 27 日实时活动能帮助用户直接通过锁定屏幕实时了解您的 App 中正在发生的事情。现在，您可以开始使用实时活动和新的 ActivityKit 框架了。相关功能已在 iOS 16 的 Beta 4 版本中推出。请注意，实时活动和 ActivityKit 不会包含在 iOS 16 的首次公开发行版中。今年晚些时候，它们会随着 iOS 的更新版本推出。到时您可以把配置了实时活动功能的 App 提交至 App Store。进一步了解实时活动和 ActivityKit (英文) 即将从 XML Feed 过渡到 App Store Connect API - 2022 年 7 月 19 日App Store Connect REST API 让您可以跨各种开发者工具自定义任务并实现任务自动化，使工作流程更灵活、更高效。从 2022 年 11 月开始，您将需要使用此 API 来代替 XML Feed，从而实现对 App 内购买项目、订阅、元数据和 App 定价的自动化管理。XML Feed 将继续为现有的 Game Center 管理功能提供支持。了解 App Store Connect API 为 RoomPlan 做好准备2022 年 6 月 30 日现在，您的 App 可以创建 3D 户型图，包括家具的尺寸和类型等关键特征。这个由 ARKit 提供支持的全新 Swift API 能够利用 iPhone 和 iPad 上的摄像头和激光雷达扫描仪将现实环境带入您的 App 中。进一步了解 RoomPlan Apple 设计大奖获奖者名单公布 - 2022 年 6 月 6 日Apple 设计大奖旨在表彰在兼容并蓄、乐趣横生、优越互动、社会影响、视觉图像，以及创新思维等类别中表现出色的 App 和游戏。一起来了解这些获奖 App 和它们背后极具才华的开发者们吧。查看获奖者 为“开发者模式”做好准备 - 2022 年 6 月 6 日开发者模式可避免用户无意中在其设备上安装可能有害的软件，并减少由仅限开发者的功能所暴露的攻击媒介。在 iOS 16、iPadOS 16 以及 watchOS 9 或更高版本中测试 App 时，请确保在您的设备中启用此模式，以授权本地安装的 App 在以上平台中运行。 帐户删除要求将从 6 月 30 日起生效 - 2022 年 5 月 24 日谨此提醒，自 2022 年 6 月 30 日起，支持帐户创建的 App 必须同时允许用户在 App 中发起帐户删除，具体如《App Store 审核指南》第 5.1.1(v) 条中所述。我们已延长该要求的截止日期，希望能给您更多准备时间。在更新您的 App 时，请注意以下要求：用户应该能够在您的 App 中轻松找到帐户删除选项。如果您的 App 提供通过 Apple 登录，在删除帐户时您将需要使用通过 Apple 登录 REST API 来撤销用户令牌。不能仅提供暂时禁用或停用帐户的选项。用户应该能够将自己的个人数据与帐户一起删除。如果 App 涉及的领域受到严格监管，您可能还需要提供额外的支持流程，用于确认和协助帐户删除过程。遵循关于储存和保留用户帐户信息以及处理帐户删除的适用法律要求。其中包括遵循不同国家或地区的当地法律。与以往一样，请咨询您的法律顾问。 阐明 App Store 改善流程的标准和新的限期延长 - 2022 年 4 月 29 日用户对优质 App 的信任是我们构建和运行 App Store 的基础。为了确保出色的用户体验并回应开发者的建议 (英文)，我们在 2016 年启动了 App Store 改善流程，以删除不再按预期运行、不遵循当前的审核准则或已过时的 App。这有助于我们确保 App 适用于绝大多数用户，并贯彻我们在安全和隐私方面的最新改革。在过去六年中，作为此流程的一部分，我们已经删除了近 280 万个 App。此流程将对用户和开发者同样有益，其中包括：可发现性：当 App Store 上不再有过时的 App，用户就能更轻松地找到真正符合他们需求的优秀 App。这同时也将帮助开发者的 App 更容易在 App Store 上被用户发现。安全和隐私：Apple 的硬件和软件都在不断地发展更新，我们经常为开发者提供新的工具来增强性能、安全性和隐私。当开发者更新他们的 App 以整合这些技术时，他们也在尽自己的一份力量来帮助保护用户的安全和保障。用户体验：让 App 保持更新以适应新型的屏幕尺寸、SDK、API，以及 iOS、iPadOS 和 macOS 上提供的所有其他功能，确保用户在 App Store 上获取任何一款 App，都能在其中享受到出色的体验。作为 App Store 改善流程的其中一环，当一款 App 在过去三年内从未更新且未达到最低下载量 (即该 App 在连续 12 个月内完全没有或只有极低的下载量) 时，其开发者将会收到电子邮件，告知该 App 已被识别并可能从 App Store 中被移除。Apple 衷心希望能帮助开发者在 App Store 上发布且保留高质量的软件。针对 App 的移除，开发者可以提出上诉。此外，包括最近收到通知的开发者在内，所有开发者现在都将拥有更多时间 (最多 90 天)，在需要时更新他们的 App。对于已在其设备上下载该 App 的用户，被删除的 App 也将继续正常运行。 4 月 25 日起将实行以下 App Store 内容提交要求 - 2022 年 3 月 15 日从 2022 年 4 月 25 日开始，所有提交到 App Store 的 iOS、iPadOS 和 watchOS app 都必须使用 Xcode 13 构建。Xcode 13 已包含 iOS 15、iPadOS 15 和 watchOS 8 的 SDK。充分利用 iOS 15、iPadOS 15 和 watchOS 8 中激动人心的功能，提供更加直观且富有价值的用户体验。通过重构代码以利用 Swift 中的异步功能来提高 app 的性能。您还能利用 SwiftUI 最新更新的功能来增强您的 app，例如优化的列表视图、更良好的搜索体验以及对控制焦点区域的支持。iPhone 和 iPad app：iOS 15 和 iPadOS 15 让您可以利用 Safari 浏览器的网页扩展、同播共享和 Group Activities API、专注模式、ShazamKit、以及 Create ML 等。您还可以发布自定产品页和 app 内活动，并在这些平台的 App Store 上进行产品页优化测试。 小型业务开发者协助申请提交将于 5 月 20 日截止 - 2022 年 4 月 25 日去年，Apple 宣布设立一亿美元的基金来帮助美国的小型业务开发者。符合条件的开发者必须在 2022 年 5 月 20 日之前向独立管理员提交申请，以便接收资助款项。该基金向所有符合以下条件的开发者开放：2015 年 6 月 4 日至 2021 年 4 月 26 日期间，通过 App Store 销售过付费 App 或 App 内购买项目 (包括订阅项目)；且在 2015 至 2021 年，持有开发者帐户期间的每个日历年内，通过美国地区的 App Store 获得的收益不超过 100 万美元。 WWDC22，召唤编码侠 - 2022 年 4 月 5 日北京时间 6 月 7 日至 11 日，与全球开发者一起加入这场为期一周的盛会，尽享属于技术与社群的节日。您将在各种活动中率先一睹 Apple 最新的平台和技术，探索最新工具和技巧，还可在线上实验室和聊天室中与 Apple 专家交流。所有活动均免费在线举行。除了线上举办的大会，Apple 还将于美国太平洋夏令时间 6 月 6 日，在 Apple Park 为开发者和学生们举行一个特别活动日，与线上的全球开发者们一起观看主题演讲和 State of the Union。现场参与名额有限，申请详情将随后发布。无论您打算在哪里、用哪种方式参与，都为这届精彩纷呈的 WWDC 做好准备吧。另外，富有才华的学生们还可通过展现自己的创造力，角逐 Swift 学生挑战赛并获得奖励。 “阅读器”app 分发的更新 - 2022 年 3 月 30 日去年，Apple 宣布了 2022 年初在 App Store 上将进行的更新，该更新将允许“阅读器”app 的开发者在 app 中提供一个指向其网站的链接，以便用户创建或管理帐户。从今天开始，《App Store 审核指南》中的准则 3.1.3(a) 将会更新，阐明阅读器 app 的开发者现在可以申请外部链接的帐户授权。此授权将允许阅读器 app 链接到开发者拥有或维护的网站，以便用户在 app 外创建或管理其帐户。阅读器 app 指的是提供以下一种或多种数字内容类型 — 杂志、报纸、图书、音频、音乐或视频 — 作为其主要功能的 app。 更新的 Apple Developer 证书现已可用 - 2022 年 2 月 1 日特别提醒，开发者现在可以更新其 Apple 推送通知服务 (APNs) 和 Developer ID 的媒介证书了。Apple Worldwide Developer Relations 媒介证书 (G4)APNs SSL 证书现在已由专门针对 APNs 的新媒介证书 (Worldwide Developer Relations G4 sub CA) 来颁发。该证书可用于发送推送通知至 app (包括 VoIP)、复杂功能、Safari 网站以及 Apple “钱包”通行证。Apple Developer ID 媒介证书 (G2)您用于在 macOS 上签署软件和安装包的数字证书现在已由新的 Developer ID 媒介证书来颁发，该证书将于 2031 年 9 月 16 日到期。与新媒介证书关联的新颁发的 Developer ID 证书可被用于在 Xcode 11.4.1 及更高版本上为软件签名。如果您运行的是 Xcode 13.2 或更高版本，您在 2022 年 1 月 28 日之后为软件签名时，更新的证书将会自动下载。如果您使用的是较早版本的 Xcode，则可以手动下载证书，或创建与以前版本的 Xcode 兼容的证书。您现有的证书将继续有效，直至到期或被撤销，以先到者为准。 现已推出新的 App Store Connect API 功能 - 2022 年 01 月 25 日现在，App Store Connect API 能让您更灵活地自动化并自定 app 的工作流程。借助这些新功能，您可以创建和提交 app 内活动、自定产品页以及产品页的优化测试。此版本还支持更新的 App Store 提交体验，让您能够提交多个项目、无需更新 app 版本即可进行提交，并查看过去提交的内容。 API文档地址请见官方文档。 现已推出适用于订阅的自定优惠代码 - 2022 年 01 月 20 日现在，获取、留存和赢回订阅者变得更加容易了。除了一次性代码之外，您现在还可以在 App Store Connect 中创建自定代码 — 您可为每个代码设定一个您选择的唯一名称 (例如 SPRINGPROMO)。自定代码可通过直接 URL 或在您的 app 中兑换。 Apple Developer 证书即将更新 - 2021 年 12 月 22 日Apple 推送通知服务 (APNs) 和 Developer ID 的媒介证书将从 2022 年 1 月 27 日起进行更新。 更新版协议现已发布 - 2021 年 12 月 13 日Apple Developer 协议、计划许可协议、以及附表 1、2 和 3 已经更新，其中对相关内容作了阐释，以便为更新后的政策和即将推出的功能提供支持。请查看以下变更，并根据需要接受更新后的条款。 计划许可协议 第 3.2 节：明确说明了使用 Apple 软件和 Apple 服务的要求和限制。 第 3.3.39 节：阐释了有关使用 HealthKit API 和 Motion &amp; Fitness API 的要求。 第 6.6 节：明确说明了有关提交 app 符号信息的要求。 第 7.4 节：阐释了有关使用 TestFlight 的要求和限制。 第 9.1 节：删除了将附表 2 和 3 视为 Apple 机密信息的言辞。 第 11.2 和 14.8 节：阐释了出口控制的要求。 第 14.3 节：更新了有关如何提交 Apple 的转让同意请求的信息。 只摘录部分，详情参考原公告。 年末假期接受 app 提交 - 2021 年 11 月 08 日我们非常高兴地宣布，今年岁末的假期期间，我们会在 App Store Connect 中继续接受 app 提交。请确保您的 app 已做好更新，并为 App Store 上这个最繁忙的季节做好准备。预计届时会有大量的 app 提交审核，请提前规划，尽早提交有时限性的内容。请注意，在 11 月 24 日至 28 日以及 12 月 23 日至 27 日期间，完成审核可能需时较长。 Apple Worldwide Developer Relations 媒介证书 (G4) APNs SSL 证书将由专门针对 APNs 的新媒介证书 (Worldwide Developer Relations G4 sub CA) 来颁发。当新的证书被激活并可供下载后，您就可以使用其向 app (包括 VoIP)、复杂功能、Safari 网站以及 Apple “钱包”通行证发送推送通知了。 Apple Developer ID 媒介证书 (G2) 您用于在 macOS 上签署软件和安装包的数字证书将由新的 Developer ID 媒介证书来颁发，该证书将于 2031 年 9 月 16 日到期。与新媒介证书关联的新颁发的 Developer ID 证书可被用于在 Xcode 11.4.1 及更高版本上签署软件。如果您运行的是 Xcode 13.2 或更高版本，您在 2022 年 1 月 28 日之后签署软件时，更新的证书将会自动下载。如果您使用的是较早版本的 Xcode，则可以手动下载证书，或创建与以前版本的 Xcode 兼容的证书。 您现有的证书将继续有效，直至到期或被撤销，以先到期者为准。 年末假期接受 app 提交 - 2021 年 11 月 08 日我们非常高兴地宣布，今年岁末的假期期间，我们会在 App Store Connect 中继续接受 app 提交。请确保您的 app 已做好更新，并为 App Store 上这个最繁忙的季节做好准备。预计届时会有大量的 app 提交审核，请提前规划，尽早提交有时限性的内容。请注意，在 11 月 24 日至 28 日以及 12 月 23 日至 27 日期间，完成审核可能需时较长。 通过 TestFlight 测试您的 Mac app - 2021 年 11 月 03 日现在，您可以邀请人们试用您的 Mac app 的 beta 版，在发布前为您提供宝贵的反馈。通过 TestFlight，您可以对多达 10,000 名测试员发出邀请，只需使用对方的电子邮件地址或通过分享公开邀请链接即可；您也可以为内部测试员创建不同的群组，并为每个群组添加不同的构建版本，还有更多便捷功能。 Beta 版本现已提供 App 隐私报告 - 2021 年 10 月 27 日iOS 15 和 iPadOS 15 引入了记录 App 活动的功能，允许用户保存其设备上 app 传感器、数据和互联网访问的摘要信息。点击“Save App Activity”(保存 App 活动)，就能以 JSON 格式导出相关活动。有关被记录的 app 活动的简介，请观看 WWDC21 讲座视频“Apple 的隐私重点整理 (简体中文字幕)”。 在 iOS 15.2 beta 版和 iPadOS 15.2 beta 版中，此活动将显示在一个名为“App Privacy Report”(App 隐私报告) 的新 UI 中。这是检查 app 的传感器、数据和互联网使用情况的绝佳机会。要在报告中查看您 app 的活动，请安装 beta 版本，然后到“设置”app &gt; 隐私&gt; “App Privacy Report”(App 隐私报告) &gt; “Turn on App Privacy Report”(打开 App 隐私报告)。一旦您使用您的 app，活动就会显示。 更新版《App Store 审核指南》现已发布 - 2021 年 10 月 22 日App Store 安全可靠、值得信赖，是用户探索和下载 app 的好去处，对开发者来说也蕴藏着巨大的商机。我们对《App Store 审核指南》进行了以下更新，以便为即将发布的 OS 版本中的新功能提供支持，同时更好地保护用户，并帮助您的 app 尽可能顺利地通过审核流程。 添加了 2.3.13：“App 内活动是指在您 app 内发生的应时活动。您的活动必须属于 App Store Connect 中提供的活动类型之一，才能在 App Store 上展示。所有活动的元数据都必须清晰准确并与活动本身相关 (而非对应整个 app)。活动发生时间必须与您在 App Store Connect 中为不同商店选择的时间和日期一致。如要借助活动获取收益，请遵守第 3 部分关于“商务”的规定。另外，您提供的活动深层链接必须对应您 app 中的正确位置。请参阅“App 内活动”以获取可接受的活动元数据和活动深层链接的相关详细指南。” 从 3.1.3 部分中删除：“开发者不得使用从 app 内获得的信息将个人用户定向到 app 之外的位置，以使用 app 内购买项目之外的购买方式 (例如，个人用户在 app 内注册帐户后，向这位用户发送介绍其他购买方式的电子邮件)。” 添加了 5.1.1 (x)：“App 可以请求用户提供基本的联系信息 (例如姓名和电子邮件地址)，前提是用户对于是否提供信息拥有选择权。另外，用户是否提供信息不应成为使用 app 功能和服务的前提条件，且 app 须符合相关准则的所有其他规定 (包括针对收集儿童信息的限制)。” 在 App Store 上展示您的 app 内活动 - 2021 年 10 月 21 日从下周开始，用户将能直接在 App Store 上探索您的 app 内活动，这将有助您以全新的方式来展示这些活动并扩大其影响范围。您现在可以在 App Store Connect 中创建 app 内活动并为它们安排 App Store 上的发布时间。这些应时的活动 (例如游戏比赛、电影首映和直播体验) 将能带动新用户试用您的 app，为现有用户提供更多畅享您 app 的新方式，还可能帮助赢回从前的用户。从 2021 年 10 月 27 日起，app 内活动就能在 iOS 15 和 iPadOS 15 的 App Store 上展示了。 “App 分析”现已提供新的指标数据 - 2021 年 10 月 07 日App Store Connect 中的“App 分析”能有效帮助您了解用户如何发现您的 app 并与之互动。现在，您更可以查看强大的全新交易指标，包括重新下载次数、总下载次数、收入、预订以及更新数据。每个指标都可以按区域、来源类型、设备等过滤条件来显示，帮助您了解推动 app 发展和成功的因素。此外，从 2021 年 9 月 20 日起，所有销售指标都将包括来自 Apple 校园教务管理和 Apple 商务管理的数据，以及来自运行 iOS 7、macOS 10.14、Apple tvOS 8 及更早版本设备的数据。 “需在 app 内提供帐户删除”的要求将于 1 月 31 日生效 - 2021 年 10 月 06 日为提供用户对其个人数据的控制，《App Store 审核指南》在去年 6 月对第 5.1.1 条进行了更新，表明所有允许创建帐户的 app 必须同时允许用户从 app 内提出删除帐户的要求。此要求将对 2022 年 1 月 31 日起提交的所有 app 生效。我们建议您查阅任何可能要求您维护某些类型数据的法律条款，并确保您的 app 向用户清晰说明该 app 将收集哪些数据以及数据的收集方式 、相关数据的所有用途、您的数据保留和删除政策，以及指南中所述的更多内容。此类数据的例子包括电子健康记录以及销售和保修记录。此外，也请确认您产品页面上的 app 隐私信息准确无误。 新的App内购买: StoreKit 2 - 2021 年 09 月 22 日StoreKit 2：StoreKit 2 新引入了基于 Swift 的强大 API，让支持 app 内购买项目和订阅变得前所未有的简单。您现在可以轻松确定产品授权和优惠资格，快速获取用户的 app 内购买交易记录，通过简单的检查了解订阅的最新状态，提供一种在您的 app 内申请退款和管理订阅的方法，以及更多操作。StoreKit 2 还使用了 Swift 并发和 JSON Web 签名，帮助简化您检索产品信息和处理交易的方式。以上功能现已面向 iOS 15、iPadOS 15、Apple tvOS 15 和 watchOS 8 推出。App Store 服务器 API：借助现已推出的全新 App Store 服务器 API，比从前更快速、更高效地解决 app 内购买项目问题。 App 内购买历史记录：获取用户的 app 内购买交易记录。 订阅状态：确定订阅是处于活跃、已过期、计费重试状态，还是处于账单宽限期。App Store 服务器通知 (即将推出)：获取关于您 app 内购买项目的实时更新信息，让您能够为用户打造个性化的体验。现在，您还能充分利用覆盖更多用户活动的新通知类型，包括订阅到期、优惠兑换和退款等。此外，您还可以在 App Store Connect 中选择输入一条与生产环境不同的 URL，专门用于在 App Store 沙盒环境中接收服务器通知。 TLS 1.0 和 1.1 弃用相关更新 - 2021 年 09 月 21 日传输层安全性 (TLS) 是用于保护网站流量的关键安全协议。它有助于保护交换信息的客户端和服务器之间传输的数据的机密性和完整性。为实现平台现代化以及提高安全性和可靠性，互联网工程任务组(IETF) 已于 2021 年 3 月 25 日弃用 TLS 1.0 和 1.1。自 iOS 15、iPadOS 15、macOS 12、watchOS 8 以及 Apple tvOS 15 起，以上 TLS 版本亦会在 Apple 平台上被弃用，同时我们将移除其在未来发布版本中的支持。如果您的 app 已在所有连接上启用了 App Transport Security (英文)(ATS)，则无需就此再作更改。但如果您的 app 仍在使用旧版 TLS 1.0 或 1.1，请制定计划过渡到 TLS 1.2 或更高版本。我们建议您支持 TLS 1.3，因为它更快速，亦更安全。请确保您的网站服务器支持更高的版本，并从您的 app 中删除以下已弃用的 Security.framework 符号： tls_protocol_version_t.TLSv10 (英文) tls_protocol_version_t.TLSv11 (英文) tls_protocol_version_t.DTLSv10 (英文) 请在 App Store Connect 中提供额外的银行帐户信息 - 2021 年 08 月 23 日由于当地法规变更，如果您在 App Store Connect 中设置了银行帐户信息，则现在需要提供银行帐户持有人的地址。具有“帐户持有人”、“管理”和“财务”职能的用户现在可以在“协议、税务及银行业务”部分提供一个有效的地址。为了避免可能中断来自 Apple 的款项，请于 2021 年 10 月 22 日之前提供此信息。 更新版《App Store 审核指南》现已发布 - 2021 年 06 月 07 日App Store 安全可靠、值得信赖，是用户探索和下载 app 的好去处，对开发者来说也蕴藏着巨大的商机。我们对《App Store 审核指南》进行了以下更改和阐释，以便为即将发布的 OS 版本中的新功能提供支持，同时更好地保护用户，并帮助您的 app 尽可能顺利地通过审核流程。此外，App Review 联系表格 (英文) 也进行了两项更新。现在，如果您认为您的 app 遭拒是出于不公平待遇 (包括政治或其他偏见)，当您提出申诉时，您还可以就此加以说明。如果您认为某个 app 存在信任或安全问题，或者违反了《App Store 审核指南》，现在也可以举报该 app。 1.1.4：可能含有色情内容或是为卖淫活动提供便利的一夜情约会 app 将被拒绝。 2.3.1：进行了如下阐释：误导性营销 (不论是在 App Store 内部还是外部) 都可能会导致 app 从 App Store 中下架以及开发者从 Apple Developer Program 中除名。 3.1.1：进行了如下阐释：数字充值卡仅可通过 app 内购买项目在 app 内销售。但在 app 内销售并邮寄给用户的实体充值卡则可以使用 app 内购买项目之外的付款方式。 3.1.2(a)：对指南进行了如下扩充：在特定条件下，蜂窝网络运营商 app 可以在随数据套餐提供的预定义套装中，包含音乐和视频订阅。阐明了如果运营商 app 支持新用户进行 app 内购买，并且运营商提供一种机制使用户在其捆绑服务到期或终止后可恢复订阅 app 内购买项目，则运营商 app 可以包含其他类型的订阅。 3.1.3：针对允许使用 app 内购买项目以外的购买方式的 app 阐释了关于电子邮件沟通政策。 4.2：进行了如下阐释：如果 app 不能带来适当的实用价值，可能无法在 App Store 中获得批准。 4.7：格式调整，增加了 4.7.1 和 4.7.2 以清晰说明相关内容。 5.1.1(v)：支持帐户创建的 app 也必须提供帐户删除功能。 5.6 和 5.6.1 – 5.6.4：扩充了“开发者行为准则”部分，涵盖了更多的开发者信任与安全问题。本节中的新规则要求开发者的身份信息必须是准确且最新的；明确指出不允许操纵影响 App Store 体验的任何元素，比如评论和排行榜；如有大量用户举报 app 的有关问题，这可能会成为判断开发者是否遵循“开发者行为准则”的一大因素。 广告归因技术更新 - 2021 年 04 月 27 日iOS 14.5 和 iPadOS 14.5 现已支持“私人点击测量”。广告网络现在可以衡量在 app 和网站中点击广告后浏览网站的广告效果。这些信息可在维护用户的隐私的同时，用于了解哪些广告能够带来转化 (如购买或注册)。从 beta 版 iOS 14.6 和 iPadOS 14.6 起，如果广告网络使用 SKAdNetwork 3.0，即便其投放的广告未能最终获得归因，也有可能收到回传信息。最多将有五个未获得 app 归因的广告网络收到回传信息。 即将实行的 AppTrackingTransparency 要求 - 2021 年 04 月 20 日在即将发布的 iOS 14.5、iPadOS 14.5 和 Apple tvOS 14.5 公开发行版本中，所有 app 都必须使用 AppTrackingTransparency 框架来征得用户的许可，才能对其进行跟踪或访问其设备的广告标识符。除非您征得用户对启用跟踪权限的许可，否则设备的广告标识符值将全部为零，您也将不允许跟踪用户。将 app 提交审核时，您必须在产品页面的“App Store 隐私信息”部分中，为其他任何形式的跟踪 (例如，按名称或电子邮件地址) 提供声明；同时，这些跟踪将仅在通过 AppTrackingTransparency 征得许可的情况下才能进行。根据 《App Store 审核指南》的准则 5.1.2 (i)，您还需要在系统提示中包含一个用途字符串以解释为什么 app 需要跟踪用户。这些要求将从 2021 年 4 月 26 日起应用于所有的 app。特别提醒，以获取用户的唯一标识或指纹为目的而对设备和使用数据进行收集的行为，仍将被视为违反 Apple Developer Program 许可协议。 App Store 服务器通知更新 - 2021 年 03 月 10 日如果您的 app 支持“家人共享”功能，现在您可以接收新的 App Store 服务器通知，来了解家庭成员状态的实时更新了。 通过 REVOKE 通知，您能知道何时应该撤销某位家庭成员对自动续期订阅或非消耗型 App 内购买项目的访问权限。当购买者针对某项 App 内购买项目停用了“家人共享”，购买者或家庭成员离开了该家庭组，或购买者要求并收到了退款时，App Store 即会将此通知发送到您的服务器。 现在，当一个共享订阅因账单问题而无法续订，以及该订阅成功续订时，App Store 都会为每位家庭成员发送 DID_FAIL_TO_RENEW 和 DID_RECOVER 通知。 特别提醒，从今天起，在分发环境中已不再支持以下弃用的 App Store 服务器通知和顶级对象。 请立即更新您的代码，以便继续提供无缝的用户体验。 RENEWAL latest_receipt latest_receipt_info latest_expired_receipt latest_expired_receipt_info 特别提醒：采用 APNs 提供商 API 的要求将从 3 月 31 日起实施 - 2021 年 03 月 04 日基于 HTTP/2 的 Apple 推送通知服务 (APNs) 提供商 API 能助您有效利用强大的功能——例如使用 JSON Web Token (JSON 网页令牌) 进行的身份验证，更完善的错误消息，以及根据特定通知的反馈。如果您用以发送推送通知的仍然是旧版的二进制协议，请确保尽快更新到 APNs 提供商 API。APNs 在 2021 年 3 月 31 日之后将不再支持旧版的二进制协议。 IMDF 现已成为国际行业标准 - 2021 年 02 月 23 日Indoor Mapping Data Format (IMDF) 是由 Apple 开发的室内制图数据格式，您可以使用此格式为各类场地 (如体育场、机场和校园) 制作室内地图并呈现给用户，同时满足场地所有者的安全和隐私要求。得益于 IMDF，场地方无需安装信标等设施，在 iPhone 和 iPad 上便能开启 Apple 的室内定位服务。IMDF 可用于移动设备，简洁易读，且可扩展性极强，为室内空间的定向、导航和探索奠定了基础。现在，开放地理空间信息联盟 (OGC) 已将 IMDF 1.0.0 纳入行业标准。 Apple 推送通知服务的服务器证书更新 - 2021 年 02 月 10 日从 2021 年 3 月 29 日起，基于令牌和证书并连接到 Apple 推送通知服务的 HTTP/2 必须合并新的根证书 (AAACertificateServices 5/12/2020 (英文)) 以替换旧的 GeoTrust Global CA 根证书。为确保无缝过渡并避免推送通知发送失败，请在 3 月 29 日前，确认在每个通知服务器的信任库中是否都已包含 HTTP/2 接口的新旧两张根证书。请注意，由 Apple 颁发的 Apple 推送通知服务 SSL 提供商证书目前不需要更新。 利用新的广告归因技术 - 2021 年 02 月 01 日SKAdNetwork 2.2。此次更新将对多种广告格式 (例如视频、音频和交互式广告) 的浏览归因提供支持。借助相关功能，您可以在保护用户的隐私的同时，显示您所选择的广告格式，并评估哪些广告最有效。私人点击测量。iOS 14.5 和 iPadOS 14.5 的私人点击测量既可用于网站，也能用于 app。广告网络现在可以衡量从 iOS 或 iPadOS app 跳转到网站的广告点击的效果。此信息可在保护用户隐私的同时，用于了解哪些广告能有效推动用户转化 (例如购买或注册)。现在就使用 Xcode 12.5、iOS 14.5 和 iPadOS 14.5 的 beta 版本来构建并测试您的 app 吧。 AppTrackingTransparency 的要求即将生效 - 2021 年 01 月 28 日App 需要通过 AppTrackingTransparency 征得用户的许可，才能跟踪用户以及访问其设备的广告标识符。我们在去年年底暂时推迟了此要求，以给您更充足的准备时间。此要求将在接下来的 beta 更新中开始生效，并会在初春发布的 iOS 14、iPadOS 14 和 Apple tvOS 14 更新版本中公开推出。我们建议您尽快验证您 app 中的 AppTrackingTransparency 实施情况。未经用户许可，您将不允许对他们进行跟踪，且其设备的广告标识符值将全部为零。在即将发布的 iOS 和 iPadOS 版本中，我们将对 SKAdNetwork 进行增强并添加对 app 的“私人点击测量”支持，以帮助广告网络更好地对这些平台的 app 中广告进行归因。“私人点击测量”可在保护用户隐私的同时，对引导用户到网站的广告活动进行测量。更多详细信息将在稍后公布。 进一步了解用户隐私和数据使用 特别提醒：App 隐私问题的要求将从 12 月 8 日起实行 - 2020 年 12 月 04 日不久后，用户在任何 Apple 平台下载 app 之前，App Store 都会先帮助其了解该 app 的隐私保护做法。在每款 app 的产品页面上，用户能了解到该 app 可能收集的某些数据类型，以及该数据是否会关联到他们或对其进行跟踪。如果您尚未输入 app 的隐私信息，请尽快在 App Store Connect 中提供。从 2020 年 12 月 8 日起，提交至 App Store 的新 app 和 app 更新都将需要包含此信息。但现有 app 将仍可供下载。 注册新的 App Store Small Business Program - 2020 年 12 月 03 日新的 App Store Small Business Program 现已开放注册，助您加速业务创新，并推动其发展。通过将付费 app 和 App 内购买项目的收益抽成降低 15％，此计划可帮助您在业务中投入更多资源，继续构建出色的 app。App Store 上销售数字商品和服务的绝大多数开发者都将符合申请资格。申请时只需填写一份简短的报名表格即可。"},{"title":"Typora 1.0 发布了(updated)","date":"2021-11-29T03:44:30.000Z","url":"/null/typora-1-0/","categories":[[" ",""]],"content":"Typora正式版发布还真是个意外——不是因为“Free during beta”结束了，而是Typora其实已经Beta测试好几年时间。甚至Typora在0.9.9之后还发布了100+个小版本，才进入0.10.x。 Typora是一款体验挺好的Markdown文档编辑器，尤其是前几年Markdown还没如今普及的时候。Typora让你可以沉浸式地Writing，所谓所见即所思，而不会因为一些语法细节影响了思绪。我相信这是很多人选择Typora的一个重要原因。只是与几年前相比，如今市场的竞争对手太多了。文档编辑只是写作或者记录的一部分，在文档管理方面，Typora几年间也可以说是踟蹰不前，而Obsidian据说却也要发布Live Preview了。有时在细节上雕花，于大局处并无影响。 Typora没有做文档同步，不支持自定义插件拓展，设计也很干净，大概就是“一次做好一件事”的一个典型案例了。目前1.0.0正式版本需要$14.99的付费，可以支持3台设备。目测暂定是一次付费模式、而不是走订阅制，虽然之前官方在大版本更新是否会收费上也是摇摆的。 Typora最后一版Beta是0.11.18，官方其实还支持下载的。作为一个Markdown编辑器，还是良心推荐👍。 ————-更新————– Typora官方已推强更，测试版不再可用。目前我的可选替代品包括VS Code及MarkText。 "},{"title":"Wireshark插件编写","date":"2021-11-29T02:53:52.000Z","url":"/tech/wireshark-plugin/","categories":[[" ",""]],"content":"网络协议开发、调试的过程，因为bug的难以避免的存在，可能会变成痛苦的过程。编程出现bug是需要被容许的事情，毕竟大师高德纳的Tex的版本也到了3.141592653不是么~ 前段时间项目需要变更Socket长连接库的底层实现，底层库替换后需要验证应用层数据传输。直观地检查应用协议层数据的传输过程，显然比业务层做黑盒测试更直接有效。 本文简要介绍Wireshark的插件编写，这可以帮助我们更好地进行网络协议开发调试、隔离错误。并且工具的作用在于，后续的边际成本几乎为0。 WireSharkWireShark是一款很著名并且很常用的网络协议分析软件，基于pcap来进行数据包捕获，其非GUI版本是TShark，GUI版本则是使用QT来编写图形界面。WireShark最早版本发布于1998年，2006更名Wireshark。跨平台、开源，支持各种常见网络协议，并且可以支持自定义协议的解析拓展。 通常来说，我们可以使用WireShark进行网络故障诊断，检查网络安全问题，验证网络应用程序，调试协议以及学习网络协议。相信大部分接触了WireShark的人都是这样的。 WireShark的基本使用比较简单，官方/非官方资料都有介绍，有需要可以官方文档找一找。 安装WireShark可以直接使用brew：brew install --cask wireshark。 环境配置需要注意的是，WireShark支持的Lua版本不是最新的，我们需要搭配匹配的环境。 我这边使用Lua的版本是v5.2.4。如果你需要安装其他Lua的工具或者库，比如LuaRocks也需要注意版本兼容问题。 Lua可以直接用sublime进行编辑，可以配置下Build System，指定lua解析器的路径就可以。 Tools –&gt; Build System –&gt; New Build System… xxx.sublime-build 编写插件首先需要修改WireShark，注入插件代码 以下是ht.lua自定义协议的插件代码，简单做一个示例： 注册自定义协议 协议的基本包结构 数据包解析 注册监听 这是示例的效果图： 粘包处理需要注意的是上面的示例，并未涉及粘包处理以及数据包的加解密。因为基于TCP的自定义协议各自封包格式不一样，基本都需要自行处理。 TCP的粘包一般两种情况：1、单Segment（TCP包）包含多PDU（应用协议包）2、单PDU跨多个Segment 处理方法要么循环解包，要么需要WireShark为我们重新拼接TCP的Payload了。 假如应用协议上我们解析到了数据包的大小，可以这样说明协议包的大小 以上是一些基本流程。 加解密WireShark的插件是比较简单的，一般比较麻烦的是数据包加解密部分。 尽管Lua社区也有挺多基础库的了，比如常见的加解密、序列化等。但棘手的一般是自定义协议，可能会使用自定的加解密库，或者使用公开算法可能进行算法强化修改。 Lua既支持使用Lua来编写加解密库，也支持嵌入C的动态库。C的效率当然更高，但Lua库的优势在于在脚本层可以数据共享。如果加解密的过程是非幂等的（比如包之间的加解密有次序或依赖），那么恭喜你，可能要继续用Lua折腾一下了。"},{"title":"iOS开发：苹果支付2.0简介","date":"2021-11-26T07:15:09.000Z","url":"/ios/storekit-ii/","tags":[["iOS","/tags/iOS/"],["支付","/tags/支付/"],["StoreKit","/tags/StoreKit/"]],"categories":[[" ",""]],"content":"苹果重新设计实现了支付框架，并使用Swift提供了新的接口，StoreKit 2.0在今年WWDC21发布了。 更新内容苹果应用内支付历来被吐槽，不但是开发测试的麻烦，还因为错误信息的缺失以及流程上难以避免的掉单。当然也还有其他一些问题，但掉单是支付的首要问题，而这主要源于苹果为了维护其生态，将支付的帐号绑定了苹果设备体系——而这真不是一个提供通用支付该有的平台特性。 继去年StoreKit支持Xcode Sandbox Testing以及Server to Server通知之后，WWDC21发布的StoreKit 2.0做了一次升级，带来了一些新的特性，包括解决掉单问题的终极方案。 更新内容包括： 支付请求新增了appAccountToken，订单信息可以关联应用的帐号体系。appAccountToken将会是持久化的，这不同于applicationUsername（时有时无）。 支持JWS因此可以在本地校验订单。 App内发起退款。 自动续期订阅商品首购优惠资格查询。 交易历史订单查询。 基于Swift的新的异步编程模型async/await。 当然StoreKit 2.0是纯Swift的接口，并且仅在iOS 15+支持。所以旧版系统的兼容是需要的，并且旧版系统发起的订单的处理具体也需要实测。但至少在流程上掉单的问题是可以完美解决的了，这对于营收以及用户体验而言是很好的。 示例代码下面是官方的示例代码 可以看到已经使用了基于协程的异步编程模型，同步化的流程处理是更直观的，非常的简洁。 参考： 「Meet StoreKit 2」："},{"title":"iOS开发：iPhone屏幕分辨率（更新）","date":"2021-10-21T08:44:13.000Z","url":"/ios/ios-device-pixels/","tags":[["iOS","/tags/iOS/"],["iPhone","/tags/iPhone/"]],"categories":[[" ",""]],"content":"iPhone的设备设备分辨率，从iPhone 4到iPhone 13 Pro Max。 按照年中大陆范围内的iOS设备覆盖率数据统计，异形屏的市场占有率已经达到50%了，基准机型从4.7英吋的iPhone 6转为5.8英吋的iPhone X了。 手机型号 屏幕尺寸 屏幕密度 屏幕宽高(pt) 屏幕分辨率(px) 倍图 屏幕比例 4/4s 3.5inch 326 ppi 320*480pt 640*960px @2x 3:2 5/5c/5s/se 4.0inch 326 ppi 320*568pt 640*1136px @2x 16:9 6/6s/7/8/se 4.7inch 326 ppi 375*667pt 750*1334px @2x 16:9 6+/6s+/7+/8+ 5.5inch 401 ppi 414*736pt 1242 * 2208px @3x 16:9 X/XS/11Pro 5.8inch 458 ppi 375*812pt 1125* 2436px @3x 19.5:9 XR/11 6.1inch 326 ppi 414*896pt 828* 1792px @2x 19.5:9 XS MAX/11Pro MAX 6.5inch 458 ppi 414*896pt 1242* 2688px @3x 19.5:9 iPhone12 min 5.4inch 476 ppi 360*780pt 1080* 2340px @3x 19.5:9 iPhone12/12Pro 6.1inch 460 ppi 390*844pt 1170* 2532px @3x 19.5:9 iPhone12Pro Max 6.7inch 458 ppi 428*926pt 1284* 2778px @3x 19.5:9 iPhone13 min 5.4inch 476 ppi 360*780pt 1080* 2340px @3x 19.5:9 iPhone13/13Pro 6.1inch 460 ppi 390*844pt 1170* 2532px @3x 19.5:9 iPhone13Pro Max 6.7inch 458 ppi 428*926pt 1284* 2778px @3x 19.5:9 Paintcode上之前有做了一个很nice的设备分辨率关系图，通过这个图可以很容易理解和区分开发用的Points、渲染用的Pixels以及设备的物理像素点。可惜只更新到了iPhone11： "},{"title":"社区电商调研","date":"2021-07-15T13:35:28.000Z","url":"/research/community-group-buying/","tags":[["调研","/tags/调研/"]],"categories":[[" ",""]],"content":" 「叮咚买菜」的广告。 叮咚买菜是一家很年轻的社区电商，2017年上线，今年6月29日已经纳斯达克上市。虽然一直是亏损状态，却一直被资本青睐，得到红杉资本、启明创投、软银等一众机构的投资。风险资本永远在追逐未来的高效收益，相信这些机构必然是忽视不了面前的机会。人日说「别只惦记着几捆白菜、几斤水果的流量」，我觉得互联网可能进入了2.0时代，增量不再是主要的驱动力了，存量才是未来争夺的焦点。 根据艾媒咨询的数据，2020生鲜电商行业规模达4584.9亿元，比2019年增⻓了64.0%。预计未来一段时间生鲜电商仍旧保持高速增⻓，到2023年生鲜电商行业规模将超万亿。下图是社区电商的发展时间线: 社区电商的基本模式“社区电商”，是依托互联网的新零售。2014年首先出现前置仓模式，后续又出现了店仓一体化、O2O平台、社区团购等运营模式。不同模式可能契合不同消费层级的需求。2020年各大电商互联网企业争相入局，是以社区团购的模式为典型的，终端用户的争夺也继续走向下沉市场。 使用场景上，用户可以在App下单，用户通过平台的同城配送服务或社区自提的方式取到商品。品类上目前主要从蔬果生鲜切入，当平台能规模进入市场时，平台运营的品类也不再局限于食品周边，可能拓展品类到日常生活快消品，所以冲击的目标首先可能是农贸市场商贩以及超市。 社区电商主要涉及以下三部分工作： 供给端管理 仓储物流配送 需求端管理 为用户带来的便捷服务，说到底，其核心是依赖于供应链管理的优化，而不只是下单跟配送。 供给端，货源主要直接是对接产地或者供货商，各个平台根据平台的优势跟侧重点，会有差异化的策略（下文会有些案例）。 仓储物流配送，大多平台是面向大区域运营的，一般会建立 区域中心仓-城市仓-服务站-配送站/同城配送 的多级仓储物流体系。同时因为生鲜产品是高频采购商品，可能过半为生鲜产品，需要支持冷链物流跟仓储。 需求端，推广期内，一般最开始是以社区团购优惠或者补贴的形式切入，通过分享可以获得折扣、低价等方式来推广，团购可以通过熟人关系的裂变来获客。社区团购中有个关键的角色称之为团长（比如芙蓉兴盛的店长），团长通过团购群来维护客群关系。 社区电商的案例要了解社区电商，必须知道长沙，2018年在长沙有近百家团购平台混战。现在入场社区团购的就包括兴盛优选、叮咚买菜、每日优鲜、橙心优选（滴滴）、美团优选、多多买菜（拼多多）、十荟团等等。 社区团购早期的雏形，可以参考兴盛优选。芙蓉兴盛便利店在全国有17000家连锁店，芙蓉兴盛的店主们通过运营微信群，收集用户的蔬菜购买需求，再通过兴盛优选统一采购，配送至门店，最后商品由用户自提。对于用户来说，线上购物的体验延伸到了买菜的事情上；对于便利店来说，店主在便利店主业的同时，可以获得额外的提成，增加了收入。 兴盛优选兴盛优选是经典的社区团购的开拓者，长沙也是兴盛优选的大本营。兴盛优选成立于2014年，在2016年开始了社区团购这一模式，目前业务已经覆盖全国17个省1400多个地县级市10万个乡镇乡村。 官方对自己的定位： “兴盛优选是一家关注民生的互联网“新零售”平台，主要定位于解决家庭消费者的日常需求，提供包括蔬菜水果，肉禽水产，米面粮油，日用百货等全品类精选商品。” 兴盛优选从多方面控制运营成本，以下是兴盛优选的一些特点： 供应链管理：打造了“阿必达”的B2B（商户到商户）的快消品订货平台，链接上游供应商/工厂/品牌，合作商户超过30万家，这是高效供应链管理的核心 自建物流配送，搭建了“中心仓-网格仓-门店”的三级物流体系，既链接产地，也打通最后一公里。运输方面相当于区域（县城）拼单，整车运输成本会降低；另外网格仓的场地、车辆是网格站自行解决，成本核算到单量（靠单量拿绩效工资），其他的平台更多是通过快递的方式物流成本会比较高。另外冷链物流建设是必需的，不然在夏天生鲜产品无法保鲜，产品品质问题最终可能会导致溃败的结局 营销裂变：基于社区的运营，团长/店面服务15分钟范围的生活圈，门店条件是需要建100人以上的团购群，叠加门店老板的人脉关系 采用“预售+自提”的方式来运营，可以优化进货供应的管理，减少产品的损耗跟库存。 使用高质低价、复购率高的产品做平台的基础商品做引流，从国家统计局的居民生鲜食品消费数据，蔬果就是高频刚需产品，也是目前多个平台营销补贴的重点 打造当日23:00下单次日11点到达（211服务） 供应商管理：售后率处罚，售后率高于规定时可能取消供货资格 门店：水果店、菜店、便民服务店等都可以，而且它本身也有1万多家便利店门店 兴盛优选从长沙开始，运营模式已经比较完善，尤其深耕“下沉市场”，物流系统去到农村。且从官方对自己的定位可以推测，当获取到流量之后，兴盛优选还可能拓展到普通电商领域，对标淘宝、京东、拼多多等。 美团优选等基本复制兴盛优选的模式，不深究供应链方面，有也乏善可言。延续烧钱补贴模式，对新用户经常有0.01元买水果蔬菜的活动。营销手段始终是手段，联想到出行跟外卖玩家的作为，如果只为了抢人头、IPO，用户不过是PV的一个数字而已。 叮咚买菜/每日优鲜这两个是跟兴盛优选不太一样的一类模式。目前覆盖城市大概都是30个左右，大多以一线/准一线城市为主，主要在华北、华中、华东和华南地区。叮咚买菜创立于2017年5月，每日优鲜成立于2014年11月。 生鲜电商为主，叮咚买菜自定位为“食品运营销售商”，这跟兴盛优选那些是有较大的出入的 有门店经营生鲜蔬果等，也就是门店加上了配送功能，相当于临时代跑腿 供应采购：分两部分，一部分是自采购，一部分则直接与供应商合作（主要是生鲜，供应商直供社区，避免生鲜的配送成本 配送成本：客单价都在70元左右；每日有限39元起送、6元配送费、30分钟送达；叮咚买菜，则是0元起送，29分钟送达，更强调复购率。所以仓储上都采用了前置仓（也就是将仓库从远郊的物流中心前移到离消费者更近），仓储配送成本较高。 商品品类：品类较齐全，大概是3000-4000个左右的品类，包括水果蔬菜、肉蛋、水产、零食、粮油、日百等，相对强调品质 会员体系：会员价格，通过包年会员可以黏住部分用户；通过社区分享优惠进行营销推广 盒马鲜生 线下门店=超市（以吃为主）+仓储+分拣配送+在店现做现吃，线下体验，新零售模式 冷链建设，提供全品类生鲜（包括进口），能快速分拣、配送 采购：全球直采+本地化直采+自有品牌 盈利：需要高客单价、客流量高才能维持运营 目标消费客群：年轻消费者，25-45女性 运营成本较高：大门店租金+到家配送 美菜网美菜网采取“两端一链一平台”的商业模式，将农产品电商、农产品物流基地进行整合，缩短农产品流通环节，减少供应链人力，实现生产端和餐厅的对接，产地直采、终端配送。本身是供应链服务商，更偏向于toB的服务。 生鲜行业的上游很分散，下游需求基本掌握在渠道上，参与社区电商需要终端流量。对于供应链，品类、规模、利润被称为不可能三角——很难做到品类齐、规模大且利润高。 美菜网尝试转向toC，参与社区团购，但手上没流量，资本并不看好。 其他过去的10年，是资本搭载移动互联网浪潮，用官方的话来说，进行“无序扩张”的10年。信息革命从ICT领域延伸到更广泛的生活应用领域，而后也将进入算法基建的时代。我们见证了独角兽的诞生，也参与了巨头的成长。虽然很多人只是拧螺丝钉的工程师，但我们始终要记住，技术只是社会目的的实现手段。资本是中性的，而人性是有善恶的。我们不能帮忙建造一艘驶向深渊的巨轮，因为我们可能就在船上。"},{"title":"反静态分析/动态调试的基本方案","date":"2021-05-29T07:13:09.000Z","url":"/ios/ios-anti-analysis/","tags":[["逆向","/tags/逆向/"]],"categories":[[" ",""]],"content":"不同项目的安全性要求不同，对于保密性要求高的代码，需要提高程序的逆向成本。 防静态分析静态分析工具很容易从Mach-O二进制文件中获取到其中的符号表，比如MachOView、Hopper等。默认情况下，我们程序中的函数名、全局变量等都是会被导出的，也就是从符号表中可以查阅得到。有意义的符号名显然对于后续的静态分析是有很大帮助的。 符号Strip防止静态分析，首先可以做的是移除内部符号，包括数据段符号和代码段符号（全局变量及内部函数名）。 因此对于项目中不需要导出的符号，我们尽量不导出。可以在链接后进行strip掉，移除符号可以使用strip命令。Xcode支持配置（Strip Style），并且可以使用编译声明__attribute__ ((visibility(&quot;hidden&quot;)))隐藏符号。 另一方面可以进行符号混淆，或者更广范围的代码混淆。 代码混淆符号混淆需要将有意义函数符号进行替代，比如C系列的可以通过宏在编译前进行替代。符号混淆需要注意的，一个是动态语言的代码中可能会使用反射，需要规避符号混淆引起Crash；另一方面则是需要处理符号解析的问题。 除此之外，代码混淆还有两部分：①代码中的常量字符串加密，比如一些关键的key；②逻辑代码中增加垃圾代码/指令。都是为了增加逆向的难度。 字符串加密，很常用的方式便是将常量字符串转换成字符数组，再进一步可以通过预处理附加加解密功能，即使很简单的加密也会让逆向难度陡增。 逻辑代码混淆，一种简单的方式是在需要保护的逻辑中特意添加无意义代码；另外指令混淆上有些工具可以支持，比如有人通过修改LLVM在指令级别进行混淆。这些都是为了提高静态分析的成本。 防动态调试防止动态调试，主要是防止应用程序被其他进程附加并在程序运行时检测应用程序逻辑。类似开发环境调试，实际上Xcode中的也是通过attach功能，来实现调试的，debugserver是调试进程。 Unix系统中，提供ptrace的系统调用来实现调试以及对进程进行跟踪。但同时苹果也提供了PT_DENY_ATTACH选项，用于阻止调试器依附到进程。 防动态调试一个主要的实现方式，就是禁止外部进程使用ptrace调用附加到本进程。常见的方式如下： 调试、反调试、反反调试就像猫鼠游戏。逆向开发也知道部分App会进行反调试，所以也可能会hook了ptrace、sysctl和syscall这样的函数来避免被反调试。要hook系统函数，通常就是通过动态库注入。 防注入动态库注入是另一种常见的动态调试以及入侵源程序的方式。比如Xcode提供的一些工具libMainthreadChecker也正是Xcode注入的动态库。 越狱环境下，可以通过DYLD_INSERT_LIBRARIES来插入动态库并执行。非越狱环境下，则可以可以通过修改Mach-O文件并重签名。 在iOS10之前，防注入可以在编译时，在 Other Linker Flags 配置上添加下面内容： 更高版本，则需要在App中检测是否被DYLD_INSERT_LIBRARIES的方式注入了动态库了： 未被注入的情况下，env是null的。 其他的手段比如检测越狱、校验App签名（需要避免被hook的情况），结合帐号设备封禁等。"},{"title":"DNSPod要实名了","date":"2021-03-17T12:32:31.000Z","url":"/undefined/dns-dnspod/","tags":[["DNS","/tags/DNS/"]],"categories":[[" ",""]],"content":"站点Let’s Encrypt的证书过期了。本来以为是定时脚本出错了，登录DNSPod后发现原来是要求实名了。 不过是个技术博客，换一个DNS解析服务是很简单的事。以前贪方便顺手用的DNSPod，其实免费的DNS解析服务商还挺多的。除了那些☁️，像godaddy这样域名商本来也提供。看了一圈最后选择了Cloudflare，可以支持Let’s Encrypt自动更新证书的脚本。 另外顺便把博客备份到了Github Page，之前一直部署在国外的VPS上，但测速是挺慢的，部署过ss还被block了两次IP地址。Github虽然在国内可能被域名污染，但是IP是没有被block掉的，配个域名，实际是挺快的。"},{"title":"iOS国际化之RTL适配","date":"2021-02-22T02:27:27.000Z","url":"/ios/ios-ui-rtl/","categories":[[" ",""]],"content":"阿语环境界面元素采用从右往左的阅读方向。视觉适配阿语环境，通常是界面元素的Right-to-Left适配。 本文是RTL适配的简单记录。 启动参数App按照系统语言来确定UI是否使用RTL。我们可以修改设备的系统设置语言，也可以修改Xcode中项目的启动参数。 设置的路径为”Edit Scheme“ - ”Run“ - ”Options“，如下图示： 如果你希望展示的是阿语的文本，可以选择”Right-to-Left Pseudolanguage With Right-to-Left Strings“。 如果你使用的是Auto Layout，并且约束时注意规避了使用left或right进行约束，那一般情况下，界面已经大体会按RTL的方式布局的了。 如果需要指定强制使用RLT布局，可以在AppDelegate中使用代码约束如下： 对于SwiftUI预览则可以使用environment进行约束： 适配内容Layout修改如果使用的是Auto Layout，适配过程是相对简单的，使用leading与trailing替换left与right的约束。 如果使用frame布局，需要根据是否RTL，重新计算布局，工程量则繁杂得多。这对于一些技术历史背负重的项目而言，人力是个挑战。 图片适配部分本地资源图片需要进行翻转（比如有方向指引性的），可以自行翻转UIImage，也有现成API： 文本对齐方式视图布局约束正确了，但是文本对齐是另一个问题。需要根据是否RTL确定文本对齐方式。 参考官方文档介绍 Adjust text alignment to match the interface direction, if the system doesn’t do so automatically. For example, if you left-align text with content in the left-to-right (LTR) context, right-align the text to match the content’s mirrored position in the RTL context. 比如 可以根据需要调整。也可以通过hook的方式针对RTL的情况全局适配。 需要注意的是，系统渲染文本时会根据文本的Unicode编码所属语言区域进行调整。比如即使是布局正确且右对齐，如果文案内容是中文或英文，渲染时仍然按照LTR的方式渲染的，...文本截断的省略号仍然显示在右边。如果文本是阿拉伯文，则...文本截断的省略号显示在左边。 UICollectionViewUICollectionView在RTL下的适配，继承UICollectionViewFlowLayout 重写两个方法 "},{"title":"Swift的内存布局与方法调度","date":"2020-12-21T06:48:38.000Z","url":"/ios/swift-lang-memlayout/","tags":[["Swift","/tags/Swift/"],["ios","/tags/ios/"]],"categories":[[" ",""]],"content":"一个值就是一块内存区域，理解内存布局，就理解Swift中的值与类型。 内存都是一系列的0和1，通常我们称之为位（bit），二进制位是数字电路的基础。 内存、Stack与Heap通常我们把8个bit称之为1个byte，我们将与系统位宽相同的字节称为一个word字长，对于64位的系统也就是8个byte。前面介绍过虚拟内存和内存分段，我们这里需要了解的是，存储器中的数据都是经地址总线与数据总线一个word一个word的存取的，一个读取的时钟周期读取一个word。这是内存布局一些基础的前置知识。 Swift是类C的语言，Swift本身是C++编写的。在数据的内存布局上，Swift与C、C++是有些类似的，在后面我们会看到。Swift应用程序的Mach-O结构也与之前是大体一致。 程序的内存分段主要包括 栈区 堆区 代码区 全局静态区 内存的栈与堆是数据的主要存储区域，也是两种不同策略管理内存的分区： 栈区：内存操作比较简单，申请或销毁内存只需要移动栈顶指针即可，速度快。因为栈区内存会随着栈帧的回收而回收，因此只能存储值类型的数据，比如临时变量，比如Swift中的基本数据类型以及enum及struct等，并且内存都是在编译器就可确定的。 堆区：内存的申请及销毁需要发起系统调用向系统申请的，虚拟内存的申请及访问速度肯定是会比栈区的慢的，但堆区内存可以由进程自主申请创建或销毁，不会因为栈帧的销毁而销毁，因此引用类型的数据都是存储在堆区的，比如Swift中的class类型数据。 Size、Stride与AlignmentSwift提供了MemoryLayout的enum来帮助我们查看类型的内存布局信息。 比如对于如下的一个只有简单数据元素的struct结构 可以通过let size = MemoryLayout&lt;YearMonth&gt;.size来获得YearMonth这个结构的内存实际大小。 MemoryLayout支持查看内存的3个信息： 简单来说我们可以理解为，size是值连续占用的内存位置，stride是考虑了内存对齐后占用的内存位置，alignment则是类型的内存对齐大小。 比如下面的例子： 对于Swift的基本数据类型，size与stride是一样的，对于复合类型size与stride往往是不一样的，就是涉及内存对齐问题。 如上图所见，假如数据是按上面那行的布局存放的，那第一次读只能读到10bit中的一部分，第二部分还需要另一次读操作。对于10bit的数据需要两次的读操作不但是低效的，并且是不安全的——操作系统对于不对齐的内存访问也会报内存访问错误。 关于内存对齐，更多内容可以参考这里。 struct的内存布局 在这个例子中，内存布局是这样的，其实跟C是一样的 这是简单元素struct的内存模型，数据都在栈区 如果我们简单做个修改，调整两个属性的前后位置： 此时的size由9增加到了16，原因也在于内存对齐。不能将8字节的a紧接着存放在一字节的b之后，因为这样会使得Int类型数据不对齐。 因为struct作为值类型，也不支持继承，所以struct中定义的方法是直接静态派发的，也就是编译时确定函数指针位置。struct的内存布局就只有相关的属性，内存对齐即可。 相对而言，class内存布局就复杂一些。 class的内存布局如果我们将上述例子Demo的类型修改为class： 你会发现Demo的size以及stride都改变了，而且只有8字节。 class与struct的差别就在于，struct是值类型，而class是引用类型。值类型的数据都存放于栈区内存，而引用类型的数据存放在堆区内存，如前文所述。因此Demo这样的一个实例在内存中只需要保留一个指针来引用堆区的内存即可，因此它的size以及stride都只有固定8个字节（64位系统）。 (示例图片)对于class实例在堆区的内存占用，可以使用class_getInstanceSize来获取：Swift中的class需要区分是继承于NSObject类还是SwiftObject类，SwiftObject是与NSObject类似的根类。对于SwiftObject派生类实例对象的内存布局大概如下： 内存的头部都有一个isa指针，与NSObject不同的是，SwiftObject单独占用8个字节来存储引用计数，而不是利用isa指针。随后存储的是从根类到当前类的实例变量，这跟Objective-C是一样的。 swift_class与objc_class也有差异，主要新增了实例内存大小及偏移等变量。 Protocol的内存布局Swift对于协议类型的采用如下的内存模型 - Existential Container。 Existential Container包括3部分： Value Buffer：前3个word，用来存储inline的值，如果属性占用内存超过3个word，则使用堆内存，此处存储堆内存的指针 vwt：第4个word，Value Witness Table，每个类型都对应这样的一个表，用来存储方法指针 pwt：第5个word（偏移32字节，0x20），Protocol Witness Table, 用来存储协议的方法 因此协议类型的内存需要占用40个字节。 泛型Swift支持泛型实现静态多态。 范型并不采用Existential Container，但是原理类似。VWT和PWT作为隐形参数，传递到范型方法里。临时变量仍然按照ValueBuffer分配3个word，如果数据大小超过3个word，则在堆上开辟内存。 作为编译优化，泛型会为具体的类生成具体的方法，但同时也会对代码进行压缩。 方法调度Swift中protocol、enum、struct和class类型都支持方法定义。 Swift中的方法调度包括几种： 静态调度，其实就是编译时已明确的函数位置 基于Witness Table动态调度，类似C++虚函数表的方式，虚函数表存放方法函数表，通过函数表偏移来获取函数指针进行调用 基于Objective-C消息机制动态调度，继承于NSObject的类可使用的，跟Objective-C一致 struct如上文所述，因为struct作为值类型，也不支持继承，所以struct中定义的方法是直接静态派发的。 class实例对象对于继承于NSObject并且override的方法，是按Objective-C的消息机制来调度的，也就是objc_msgSend；非override的方法则是vtable方式调度。 没加@objc的实例方法，编译后在类对象中的vtable以指针的方式指向该函数的具体实现。 加了@objc的实例方法，编译后该方法函数指针会在vtable中存在，并且还存在于类对象中的method_list中。 调用上， 对于没加@objc的方法，以vtable方式调度 对于加了@objc的方法，如果不以selector来调用则是vtable方式，否则是走消息机制 对于加了dynamic的方法，则直接走消息机制 final修饰的类与方法，因为不存在被继承的情况，直接静态调度 extension定义方法对于class的extension中定义的方法，同样对于非重写的OC类的方法，是直接静态调度的，所以基类中extension定义的方法是不会被改变的，方法并不会如Objective-C那样记录到类的方法列表中。 对于没加@objc的类扩展中的方法，走的直接派发的方式，方法不暴露给Objc的调用方式，包括performSelector: 对于加了@objc的类扩展中的方法，都走的消息机制。 "},{"title":"Swift语法简要","date":"2020-12-18T14:19:08.000Z","url":"/ios/swift-lang-basics/","tags":[["Swift","/tags/Swift/"],["ios","/tags/ios/"]],"categories":[[" ",""]],"content":" Swift 5.0 与ABI稳定 Swift 版本 Xcode 版本 发布时间 重大事件 Swift 1.0 ~ 1.2 6.x 2014 语⾔发布 Swift 2.0 ~ 2.2.1 7.x 2015 对协议，泛型能力进一步扩展，开始支持 Linux，随后出现了以 Swift 语言为核心的后端框架 Perfect，Vapor，Kitura Swift 3.0 ~ 3.3.1 8.x 2016 发布了 Swift Package Manager，同时以 GCD，Core Graphics 为代表的基础库 API 风格发生了大幅度转变，摆脱了 Objective-C 时代的烙印 Swift 4.0 ~ 4.1.3 9.x 2017 在整体的语法，使用和理念上基本定型，提出了 Codable 协议，同时 Xcode 的 Swift Syntax Mirgration 的最低版本固定为 4 Swift 4.2 ~ 4.2.4 10.x 2018 Swift社区从邮件列表转向论坛，语言小幅升级，主要是功能完善，性能提升，同年 Swift for TensorFlow 发布并开源 Swift 5.0 ~ 5.0.3 10.2.x 2019 ABI 稳定，iOS 12 开始内置 Swift 运行时 Swift 5.1 ~ 5.2 11.x 2020 新增 Property Wrapper ，Opaque Type 等新的语法功能，同年 WWDC 上，Apple 发布了 SwiftUI，Combine，Catalyst 等 Swift 语言的专属 SDK 历经了5年，Swift终于在2019年3月发布了5.0版本，带来了ABI稳定。从RedMonk公布的编程语言排名看，Swift自2017年开始跃到10名左右，而Objective-C则持续下降，目前Swift排名与Objective-C相近，并列排在了11位。 从现在的发展趋势看，Swift势必替代Objective-C成为iOS/MacOS的主要应用开发语言。开发社区在项目演进尤其是新项目的开发上，更多地选择了Swift，苹果也确实在应用框架上越来越多的倾向了Swift。SwiftUI尽管还在发展中，但这也是苹果在思考融合声明式响应式UI框架的结果。 站在这个时间节点，无论是企业还是个人，显然Swift不再是一个Option，而是新的基础建设的砖头和铲子。 只从一方面去评价语言的优劣是不够的，语言的流行程度受到应用场景与需求的限定。很多人不一定喜欢JavaScript，但不妨碍JavaScript作为Web开发的主流语言。对于Swift，尽管吸纳了很多其他语言的特性，但为了兼容Objective-C以及其他考虑，显然也做了很多compromise。语言的发展都是平衡的产物。Chris Lattner在WWDC 2017上有过一些对Swift语言特点及后续发展的看法，有兴趣可以查阅这里了解。 本文将整理Swift的一些语法概要，方便一些小伙伴可以30分钟内对Swift语言特性有一个基本的认知。 语言文档官方文档： 中译文档： 基本概念Swift是一门编译型、静态类型、强类型的编程语言。 编译型是指会源码直接编译为（特定平台架构下的）二进制可执行文件，解释型（通常说的脚本语言）则并不会。解释型语言（在不同平台下）有一个源码解释器，其在运行过程中才将需要执行的源码（或者中间字节码）转换为机器码。因此编译型语言性能更高，解释型语言则更容易实现跨平台。 数据类型是语言定义的一部分（其定义了该类型数据可进行的操作），值是运行时的数据。静态/动态类型是以Type Check的时机进行区分的。通俗来说，动态类型选择相信编译期的数据类型声明，并在运行时才去确认数据的类型是否合法（合法是指不会因为出现与其类型定义不一致的操作而导致错误），而静态类型则在编译器是明确的。静态类型的代表有C++/Java/Go，动态类型的代表有Python、Ruby等。 强/弱类型则看编译器是否支持隐式类型转换。 在编译阶段检查类型问题，可以避免运行时不可预测的错误。 基本数据类型常量与变量 Swift中通过let/var来限定值的可变性，通过let可以声明常量，var声明变量。举例，let list = []是不可变的，而var list = []则是可变的。这跟Objc常见的Mutable的集合类型是不同的，Objective-C是通过类型来支持可变性，Mutable类型是可变的，而非可变的是另一个类型，比如NSMutableArray与NSArray。Swift通过将Array这些集合使用值类型来实现以达到这个要求。 基本数据类型 有数值（Int、Int8、Int16、Int32、Int64，float，double）、Bool、字符(串)（String、Character）。 集合类型（数组Array、字典Dictionary、集合、元组）。 String是字符串类型，比如&quot;hello, world&quot;，String的内容可以通过很多方式来访问。多行字符串使用&quot;&quot;&quot;来包括。为了能强化理解，你可以打开Xcode在Playground中来实践一下。 字面值，基础数据类型都可以直接使用字面值Literals，比如let someString = “Some string literal value”。 类型推断，比如上面的例子let someString = “Some string literal value”，Swift可以推断someString的类型，因为它使用了字符串字面量来初始化了。 类型别名，typealias CountType = Int，可以在代码中直接使用别名，let count: CountType = 10。 Swift还引入了Optional（通常译为可空类型，其实是使用Enum实现的）——要么有值，要么为空（也就是值的缺失）。通常在变量声明时，可以在类型后加上?，来声明这是一个Optional类型，例如：var name: String?声明了一个名为name的变量，这个变量要么有值并且为String类型的值，要么为空。另外还有隐式解析可空类型，声明时在类型后加上!，比如let xNotNil: String! = “aaa”，指定该变量不应为空。普通可空类型可以为空，取值时必须变量名!（但通常我们会配合if let或guard let等方式来取值）；隐式解析可空类型可以直接取值。Optional Binding是在if等语句中，可用来对可空类型取值的，如果没有就是nil。可选链不赘述。 值类型与引用类型 Swift中的数据，要么是值类型，要么是引用类型。引用类型实例内存是按引用计数的，这是不同之处。struct是值类型，class是引用类型。 重复提醒：Swift是一门强类型语言，这意味着值不能进行隐式类型转换，不同类型之间转换必须通过显式的类型实例化过程。比如Int与Int64两个类型之间赋值，是需要显式的类型转换的，let a: Int = Int(a64)。 另外注释与C系列的一样，单行注释//、多行注释/**/，但Swift的注释支持嵌套多行注释了。 基本运算符Swift是类C的语言，基础运算符跟C或其他语言都类似。 算术运算符：+ - * / % 比较运算符：== != &gt; &lt; &gt;= &lt;= 逻辑运算符：! &amp;&amp; || 三元运算符：? : 区间运算符：a..&lt;b半开区间、a...b闭区间、[..i]或[i..]单侧区间 集合类型（数组、字典、元组）几种集合类型：数组Array、字典Dictionary、集合Set、元组。 集合是序列的一种，序列Sequence协议： Sequence协议要求集合类型支持迭代遍历，比如 会被编译器翻译为： 集合类型遵循Collection协议，Collection继承于Sequence： 集合类型在Sequence的基础上扩展了下标访问、元素个数能特性。我们常用的集合类型Array，Dictionary，Set都遵循该协议。 流程控制for-in、while、if、guard、switch、continue、break、fallthrough 含义都比较直观，只是switch多分支判断中，case内结束默认是break了，除非fallthroght。 函数function类型在swift语言中是first class citizen，其语法规范大概如下： 参数标签若与参数名一致，则可省略；参数标签也可以使用_，调用时可省略参数名（标签）。函数支持return隐式返回、默认参数值、可变参数、inout参数（&amp;），并且支持嵌套函数。 闭包“闭包就是一个匿名的函数体” 🆚 “函数是一个有名称的闭包” 这是一个闭包表达式的语法。 闭包利用上下文推断参数及返回值，支持尾随闭包、隐式返回单表达式闭包，使用$0引用参数，这些都是编译器的一些语法糖。 比函数体晚执行的（通常是异步处理）称为逃逸闭包，需要使用@escaping进行修饰。 Class与Structclass与struct是Swift中使用最广泛的类型。 0、类型声明、初始化、实例化 1、存储属性与计算属性 计算属性就是提供get/set方法的属性方法，依赖其他数据，一般作为便捷访问方法； 存储属性拥有存储空间，相当于Objc类中拥有实例变量的属性。extension中只能声明计算属性，而没有存储属性。 2、方法 其实class、struct、enum中都可以声明方法，方法就是类型中定义的函数。类型、属性与方法都有权限修饰（见下文）。 3、对象模型 Swift中的类（class）可以继承，也可以不继承其他Swift类。不继承其他类的，实际上他们都是SwiftObject的派生类。也就是在Swift中有SwiftObject与NSObject两个根类）。Swift跟Objc一样其实是单一继承链。但不一样的是，Swift中的协议可以通过extension来提供默认的协议方法实现，使得Swift中的类能获得类似Mixin的能力。 struct是值类型，不支持继承。 4、内存模型 struct与class的区别，首要在于值与引用的区别。引用意味着class的实例可以是共享的，而struct的”实例”都是copy的。值与引用各有其适用场景，值可以避免数据跨域的污染，而引用则有利于内存优化。 内存管理上，Swift类依然使用引用计数。如上面提到的，Swift为了支持与Objective-C的互操作，设计了SwiftObject的根类。可以参考Swift的Github站点上对class的TypeMetadata的说明。 destructor(-2)/isa(0)/super(1)//reserved(2,3)/rodata(4,低位1是swift)/class(5,32bit)/instance addrp(32bit)/instance size(32bit)/… 具体的内存布局我们会另外再说明。 5、权限修饰：open/public/internal/fileprivate/private open：访问不受限，外部类可以继承、override方法，对于模块定义的类，如果允许外部进行继承是需要修饰为open的；public：访问不受限，但仅本模块可以继承、修改方法/属性；internal：访问限制在模块内部；fileprivate：访问限制在同一文件内部；private：访问限制在类内部； 一些常见协议自定义输出支持： 调试输出支持： 可散列化支持： 作为集合的key需要是可哈希的（hashable），实现Hashable协议能使集合数据的查找复杂度降低到O(1)。 自定义类型实现Hashable的方式，可以重写hash(into:)方法。如： 基本数据类型是可哈希的。 比较运算支持： 序列化编码支持： Swift 4.0引入Codable使得可原生支持模型JSON转换。 案例： // 编解码过程 对于需要自定义key的可以内置一个CodingKeys的enum定义来提供。如： 特性修饰词特性修饰词是进入Swift开发非常常见的。 @main声明为Swift程序入口 @available nonobjc废除一个隐含的objc特性。 objc用 objc 特性标记的类必须继承自一个 Objective-C 中定义的类。如果你把 objc 用到类或协议中，它会隐式地应用于该类或协议中 Objective-C 兼容的成员上。 objcMembersSwift中定义的方法默认是不能被OC调用的，除非我们手动添加@objc标识。但如果一个类的方法属性较多，这样会很麻烦，于是有了这样一个标识符@objcMembers，它可以让整个类的属性方法都隐式添加@objc。 dynamicCallable与dynamicMemberLookup前者实现dynamicallyCall(withArguments:)或dynamicallyCall(withKeywordArguments:)，实例可视为可调用函数，也就是instance(…)是可以的。 后者类型必须实现一个 subscript(dynamicMemberLookup:) 下标脚本方法，动态的通过.属性的方法来访问查询。比如： escaping逃逸闭包声明。 propertyWrapperSwift 5.1开始支持@propertyWrapper，属性封装器。@propertyWrapper是Swift 5之后非常重要的特性，应用场景也很多。SwiftUI的推出，@State，@Binding，@EnvironmentObject 等这些都依赖于属性封装器的支持。 包装器必须定义一个 wrappedValue 实例属性。包装属性的值就是这个属性暴露的 getter 和 setter。大多数情况下， wrappedValue 是一个计算值，但也可以是存储值。 包装器定义和管理任何被包装值需要的存储。编译器会通过在包装的属性名称前添加下划线（ _ ）来合成对应实例所需要的存储——比如说， someProperty 的包装器会以 _someProperty 的形式存储。包装器合成存储的访问控制权限为 private 级。 propertyWrapper大概有4个用例场景： 值约束 属性赋值时进行值转换 改变合成的比较语义 属性访问检查 详细可查看nshipster。 包装属性的投射值就是属性包装器可以用于暴露额外功能的第二个值。属性包装器类型的作者负责决定投射值的意义并且定义暴露的投射值的接口。要从属性包装器中投射值，在包装器类型中定义 projectedValue 实例属性。编译器会通过在包装属性名称前添加一个美元符号（ $ ）来为投射的值合成标记 testable允许测试模块像public一样访问internal的的代码。 @State、@Binding、@ObservedObject、@EnvironmentObjectSwiftUI内容。"},{"title":"iOS音频：AAC文件结构","date":"2020-11-29T06:34:21.000Z","url":"/ios/ios-audio-aac/","tags":[["iOS","/tags/iOS/"],["音频","/tags/音频/"],["AAC","/tags/AAC/"]],"categories":[[" ",""]],"content":"AAC音频压缩是MPEG-2及MPEG-4规范的一部分，AAC是除MP3外另一种常见的音频数据编码方式。尤其是在音视频领域，主流的音视频编码标配是H264+AAC，其中像TS、RTP、FLV、MP4都支持AAC音频编码。FAAC是开源的AAC编解码器。 AAC编码的发展历程1988年ISO/IEC标准化组织成立了MPEG专家组来开发通用的运动图像、声音及其组合的国际标准。自1988年以来，ISO/MPEG承担了很多的音视频编码的标准化工作。 1992年末，MPEG完成了MPEG-1视频编码标准，最后被采纳为ISO/IEC IS 11172标准。与之对应的音频部分分为三种模式，从Layer-1 到Layer-3编码，音频质量逐步提高。MPEG-1 Layer-3就是我们所知的MP3。 后来MPEG-2在两方面对于MPEG-1进行了扩展（音频部分）：①对于5.1声道的支持，适应通常所谓的电影院音响效果；②增加了对于16kHz、22.5kHz、24kHz采样率的支持。同时MPEG-2保持音频编码的后向兼容性，这就是MPEG-2 BC（Back-Compatible）。 AAC首先引入是在MPEG-2标准的part 7。在发现放弃兼容性可以提高编码的效率后，MPEG便放弃了兼容性要求，并成立了一个新的工作项目，定义为AAC（Advanced Audio Coding），并于1997年形成了国际标准ISO 13818-7。AAC标准是不兼容MPEG-1的，也被称为MPEG-2 NBC。 AAC有很多新的特性。它支持从8k到96k的各种采样率，支持多种声道配置方案。与MP3相比，压缩比更高，提高了音频质量，也使AAC拥有更优异的编码质量和性能。 AAC有多种规格，其中AAC LC、AAC HE V1和AAC HE V2是常见的。 AAC LC（Low Complexity）低复杂度规格，码流128kbps，音质较好，但是码流太大了。 AAC HE V1：HE是指”High Effective”，AAC HE在AAC LC的基础上增加了SBR（Special Band Replication，频段复制）。音乐的主要频谱集中在低频段，高频段幅度小但包含音质细节。但如果按高频段的编码标准编码整个频段，则输出文件过大。SBR对频谱进行切割，低频段单独编码保存主要成分，高频单独放大，保存音质。这是一种平衡。最终码流在64kbps左右。 AAC HE V2：在V1的基础支持了PS（parametric stereo），参数化立体声。原来的立体声文件是双声道，文件输出是单声道的两倍。但双声道声音有相似性，只需要存储一个声道，另一个用参数进行描述。码率进一步降低，可以到48kbps甚至24kbps。 总的来说AAC编码支持8KHz-96KHz采样率范围，码率在8kbps-576kbps之间，最多支持48声道。 AAC音频数据包格式AAC音频被支持的几种容器格式 互联网媒体类型： AAC支持的封装格式： ADIF（Audio Data Interchange Format），必须从音频的头开始才能解码。 ADTS（Audio Data Transport Stream），每一帧单独解码，这是我们常见的音频流封装格式。 LATM/LOAS，其中LATM提供了为多个AAC流进行multiplexing的方法，而LOAS则用来为LATM数据包添加同步信息 本文主要涉及的是ADTS封装格式的AAC文件结构。 ADTS 帧头如上所述，ADTS每一帧可以单独解码，因为ADTS的头部包含了音频数据的基本信息。如下所示： 每个ADTS帧都包含一个ADTS Header以及ADTS ES（Elementary Streams，原始流）。 ADTS Header一共7个字节或者9个字节（若有CRC校验），分为两部分：adts_fixed_header以及adts_variable_header，每部分分别占28个bits。 下面是ADTS Header的位解析（来源multimedia）AAAAAAAA AAAABCCD EEFFFFGH HHIJKLMM MMMMMMMM MMMOOOOO OOOOOOPP (QQQQQQQQ QQQQQQQQ) 其中adts_fixed_header部分: Offset Letter Length (bits) Meaning Description 0 A 12 syncword 同步字，始终是 0xFFF, 代表ADTS帧的开始 12 B 1 MPEG Version 0 for MPEG-4, 1 for MPEG-2 13 C 2 Layer always 0 15 D 1 Protection absent 是否有CRC校验 16 E 2 Profile AAC规范等级，等于 [MPEG-4 Audio Object Type] - 1 18 F 4 Sampling Index 采样率索引 (15 is forbidden) 22 G 1 Private Bit guaranteed never to be used by MPEG, set to 0 when encoding, ignore when decoding 23 H 3 Channel Configuration 通道配置，2表示立体声 26 I 1 Originality set to 0 when encoding, ignore when decoding 27 J 1 Home set to 0 when encoding, ignore when decoding 可以看到与MP3帧类似的是，采样率、通道配置这些都是固定参数，不同的是ADTS将这些3个半字节也附加到每个帧中，这样ADTS帧的解析是没有其他依赖的。 可变部分adts_variable_header: Offset Letter Length (bits) Meaning Description 28 K 1 copyrighted id bit the next bit of a centrally registered copyright identifier, set to 0 when encoding, ignore when decoding 29 L 1 copyright id start signals that this frame’s copyright id bit is the first bit of the copyright id, set to 0 when encoding, ignore when decoding 30 M 13 Frame Length ADTS帧长，包括头部及原始流，头部为7或9字节 43 O 11 Buffer Fullness 0x7FF 代表是码率可变的，VBR，0x000则是固定码率 54 P 2 Number of AAC frames(RDBs) ADTS帧中至少一个AAC的原始数据帧，因此此处是 Number of AAC frames(RDBs) in ADTS frame minus 1。一个AAC帧为1024个采样 56 Q 16 CRC CRC if protection absent is 0 各字段语义上如下图所示： 根据头部的Frame Length帧长以及是否有CRC可以计算出ADTS帧中AAC帧的长度，从而可以读出AAC原始数据帧。 一些参数Aduio Object Type Sampling frequency index: Channel Configuration:"},{"title":"iOS音频：MP3文件结构","date":"2020-11-29T03:03:43.000Z","url":"/tech/ios-audio-mp3/","tags":[["iOS","/tags/iOS/"],["音频","/tags/音频/"],["MP3","/tags/MP3/"]],"categories":[[" ",""]],"content":"MP3 (MPEG-1, 2, 2.5 Audio Layer III)是常见的音频编码方案，可以支持8-48kHz采样率、8-320kbps的比特率。MP3有大量的软硬件支持，兼容性好，压缩比也比较高，尤其适合于128kbps以上的音乐音频编码。 概述MP3文件可以分为两部分：元数据+音频数据。 元数据，主要是音频专辑、创作者等信息，目前一般是两种格式：一种是ID3V2格式，一种是ID3V1格式。其中ID3V2在文件头，长度不固定，而ID3V1在文件结尾位置，长度固定为128字节。 音频数据，具体来说，是一系列音频数据帧（Frame），每一帧是独立可播放的。每一个音频帧，又分为帧头跟数据载体，也就是Header与Payload。帧头又记录了该帧的采样率、比特率等信息。实际上Frame Header是我们主要研究的对象，因为这就是格式规范所在。 因此可以理解为，MP3文件=[ID3V2]+音频数据（Frame）+[ID3V1]。 我们可以先看下面这张结构示例图（来自wiki）： 元数据：ID3V2与ID3V1ID3是一个音频文件标签的标准，详细可以参见官方文档。 ID3V1标准其字节分布： 位置（字节） 长度（字节） 说明 0 3 “TAG” 3 30 歌名 33 30 作者 63 30 专辑名 93 4 年份 97 28 附注（Comment） 125 1 保留 126 1 音轨号 127 1 MP3音乐类别（Genre Identifier） ID3V1的前3个字节为”TAG”。可以看到，ID3V1固定128字节无法拓展，存放信息较少（比如封面图等）。但ID3V1.1仍有不少支持。 ID3V2则是一个容器格式，允许拓展新的数据片段。ID3V2标签支持Unicode编码，并且ID3V2存放在音频文件文件头，使得实现音频流（streaming）更方便。另外，ID3V2对包含音乐同步的歌词也是支持的。目前主流的是ID3V2.3标准。 ID3V2.3的标签，每个标签都有一个标签头与若干标签帧或一个拓展标签头组成。 标签头ID3V2.3的标签头为10个字节，具体如下定义： 一个典型的ID3v2.3的文件头：49 44 33 03 00 00 00 00 72 54 52 43 4B 00 00 其文件头开始是”ID3”，其版本0x3，副版本0。 Flag也是一个字节，也就是0bABCxxxxx，只定义了前3位，A是否非同步，B是否有拓展头部，C是否测试。 标签大小4个字节，但每个字节首位不用（&amp;0x7F），也就是：0xxxxxxx 0xxxxxxx 0xxxxxxx 0xxxxxxx。 标签帧每个标签帧都有10个字节的帧头与至少一个字节的不固定长度内容。 帧标识用4个字符表示，说明一个帧的内容含义。 帧大小Size固定4个字节，8位都有效。 标识Flags为ABC00000IJK00000 音频数据帧音频数据由一系列数据帧组成。每个帧的长度可能固定（CBR），也可能是不固定的（VBR）。每个帧都包括帧头与载荷数据。 Frame Header为4个字节，也就是32Bit。这32Bit中可以定义音频帧的版本格式、比特率/采样率、声道模式等。 具体含义参见下表： 帧头11位标志位，以FF开头。第16位是CRC标志位，为0时表示有CRC校验。如果有CRC校验，则帧头最后还有16bit的校验位。 其中的比特率、采样率索引表如下（需要结合版本，比如常见的MPEG V1,L3）： 常见的比特率如128kbps、192kbps以及320kbps，常见采样率就是44.1kHz。 在MPEG-1 Layer III中，有些特定的比特率需要与特定的声道模式组合才可使用： 比特率 允许的模式 free all 32 single channel 48 single channel 56 single channel 64 all 80 single channel 96 all 112 all 128 all 160 all 192 all 224 stereo, intensity stereo, dual channel 256 stereo, intensity stereo, dual channel 320 stereo, intensity stereo, dual channel 384 stereo, intensity stereo, dual channel 音频帧长度每个音频帧都是压缩后的音频数据，MPEG音频帧的每一帧的采样数都是固定的。具体数值参见下面图表： 每一帧的长度（byte）为：FrameLengthInBytes = SamplesPerFrame * BitsPerSample / 8 * Channels 对于比特率，我们知道：BitRate = SampleRate * BitsPerSample * Channels，于是： FrameLengthInBytes = SamplesPerFrame / 8 * BitRate / SampleRate 这些参数都是每一帧帧头都有的字段。 需要注意的是，比特率是不固定的，因此数据帧的长度也不是固定的。并且为了适配比特率（使其精确满足比特率），有时还需要进行数据填充。比如对于128kbps比特率、44.1kHz的Layer III的数据帧，我们可以计算到帧长为417.96这样的奇怪帧长，但实际上编码时大部分的帧会使用418字节的帧长，而少部分帧是417字节。而音频帧头固定为4字节，所以整个MPEG帧大小为422字节。 所以帧长的计算修正为：数据帧长 = 每帧采样数 / 8 * 比特率 / 采样率 + 填充大小 对于Layer I的帧填充为4字节（slot大小），而Layer II和III的填充位则是1字节。于是： 一个数据帧是否有填充位是由帧头的第22位来标识的，参见上面的图。 对于单个MP3文件而言，其音频采样率是固定的，可变的是各个帧所使用的比特率。而CBR与VBR的区别也正是在于此。 音频帧时间每帧固定采样数，因此每帧的时间为： 比如对于常见的44.1kHz采样率的MP3文件，其每帧持续时间为： MP3的播放时间CBR的时间计算对于CBR的计算时间是很直观的，知道音频的比特率及文件大小即可： FileSize严格来说应考虑除元数据外的音频数据大小，但通常标签数据相对于整个文件大小而言可以忽略不计。 VBR的时间计算VBR计算播放时间，一种方式可以通过计算MP3文件的平均比特率，然后套用CBR的方式即可。但准确的平均比特率需要遍历整个MP3文件的，如果只是在文件头部采样（常有音乐沉默），可能会失真。 VBR变的只是帧的比特率，采样率是固定的，每一帧的时间也是固定的。所以另一种计算方式是根据总帧数来计算时长。 要获知总帧数，最基本的方式仍然是可以进行遍历。但更高效的方式，显然也已经有人想过了——通过拓展头部记录总帧数。在第一个音频帧的音频数据区附加一个VBR头部，在其中记录总的帧数，已经是业界的事实标准。并且为了快速seek time，VBR头部中通常还附加了一个TOC的目录。 VBR头部VBR头有常见的几种：XING、VBRI及LAME头部。单独说一下 XING头XING头是XING公司推出的规范，大多数VBR的音频文件都添加了XING头。 XING头位于第一个音频帧的帧头之后（某个位置，通常是0x24的偏移）。包含XING头的整个第一个数据帧没有音频数据，因此即使解码器不处理XING头也可以解码。 首先需要定位MPEG第一帧，从文件头开始读取元数据（ID3V2.3标签头及各标签帧），然后通过MPEG数据帧头11个1的bit去定位第一帧的帧头位置。XING头在CBR中也可能存在，此时头部标识就不是XING而是Info了。 在MPEG音频的帧头的后面，有一些解码器会用到的一些信息，用于解码器控制音频流的播放，叫做边信息。边信息大小可参考：对于MPEG-1 Layer III而言，边信息大小就是32Bytes，因此就是MPEG数据帧头的36Bytes（也就是0x24）的偏移处。 XING头的字段如下： 位置（字节） 长度（字节） 含义 示例 0 4 4个ASCII字符的VBR头 ID，要么是Xing，要么是Info，无NULL结尾（普通字符串都以NULL,即\\0结尾） ‘Xing’ 4 4 存放一个标志，用于表示接下来存在哪些域/字段,各字段逻辑或的结果：0x0001存在总帧数（Frames）字段0x0002存在文件大小（Bytes）字段0x0004存在TOC字段0x0008存在音频质量指示字段 0x0007 就表示下面存在：总帧数文件大小总字节数TOC表 8 4 总帧数(Frames)，大端[可选] 7344 8或12 4 文件总大小，单位字节，大端[可选] 45000 8，12，16 100 TOC表，大端[可选] 8或12, 16, 108, 112, 116 4 音频质量指示，最差0，最好100，大端[可选] 0 VBRI头VBRI头通常只存在于用Fraunhofer编码的MPEG音频文件中。并且位置是固定的。 VBRI头的字段如下： 位置（字节） 长度（字节） 含义 示例 0 4 4个ASCII字符的VBR头ID：“VBRI”无NULL结尾 “VBRI” 4 2 版本ID，大端，类型：DWORD 1 6 2 延迟，类型：float 7344 8 2 音频质量指示 75 10 4 文件总大小，大端，类型：DWORD 45000 14 4 总的帧数，大端，类型：DWORD 7344 18 2 TOC表的表项数目，大端，类型：WORD 100 20 2 TOC表项的缩放因子，大端，类型：DWORD 1 22 2 单个TOC表项的大小，单位字节，最大为4，大端，类型：DWORD 2 24 2 帧数/表项，大端，类型：WORD 845 26 用于检索的TOC表，整型值，可以通过每个表项大小乘于表项个数得到此TOC表的总大小，大端 LAME头参考此处 MP3的压缩比以采样率为44.1kHz为例。 原始PCM编码的音频数据，每秒的数据量为： 对于双声道、16位量化深度来算，DataSize=2 * 44100 * 16=1411200的bits。 而该原始音频数据使用MP3编码后，以128kbps比特率CBR的为例： 也就是DataSize=128000的bits。 因此压缩比： 比特率越高，压缩比越低。 对于上述128kbps的MP3的压缩率，压缩比是 1411200 / 128000，大约是11左右。 对于MP3文件解析的示例，可以参考此文有完整的MP3文件解析的示例 参考：MP3’s Tech: "},{"title":"iOS音频：数字音频基础","date":"2020-11-15T06:34:28.000Z","url":"/ios/ios-digital-audio-basic/","tags":[["iOS","/tags/iOS/"],["音视频","/tags/音视频/"]],"categories":[[" ",""]],"content":"在学习音频开发之前，我们需要了解声音及音频的一些基本知识，比如声音的原理还有音频数字化。 声学基础人耳是一个完整的听觉感知系统。引用wiki上的定义，人的听觉是，声波通过外耳和中耳组成的传音系统传递到内耳，经内耳的环能作用将声波的机械能转变为听觉神经上的神经冲动，后者传送到大脑皮层听觉中枢而产生的主观感觉。简单点说，听觉是声波引起的主观感觉。 下图是人耳的结构示意图： 从生理上分，人耳主要包括耳廓、耳道、鼓膜、听小骨、半规管、听觉神经、耳蜗和耳咽管。外耳区与空气接触，鼓膜外侧承受的是空气气压；中耳是空气不流通的腔体，但经咽鼓管连接咽喉部，平时吞咽动作是会开放咽鼓管，空气可以进入中耳达到耳压平衡。内耳耳蜗内部则是充满淋巴液的，听小骨的镫骨连接到内耳耳蜗的卵圆窗。 我们知道声音是一种纵波，振动源扰动介质发生压缩与拉伸变形，形成声波进行传播。声音传播的介质也很多，固体、液体、气体等都可以（骨传感耳机就是固体介质的一种应用）。通常来说，声波经空气的振动传导到鼓膜，鼓膜两侧的压力差，导致鼓膜振动，这是听觉的第一步。我们看一下声音在空气中传播的示意图： 上图的下半部分是声音在空气中运动的示意，上半部分是声波对大气压扰动（都是单一频率示意）。 人耳可感知的最小压力变化是大气压的十亿分之一，这种灵敏度得益于外耳和中耳结构产生的放大作用。内耳充满了流体，如果没有中耳，让鼓膜直接激发内耳，效率是很低的；再者鼓膜拾音依赖压力差，中耳的腔体正是拾音的快速压力波动的需要。 外耳道的长度平均在2.5-3cm，其一端是鼓膜，一端是开放的。这个半封闭的腔体在鼓膜处会对3-4kHz左右的声波产生共振使信号加强，另外3次谐波信号也会得到加强，这是外耳道的放大效应。而中耳道的听小骨其实是3块骨头，锤骨、砧骨、镫骨。鼓膜与锤骨相接，声音经外耳道引起鼓膜振动，再经锤骨、砧骨、镫骨的杆杠结构，将振动传递到内耳。典型的鼓膜有效振动面积55平方毫米，而连接内耳卵圆窗的镫骨底板3.2平方毫米，这个可以将波动放大17倍，再加上听小骨1.3倍的杆杠可以将声波放大22.1倍，相当于27dB。 内耳的机理则相对复杂，简单来说就是镫骨底板传动引起淋巴液沿着耳蜗基底膜的运动，基底膜顶部有很多称为“柯蒂氏器”的结构，其上有纤毛细胞、内部连接了神经纤维。基底膜及淋巴液的运动会使纤毛发生偏移，使得钾钙离子得以进入并触发神经脉冲。耳蜗大概是2.5-2.75圈，展开长度约3.2cm，这些不同位置的基底膜对不同频率的反应不同，一个脉冲即可确定频率，而声压则影响了脉冲的多少。 以上是听觉的基本过程。 声音三要素我们对声音的感知主要体现在三方面：音阶（调）、响度和音色，音阶、响度与音色是人的主观感受。 声波的基准频率决定了声音的音高，频率越高，音调就越高、声音就越尖锐，反之声音越低沉；声波的振幅越大，声压就越大，人耳感受到响度就越大；而音色，我们要知道自然界的声音不是单一频率的，而是多种频率混合在一起的——不同的声音的基本波形是由不同的谐波组成的（用音乐的术语就是在基准音的基础上产生泛音，然后形成一个音色的）。声源除了整体的振动，还有局部的振动，不同的器质会产生不同的组合，这也就会产生音色的区别。 我们通常用分贝来表示声压的大小，贝尔是一个对数比值，而不是一个绝对的测量单位。公式中pref是参考声压振幅，prms是采样点振幅： $$ Lp=20\\lg{\\frac{prms}{pref}} $$ 音阶、响度与音色虽然分别对应着声音的频率、波幅以及波形，但不是等同关系。而且同等声压下，不同频率其实有不同的听觉感知的。等响度曲线就是主观测定得到的描述不同频率、声压下的一簇听觉感知曲线。 举个例子来说明等响度曲线：1kHz10dB的声音给人的听觉响度大概是10方，而对于100Hz的声音需要达到这种效果，需要将声音提高到30DB。 从上面的等响度曲线图我们可以看到，高声压比低声压有更宽的频响范围。人耳对低频声音很不敏感，而对4khz附近的频率则比较容易捕捉到。上图中曲线簇在2kHz-5kHz之间都有一个明显的下凹陷，凹陷意味着该频率下更低的声压级也能达到相同听觉感知。这段频率的高灵敏度响应是感知人声的重要条件。等响度曲线在3.5-4kHz以及13.5kHz有凹陷峰值，这是有生物学基础的，是上文提到的外耳道谐振引起的。 从模拟信号到数字音频想象一下，声音经过麦克风，最终怎样才被记录在设备上，又是怎么被播放出来的？ 自然界的信号都是模拟信号，模拟信号是时域连续信号。如果以模拟信号的形式，声音是不便于存储与传输。在现在熟悉的数字音频使用之前，声音的录制与回放其实也经历了漫长的发展过程。 1857年Scott发明的声波振记器，将声音振动转化记录到纸上，最早的声音录制设备；1877年爱迪生发明了圆筒型唱片和留声机，声音转化为金属针的振动，波形记录在圆筒形的锡箔上；1887年Berliner发明圆片型唱片合平面式留声机；1898年磁性录音机在丹麦问世，利用的是剩磁原理；1912年圆筒式录音被淘汰；1924年电气唱片刻纹头问世；1931年密纹唱片问世（LP唱片，黑胶唱片）；1935年德国通用电气公司研制磁带录音机（二战后美国获得了该技术）；1963年荷兰飞利浦公司生产音频盒式磁带；1976年索尼公司研制出激光唱片（CD）；1996年DVD统一格式；1997年便携MP3播放器问世，MP3的发展基于60’s和70’s的LPC、DCT等编码研究基础； 现在很多人都知道曾经流行了40年的黑胶唱片，却不一定了解唱片的历史与未来。 在电子与信息科学广泛发展应用之前，声音只能通过物理机械记录或者磁记录的方式进行存储。磁记录是电子时代很重要的存储技术，可以利用交流偏磁原理进行音频记录，后续利用其逆向作用可以回放声音，这跟机械运动记录道理是一样的。（下图是偏磁录音原理） 无论是原始的机械记录或是磁带录音或是现在的数字音频，都是需要对声波转储以及还原，实现声音的录制跟回放。与现在的数字音频不同的是，机械记录或者磁记录的过程其实是时间连续的，而搭载在电子电路之上的数字音频，无论时间或是数值却都是离散化了。电子电路、数字信号处理的发展，使得信号可以通过电子器件进行存储、通过电路进行传输，这也把我们带进了数字音频时代。 采样与量化音频在数字化之前，还要解决电信号转换的问题，才能搭载在电子电路上传输。拾音器与扬声器是其中非常重要的器件。 拾音器是利用电磁特性实现声音与电信号的转换。目前麦克风主要有两种，动圈式以及电容式。动圈式麦克风利用的是电磁感应原理，将线圈搭载在振膜上并置于磁场中，当声压引起振膜运动时，会在线圈中产生感应电流。而电容式麦克风则利用电容器的充放电原理，振膜改变电容极板的距离，会改变电容大小，从而引起电流。一般来说，电容式麦克风比动圈式灵敏度更高，频域也更宽。 当声音从声波转化为电信号后，要搭载在数字电路来存储传输，还必须转换为数字信号。FM/AM收音机很多人都还用过，广播的音频信号其实就是通过调频或调幅的方式搭载在载波信号上进行传输。广播的音频在传输的时候，时间是连续的，信号也是连续的。而计算机和互联网上传播的音频则不一样。 数字电路终端上的信号传输与存储，需要模数转换和数模转换，这个过程如下图所示： 模数转换的数字化过程至少需要经过采样与量化（也有内置编码），分别是时间与信号幅度的数字化。 采样就是按固定频率（即采样率）去对模拟信号进行信号强度度量，量化是对信号波幅度量并将信号强度转化为数值进行描述。采样率越高保真度越高，声音可以被还原的越好，更高的采样率意味着更多的数据量。人耳可接收的声音频率范围是20Hz-20kHz，根据奈奎斯特-香农采样定理，采样率超过40K基本可以还原所有可听到的声音了。 常见的一些采样率：8000 Hz - 电话所用采样率， 对于人的说话已经足够11025 Hz - 电话所用采样率22050 Hz - 无线电广播所用采样率32000 Hz - miniDV 数码视频 camcorder、DAT (LP mode)所用采样率44100 Hz - 音频 CD, 也常用于 MPEG-1 音频（VCD，SVCD，MP3）所用采样率47250 Hz - 商用 PCM 录音机所用采样率48000 Hz - miniDV、数字电视、DVD、DAT、电影和专业音频所用的数字声音所用采样率50000 Hz - 商用数字录音机所用采样率96000 Hz或者 192000 Hz - DVD-Audio、一些 LPCM DVD 音轨、BD-ROM（蓝光盘）音轨、和 HD-DVD （高清晰度 DVD）音轨所用所用采样率 44.1kHz是一个常用的采样率参数，标准的CD音频就使用44.1kHz，以及16位整型的量化精度。 采样是时间维度的离散化，而量化是信号值的离散化。量化的位深影响了数字音频复现的精细程度。在声音上，16位的位深可以记录声音96db的动态范围。 采样与量化涉及到的数理基础比较多，比如低通信号的脉冲抽样、插值、信噪比等等，可以自行了解学习。 数字音频基本概念原始的经过AD转换的数字音频数据，通常就是我们见到的PCM编码的音频，是没有压缩编码的。 一般可以通过以下这些参数，描述数字音频： 声道：单声道、立体声、4声道、5.1声道（杜比，.1加强人声） 采样率：脉冲采样频率 位深：采样的数值量化精度 帧：PCM不需要帧的概念；amr是20ms一帧，独立帧；mp3分vbr、cbr等 交错模式：数字音频信号存储以连续帧方式存放，先记录帧1的左右声道样本，再记录帧2的记录；非交错模式则先记录一个周期内所有帧的左声道，再记录右声道样本 比特率：码率，音乐每秒播放的数据量，对于PCM音频流，码率=采样率x量化位深x声道数； 原始音频数据未经编码还是比较大的，比如44.1kHz采样率、双声道、16位量化的音频，1分钟的数据量是：44100 * 16 / 2 * 60 * 2 = 42.336MB 这么大的数据量，无论是对存储还是对带宽的要求都挺高的。这也是为什么需要数字音频压缩算法的原因。 What’s Next以上便是音频以及数字音频的一些背景知识，之后我们将继续学习数字音频以及iOS开发上的音频相关的一些内容。 "},{"title":"iOS性能优化：MetricKit","date":"2020-11-13T08:39:50.000Z","url":"/null/ios-apm-metrickit/","categories":[[" ",""]],"content":"MetricKit是苹果提供的App内应用性能检测框架，覆盖了CPU、GPU、磁盘以及运行数据等。 MetricKit适用于iOS 13.0+的设备。它会在一天结束后，将过去24小时搜集的性能指标和问题诊断报告归集在一起，然后在下一次启动 App 后，在 delegate 的回调中提供给我们。实际使用时除了获取到过去24小时的数据，24小时之前未被收集过的数据也会一并返回。 MXMetricPayload 属性 类型 含义 补充说明 latestApplicationVersion NSString 收集此数据时的最高版本信息 考虑到APP会有不同的版本，MXMetricPayload会携带一个latestApplicationVersion的字符串，此字段会和数据统计时项目配置中的Version版本保持一致。 语义上latest并不是表示APP的最新版本，而是说，在此24小时数据采集的区间内，如果你从1.0版本升级到了1.1版本，也就是当前payload的数据是两个版本的混合数据，latestApplicationVersion应该是显示的1.1而不是1.0 includesMultipleApplicationVersions BOOL 当前24小时数据包是否包含多个版本 timeStampBegin NSDate 数据采集的开始时间 timeStampEnd NSDate 数据采集的结束时间 cpuMetrics MXCPUMetric CPU指标 累计CPU运行耗时 累计CPU指令数 gpuMetrics MXGPUMetric GPU指标 累计GPU运行耗时 cellularConditionMetrics MXCellularConditionMetric 蜂窝网络指标 信号格数直方图 applicationTimeMetrics MXAppRunTimeMetric 运行时间指标 累计前台运行时长 累计后台运行时长 累计后台播放音乐时长 累计后台使用定位时长 locationActivityMetrics MXLocationActivityMetric 定位指标 累计最佳精度定位时长 累计最佳精度导航时长 累计10米精度定位时长 累计100米精度定位时长 累计1000米精度定位时长 累计3000米精度定位时长 networkTransferMetrics MXNetworkTransferMetric 网络指标 累计wifi上传数据量 累计wifi下载数据量 累计流量上传数据量 累计流量下载数据量 applicationLaunchMetrics MXAppLaunchMetric APP启动指标 冷启直方图 热起直方图 applicationResponsivenessMetrics MXAppResponsivenessMetric APP挂起指标 不响应用户交互时间直方图 diskIOMetrics MXDiskIOMetric 磁盘IO指标 累计写入磁盘或其他长期存储的数据量 memoryMetrics MXMemoryMetric 内存指标 最高内存使用量 suspended状态下平均内存使用量 displayMetrics MXDisplayMetric 显示指标 平均像素亮度 animationMetrics MXAnimationMetric UIScrollView掉帧指标 iOS 14 新增 scrollView滑动掉帧时间比例 applicationExitMetrics MXAppExitMetric App退出指标 iOS 14 新增 累计前台正常退出次数 累计前台内存资源受限退出次数 （应该就是OOM,未验证） 累计前台BadAccess退出次数 累计前台不正常退出次数（包含未捕获异常、调用Abort函数、发出abort信号） 累计前台非法指令退出次数 累计前台WatchDog杀死退出次数 累计后台正常退出次数 累计后台内存资源受限退出次数 （应该就是OOM,未验证） 累计后台CPU使用受限退出次数 累计后台为了其他应用腾内存而杀死本应用退出次数 累计后台BadAccess退出次数 累计后台不正常退出次数（包含未捕获异常、调用Abort函数、发出abort信号） 累计后台非法指令退出次数 累计后台WatchDog杀死退出次数 累计后台suspend状态下访问锁定资源文件杀死退出次数 累计后台任务超时杀死退出次数 signpostMetrics NSArray 自选代码段运行指标 自选段名 自选段分类 运行总次数 运行耗时直方图 累计CPU时长 平均内存 累计磁盘写入 metaData MXMetaData 基本信息 区域 操作系统版本 设备类型 App版本 指令集 MXDiagnosticPayload (iOS 14 新增) 属性 类型 含义 补充说明 cpuExceptionDiagnostics NSArray CPU异常诊断 调用栈 异常时CPU使用时长 采样次数 diskWriteExceptionDiagnostics NSArray 磁盘写入异常诊断 调用栈 异常时总磁盘写入量 hangDiagnostics NSArray 挂起诊断 调用栈 挂起时长 crashDiagnostics NSArray 崩溃诊断 调用栈 崩溃原因 虚拟内存区域信息 exceptionType exceptionCode signal timeStampBegin NSDate 诊断开始时间 收集到终端的Metric后可以针对性分析各项指标。 （未完待续）"},{"title":"快速清理Mac的缓存","date":"2020-10-07T06:16:48.000Z","url":"/tech/clean-your-mac/","tags":[["Mac","/tags/Mac/"]],"categories":[[" ",""]],"content":"对于软件的缓存文件，macOS一概归为为“其他文件”，这一点让人很抓头。本来不是很麻烦的事情，CleanYourMac又收费。。 这里简单总结几个可以清理的位置： 下载的软件安装包，DMG、XIP默认装完即删 Xcode相关缓存 App缓存 打包缓存：~/Library/Developer/Xcode/Archives Build缓存，~/Library/Developer/Xcode/DerivedData 模拟器缓存：~/Library/Developer/CoreSimulator/Devices/，Xcode内也可删除 模拟器运行时缓存：/Library/Developer/CoreSimulator/Profiles/Runtimes 真机支持文件：~/Library/Developer/Xcode/iOS\\ DeviceSupport，按需删除 Playground缓存：~/Library/Developer/XCPGDevices/ 软件包缓存 CocoaPods：~/Library/Caches/CocoaPods/Pods，确认后按需删除 Yarn：~/Library/Caches/Yarn其他同理，可以在~/Library/Caches/中查找 正常情况可以轻轻松松清理个几十G出来。"},{"title":"iOS开发：苹果支付测试","date":"2020-06-30T13:13:09.000Z","url":"/ios/storekit-testing/","tags":[["iOS","/tags/iOS/"],["支付","/tags/支付/"],["StoreKit","/tags/StoreKit/"]],"categories":[[" ",""]],"content":"WWDC 2020苹果的Xcode12开始可以支持StoreKit支付的模拟测试，大概是试图减少开发者在测试调试上面的困扰。StoreKit一直遭人遭人诟病，毕竟将责任交由环境复杂的终端，是苹果支付问题的起点。 环境要求对于iOS应用：macOS 10.15+，Xcode 12+对于macOS应用：macOS 11+，Xcode 12+ 配置及流程 创建配置文件（StoreKit configuration file），.storekit后缀 商品配置，最基本的需要ProductId与价格，与AppStore Connect上是一致的目前只支持消耗性商品、非消耗性商品及自动续费商品的配置。 开启测试，编辑scheme，指定是否使用配置文件 凭据校验，需要导出证书（选中.storekit文件可以导出） 管理交易，在Xcode的调试面板上，有Transactions Manager的入口，可以管理过往的交易 具体配置及测试流程并不复杂，可以参阅官方文档，有非常详细的说明。 一切配置妥当开始测试之后，我们可以看到Xcode是启动了一个本地服务来模拟StoreKit的后台服务， 响应数据 测试注意点 target必须选择iOS14.0以上，如果项目的target原本是iOS8-13的，可能会遇到如下提示 &lt;SKPaymentQueue: 0x7faf9c0ccff0&gt;: Error in remote proxy while processing transaction: Error Domain=NSCocoaErrorDomain Code=4097 “connection to service on pid 23668 named com.apple.storekitservice” UserInfo={NSDebugDescription=connection to service on pid 23668 named com.apple.storekitservice} applicationUsername最好置空，不要用json，否则提示4097找不到服务错误 交易凭据是本地测试数据。客户端可以本地校验凭据。但如果要走业务流程，需要后端支持验证这些凭据。 "},{"title":"MessagePack简介","date":"2020-04-19T09:03:00.000Z","url":"/tech/messagepack/","tags":[["JSON","/tags/JSON/"],["序列化","/tags/序列化/"]],"categories":[[" ",""]],"content":"It’s like JSON. but fast and small. MessagePack是什么MessagePack是一个高效的二进制序列化格式，它像JSON一样支持不同语言间的数据交互，但是它的性能更快，序列化之后的码流也更小。 比如小的整型会被编码为一个单字节，短字符串也仅仅需要额外的一个字节来编码。 我们可以看下面的例子说明： 实际上MessagePack确实就“像JSON”一样。 性能如何序列化的性能体现可以分为两方面，一个是编码效率，一个是编码速度。 根据网友的测试数据，编码效率上确实是比JSON要好的，很明显因为MessagePack本身就是在JSON基础上进行字典编码。但经过gzip压缩后，实际差别不大。所以对于能叠加gzip压缩的场景（比如HTTP协议），显然使用MessagePack的必要性也不高。 Format Encoded (bytes) Encoded + Gzipped (bytes) JSON 143025 26214 MessagePack 120799 (-22226) 26074 (-140) 而编码速度上，编解码时间相差70%以上，在循环10k次以上时间感知上体现比较明显，但常见情境下比如100次循环的条件下，差异在50ms级别。 Loops JSON Encoding (s) MessagePack Encoding (s) JSON Decoding (s) MessagePack Decoding (s) 1 0.00064 0.00019 (-0,00045) 0.00164 0.00051 (-0,00113) 10 0.00340 0.00082 (-0,00258) 0.00866 0.00194 (-0,00672) 100 0.03135 0.00732 (-0,02403) 0.07905 0.01700 (-0,06205) 1000 0.30385 0.07250 (-0,23135) 0.77422 0.16785 (-0,60637) 10000 3.02723 0.72503 (-2,95472) 7.74523 1.65804 (-6,08719) 100000 30.29353 7.25324 (-23,04029) 77.48423 16.71792 (-60,76631) 因此综上，在HTTP协议下传输的话，切换到MessagePack的必要性不大。但在自定义协议上还是可以尝试使用的，不经过压缩编码，在流量方面比JSON要优化一些，编码效率也高，尤其你是想使用一个相对不那么可读的序列化编码。 对比ProtoBuf其实根据官网的时间MessagePack应该在2008年就问世了，但到如今应用的范围并不算广泛。而同年Google也正式对外发布ProtoBuf 2.0。在数据二进制编码序列化上，ProtoBuf的使用率更高。在gRPC继续推广的过程中，ProtoBuf可能有更多的应用。 ProtoBuf二进制编码，通过T-(L)-V（TAG-LENGTH-VALUE）方式编码，因为对字段使用编号指代，所以编解码依赖proto文件，编码后数据没有可读性。公开发布时，ProtoBuf规范版本是proto2，目前ProtoBuf规范的版本是proto3。官方文档可见此处。编解码过程的示例也可以参考此文。 ProtoBuf更容易拓展，尽管编解码端需要统一使用proto消息规范文件。同时因为Protobuf IDL统一了语言无关的服务定义，协议部分可以独立，对于多端接口的定义也是一种约束。Google在开发ProtoBuf时首先考虑的也并不只是编解码效率问题。并且消息协议变更时，可以平滑升级，这对于二进制编码的协议而言是非常重要的。 相比而言MessagePack就是比较简单独立的了，既然理解为经过优化的JSON，就没有消息规范文件的约束。 编码规范介绍MessagePack目前已经支持了常见的的编程语言。如果你要开发新的编解码器，是需要了解序列化编码规范的。 编码规范可以参见MessagePack在github的文档。 序列化过程中会根据首字节（及后续字节）来确定编码格式，比如常见的一些首字节： 格式 首字节 (in binary) 首字节 (in hex) 正整数（特定） 0xxxxxxx 0x00 - 0x7f fixmap 1000xxxx 0x80 - 0x8f fixarray 1001xxxx 0x90 - 0x9f fixstr 101xxxxx 0xa0 - 0xbf nil 11000000 0xc0 (never used) 11000001 0xc1 false 11000010 0xc2 true 11000011 0xc3 浮点数编码格式： IEEE 754单/双精度格式。 字符串编码格式： 其中XXXX或YYYY、ZZZZ都是表征字符串数据data大小N的预留位，大端序。 数组的编码格式： 其中的XXXX或YYYY、ZZZZ都是表征数组大小N的预留位。"},{"title":"虚拟内存与Page Fault","date":"2020-04-11T13:13:09.000Z","url":"/tech/pagefault/","tags":[["内存","/tags/内存/"]],"categories":[[" ",""]],"content":"实际上Page Fault并不是如其名的一个“错误”，而只是访问内存分页的一种事件方式。 缺页中断（英语：Page Fault）又名页缺失、页故障等，是当进程试图访问内存数据、但该内存地址对应的物理内存尚未加载时，由CPU的内存管理单元MMU所发出的中断。缺页中断发生后，会发生外部存储的IO操作——这相对CPU及内存的访问是慢了几个数量级的。频繁的缺页中断，可能会造成性能问题，了解PageFault可以帮助我们理解以及进行IO相关的性能优化。 作为虚拟内存访问的一种事件机制，PageFault其实是内存分页以及CPU寻址方式的发展的结果。 内存分页计算机存储是多层次体系结构的，这也是时间与空间的平衡。计算机的存储包括CPU的寄存器、片上缓存、内存以及外存（闪存或硬盘存储）等。 程序或可执行文件，在加载执行前都只是存放在外部存储中的文件。程序加载后，系统为进程分配内存，每个进程都会有自己独立的地址空间，也就是虚拟地址空间。虚拟地址空间的大小是由数据总线宽度决定的，一般也就是CPU的位数，在32位系统中虚拟地址空间就是4GB。操作系统内核常驻于内存中，所以一般（用户进程的）虚拟地址空间中还会统一预留出内核的地址空间。 内存的分配是通过将物理内存划分为页面，然后将这些页面映射到虚拟地址空间中来实现的。这是操作系统与CPU中的MMU内存管理单元协同处理的。通过引入虚拟地址空间，操作系统可以提高内存的使用效率，也可以避免进程间内存不隔离引发的问题。 在访问某个内存地址时，CPU会将虚拟内存地址交由MMU去访问内存数据。Page Table可以理解为MMU使用的映射表，当虚拟地址与RAM的物理地址建立映射关系时，访问虚拟地址时MMU可以转换为RAM的实际地址并访问物理内存。当某个虚拟地址在Page Table还没建立与物理内存地址的映射时，MMU转译地址失败，便会触发Page Fault，Page Fault之后会加载相关的物理内存分页，并在Page Table建立虚拟内存地址与物理内存地址的映射关系。 CPU寻址方式为什么内存分页是计算机结构发展的需要？要理解内存分页，还需要了解CPU寻址机制的发展。 CPU中央处理器是一个超规模的集成电路，主要功能就是解析指令以及处理数据。从功能上CPU中主要分为三大部分，控制单元、运算单元以及存储单元，这三部分通过内部总线连接。控制单元包括指令寄存器、指令译码器及操作控制器等，主要是整个处理过程的调度；运算单元则主要是完成算术及逻辑运算，由控制单元信号控制；存储单元则负责存储数据及运算结果，包括片上缓存及寄存器组。总的来说，CPU会读取指令并译码，执行指令，得到运算结果写回，然后修改指令计数器继续下一条指令。 一条指令由操作码（opcode）和操作数（operand）构成，指令执行包括”取操作数“及”运算“两步。操作码表示指令的动作，例如算术运算、跳转等，操作数则表示指令操作对象。操作数是一个数字，它可以有多种来源，例如寄存器，存储器或者立即数。CPU的寻址方式在指令编码中是指操作数来源或者地址构成方法，根据操作数是否来源于存储器有分为存储器式寻址与非存储器式寻址。 非存储器式寻址一般包括立即数寻址、寄存器寻址，存储器式寻址则包括直接寻址、间接寻址、基址变址寻址等。比如ARM中的load、store指令就是典型的存储器式寻址的指令。 早期计算机或者现在的一些嵌入式设备，程序是直接加载运行在物理内存上的。比如一些MCU芯片，程序经过编译后，每条代码指令和数据都分配了地址，这也是程序运行时可以直接访问的物理内存地址。编译好的二进制一般会烧到ROM中，运行时是直接拷贝到在物理内存中并开始运行的。 0x10000000 100 0x10000004 200 0x10000008 MOV AX [0x10000000] 0x10000012 MOV BX [0x10000004] 0x10000004 ADD AX,BX 上述汇编代码示例中，汇编代码中硬编码的地址0x10000000就是运行期在物理内存中的地址，这就是直接地址寻址的方式。 上世纪BJT与FET晶体管的发明应用，使计算设备得到快速发展。1978年Intel发布了8086微处理器，这也是众所周知的x86架构的起源。8086芯片开始支持16位的字长（寄存器、数据总线等），但地址总线宽度支持到了20位。为了使CPU能访问整个地址空间，8086采用了新的的寻址方式——分段寻址。分段寻址，是指一个地址由段地址与偏移量两部分组成，这样的地址被标记为[segment: offset]，在当时段地址左移4位再与偏移量相加即为物理地址，以达到地址空间的扩充。分段寻址使得程序有了可以独立于物理地址的逻辑地址。 此时程序编译可执行文件会划分为代码段、数据段等，编译器会将地址修正为相对于所属段的偏移地址。程序加载到内存后，会根据需要分配代码段、数据段以及BSS和堆栈段的内存空间。Intel通过新增4个段寄存器（代码段CS、数据段DS、堆栈段SS、其他ES），来存放各个段的段地址。偏移地址编译后是固定的，段基址在不同的运行期是可能改变的。 0x10000000 100 0x10000004 200 // … 0x20000008 MOV AX [BP+0] 0x20000012 MOV BX [BP+4] 0x20000004 ADD AX,BX 在这个汇编代码实例中，[0]中的0就是相对数据段的偏移位置，BP就是基指针（寄存器）。在运行时，CPU寻址时会按数据段基址（比如0x10000000）+偏移位置0计算得到实际的物理地址进行寻址。 运行时对分段寻址的支持，需要一个段描述表，GDT全局段描述符表。GDT可以存放在任何内存位置，GDT的地址通过一个GDTR的寄存器来存放。因为GDT是全局可见的，用户程序可以随意修改段基址寄存器来访问任何内存。因此后来1982年推出80826时改成了段选择子+偏移地址寻址，段寄存器改成了存放选择子（约等于段描述符索引），并添加了权限控制，也就是保护模式。原理是相似的，都是借助寄存器增加了地址转译的中间层。 1985年Intel发布了80386，开始支持32位。操作系统从最初的单任务系统变为多任务并行处理。分段寻址实现了寻址空间的提升，但还有些问题。首先内存分段的地址空间都是连续的，在多任务的情况下很容易产生内存碎片（某些空闲的内存地址段不足以分配内存）；另一方面即使可以仔细地将不同的程序代码/数据放到不同的内存区域，但调度起来非常麻烦。为了便于内存管理与减少碎片，MMU出现并带来了虚拟内存地址。 MMU（Memory Management Unit）是CPU的内存管理单元, 也称作分页内存管理单元（Paged Memory Management Unit），这是一种基于内存分页的、负责处理CPU的内存访问请求的计算机硬件。MMU的功能包括虚拟内存管理、高速缓存控制、内存保护等。MMU在CPU指令单元与地址总线之间增加了一层。虚拟地址也称为线性地址，其实就是计算得到的逻辑地址，对于程序而言只知道虚拟内存地址，而不再需要关心物理内存地址。 Page Fault回过头来，想象一下程序的运行场景。 一个可能有几十MB大小的可执行程序，它在运行的某个时刻是不会在跑所有的逻辑/代码的。有些是初始化时运行的，而有些会在很多条件分支满足后才执行。实际上操作系统确实不会一次性加载所有的代码的，因为内存分页的支持，只会在需要时才加载即可。 当CPU希望访问某个内存地址处的指令代码（或数据），若此时该内存地址（虚拟地址/线性地址）的数据尚未载入RAM时，Page Fault便发生了。内存访问大概的过程是这样的： 1、查找页表位置2、如果Page Fault发生了，通知操作系统来处理，也就是PageFaultHandler3、查找空闲页（帧）4、从磁盘读入数据到RAM5、更新进程的Page Table6、之前触发Page Fault的指令恢复执行 缺页中断交给PageFaultHandler处理时，其根据缺页中断的不同类型会进行不同的处理： Major Page Fault，硬缺页错误 Minor Page Fault，软缺页错误 Invalid Page Fault，无效缺页错误 硬性页缺失是指相关的页在页缺失发生时未被加载进内存的情况。这时操作系统需要：1、寻找到一个空闲的页。或者把另外一个使用中的页写到磁盘上（若有需要），并注销在MMU内的记录2、将数据读入被选定的页3、向MMU注册该页 软性页缺失，物理内存中是存在对应页帧的，但发出访问的进程并未建立映射（可能是其他进程调入的），此时无需从磁盘读取写入内存。一般出现在多进程共享内存区域，比如共享代码库。 无效缺页错误，就真的是错误了，比如地址非法可能会Segmentation Fault异常并向进程发送SIGSEGV的信号，kill掉该进程。 可以参考“Linux下Page Fault的处理”的代码分析。 MMU与Page Table每个进程都有独立的虚拟内存地址空间，都认为自己拥有全部的地址空间（尽管并非如此）。MMU作为一个内存管理单元，是如何进行虚拟内存地址转换的呢？ 事实上每个进程都在内存中保存自己的VA（Virtual Address）转PA（Physical Address）的表，也就是Page Table。因为不同进程地址空间的重叠，这就要求映射表是区分进程的。MMU可以被配置指向该表的起始地址（PTBR页表基址寄存器，在ARM中为TTBR）。如前面所述，对于一个Major Page Fault，分页的物理内存读入后会向MMU注册该表，此后MMU通过查表就可以转译VA对应的PA了。结构如下图示： 虚拟内存的分页一般与物理内存分页保持一致的大小，对于一个分页，前者称之为page，后者称之为frame。一般而言，内存分页的大小是默认4Kb的（在ARM64上iOS为16Kb），我们以32位的内存地址空间为例，4GB的地址空间需要划分为2^20个page，这意味着Page Table会有2^20个条目（Page Table Entry，也简称PTE）。然后计算一下Page Table每个条目的内存大小。 每个条目（PTE）需要包含一个映射的frame的编号，因为2^32的物理内存空间同样按2^12的分页大小进行划分，也就是frame的编号是需要20bit来记录的；另外每个条目还需要记录额外的信息，至少1bit来记录分页是否有效（Present），至少1bit来记录分页是否dirty（涉及到Copy On Write），以及权限位。这一共需要用到4个Byte。于是对于每个进程而言，Page Table需要 2^20 * 4 = 4MB的内存。4MB不算大，但对于多进程的操作系统而言，这对内存消耗是很大的，并且Page Table虽然是进程分离，但是PTE是属于内核资源的。 PTE的保护与状态位 功能 _PAGE_PRESENT Page is resident in memory and not swapped out _PAGE_PROTNONE Page is resident but not accessable _PAGE_RW Set if the page may be written to _PAGE_USER Set if the page is accessible from user space _PAGE_DIRTY Set if the page is written to _PAGE_ACCESSED Set if the page is accessed 事实上正如上面所提的，每个进程是不会使用全部地址空间的（甚至只使用了很少一部分），于是Page Table优化引入了多级页表，也被认为是“paging the page table”。一级页表项也被称为POPTs或者PGD（Page Global Directory），为了方便，可以使POPTs与每个分页一样的内存大小，也就是2^12字节=4KB，这样每个POPT支持 2^12 / 4 = 2^10 个PTE，最多一共需要2^20 / 2^10 = 2^10个POPT。这种情况下再来看一下如何通过多级页表进行寻址。仍是以32bit地址为例，如上所述，一个VA地址需要10bit来确定POPT，10bit来确定POPT中的哪个PTE，最后的12bit则是其在4Kb分页中的偏移。在实际设计上，可以根据需要设定多级页表（比如4级PGD、PUD、PMD、PTE），原理是类似的，具体的寻址可以参考下图： 但在多级分页的方案下，每一次VA的寻址都会发生多次的内存访问（POPT-&gt;PTE-&gt;PA），很大程度降低了性能。为了优化，也基于程序的局部性原理，MMU加入了一个TLB（translation lookaside buffer），也就是缓存。当TLB缓存未命中时，再执行Page Table的寻址。具体流程正如头图所示： 参考：PageFault带来的性能问题Intel 8086Intel 80836"},{"title":"APNS远程推送模拟","date":"2020-04-10T13:13:09.000Z","url":"/ios/ios-apns-mocking/","tags":[["iOS","/tags/iOS/"],["APNS","/tags/APNS/"]],"categories":[[" ",""]],"content":"如果想测试应用的消息推送的逻辑，在此之前我们只有一个选择，就是使用真实设备以及苹果推送服务进行测试。在真正的测试发送通知之前，我们需要将设备id添加到开发者后台，需要更新授权文件，需要配置推送证书，重新编译App安装到设备上以及获取设备的推送令牌。 这是让人难受的过程，尤其是对于一些共享开发帐号的情况——100个开发设备的名额很快就受限了。如果你是个新手，对推送不太了解，可能开发证书跟推送证书还不太明了，或者如果后端也是懵逼的，那难度系数还要+1。没有真机调试，相信这会是你难忘的调试经历。这不是我的经历，但现实确实是很多人会有困扰。 我通常使用Knuff或者一些Python库来测试推送，我现在也还会用，但现在我们有更好的选择了。 从Xcode 11.4开始，可以直接在模拟器中模拟远程推送通知。免去了繁杂的配置过程，也无需漫长的等待。 最好的方法是使用simctl命令行工具，该工具提供了以编程方式使用模拟器的界面。 推送的Payload数据是这样的：（官方文档） 对于App的指定，可以在Payload中指定为APP_PRODUCT_BUNDLE_IDENTIFIER，或者在命令行中指定也是可以的。 推送的命令： 示例： 也可以使用下面的命令，获取到已启动的："},{"title":"JSON Web Token","date":"2020-01-10T13:41:36.000Z","url":"/ios/json-web-token/","tags":[["JWT","/tags/JWT/"]],"categories":[[" ",""]],"content":"OAuth2在移动端实践是不安全的，有不少的产品（包括某些上亿用户量的App），也会出现将client_secret保存在客户端的情况。钥匙丢了、锁却不能换，对于项目而言无疑是很被动的。 因此需要在终端或者整体方案设计上，考虑规避这类问题。 Sign In With Apple在WWDC2019推出后，今年几乎是强制性的接入（发觉大小公司并没有什么抵抗？）。尽管晚了一点，但作为苹果生态的重要一环，终究是出场了。要知道，微信、微博成长为大平台，早期支持授权登录是非常重要的。 与「使用微信登录」、「使用微博登录」一样，Sign In With Apple其实也是基于OAuth2和OpenID Connect的规范来实现授权登录的。那么面对千万级别以上的开发者、全球的用户量，苹果怎么从技术方案上保证数据安全呢？其中的一个方式便是使用JSON Web Token。 JSON Web Token概念JSON Web Token（简称JWT）是一个规范，规范性文件请看RFC-7519。 看看IETF的对JWT的简介： JSON Web Token (JWT) is a compact, URL-safe means of representingclaims to be transferred between two parties. The claims in a JWTare encoded as a JSON object that is used as the payload of a JSONWeb Signature (JWS) structure or as the plaintext of a JSON WebEncryption (JWE) structure, enabling the claims to be digitallysigned or integrity protected with a Message Authentication Code(MAC) and/or encrypted. claim是一种对所有权的宣示。JWT主要是通过对claims做签名，来保证这种所有权的有效性。这从下面介绍的JWT的结构我们可以知道。 JSON Web Token结构看一个例子： 可以看到JWT令牌是一个由.点号分隔为3段的字符串（无分行），并且每段是Base64编码的。 Base64解码后可以看到：第一部分是：（Header） 第二部分是：（Payload） 第三部分是：（Signature） 事实上，一个JWT就是由三部分组成：头部、有效载荷、签名。格式是Header.Payload.Signature，三部分Base64编码后通过点号连接。 其中Header中指定了签名的算法，alg为算法的缩写，通常的比如RS256、HS256。例子中是HS256，也就是HMAC SHA256）。typ为类型的缩写，可选的有[JWS] 与 [JWE]——这两个也是常用的JWT的两种应用。 Header也可以有额外的字段，比如对于非对称加密签名的算法，可能有kid字段（也就是秘钥id）等。 Payload是包含声明的有效载荷。声明是关于实体（比如用户）与其他元数据。 声明可以分为三大类，Registered Claims、Public Claims和Private Claims。其中Registered Claims是标准规定的有特定的含义的声明字段，也是最常用到的，规范里的声明字段有： 一般sub主题是主要的声明。 Public Claims则可以理解为保留字段，比如OpenID的工作组就定义了一组字段，可以参考IANA JWT。对于实际应用上，如果不考虑外部交互，拓展一般用私有声明字段即可。 也可以有自定义的声明字段。 Signature签名部分，根据header中指定的算法进行签名。比如例子中的HS256，是这样的： 签名算法一般是HS256、RS256或ES256。HS256是HMAC SHA256的摘要散列算法，RS256或ES256则是使用非对称密钥进行签名校验。 JWS与JWEJWT是规范，而JWS和JWE就是两个实现了。JWS主要明确签名的细节，关心的是数据防篡改，但数据是可能被窥探的；JWE则关心数据的私密安全性，主要明确数据加解密的细节。 JWS支持的签名算法前面提到的HMAC SHA、RSA SHA、ECDSA SHA系列，每个系列根据密钥长度有不同安全强度。JWT也是可以不签名的（header中alg为none），不签名的JWT被称为不安全的JWT，签名的其实就是JWS了。JWS签名需要用到公钥或者共享密钥来验签，这个密钥被称为JSON Web Key，也就是JWK。 为了支持公钥验签，JWS会有额外的header声明。比如若使用私有部署的证书来签名，则可以声明kid来提供jwk的索引。苹果也是这么干的，苹果提供了服务地址来下载它用来验签的公钥。苹果下发到前端的identityToken就是一个使用苹果的私钥签名的JWT，后面有机会再介绍苹果的授权流程。除了kid，JWS还支持X509证书相关的字段，比如： x5u: 指向X509公共证书的URL x5c: X509证书链 x5t：X509证书的SHA-1指纹 x5t#S256: X509证书的SHA-256指纹 JWE的结构稍微有些差异，JWE令牌由五个关键组件构建，主要包括：JOSE头、JWE加密密钥、JWE初始化向量、JWE密文和JWE身份验证标签。 The protected header，类似于JWS的头部； The encrypted key，用于加密密文和其他加密数据的对称密钥； The initialization vector，初始IV值，有些加密方式需要额外的或者随机的数据； The encrypted data，密文数据； The authentication tag，由算法产生的附加数据，来防止密文被篡改 关注JWE的头部的一些参数字段：alg：定义用于加密 Content Encryption Key（CEK）的算法，必须为RSA-OAEPenc：定义用于加密载荷数据以及提供认证标签，必须为A128CBC-HS256cty：定义载荷的Content Type，必须为“JWT”kid：可选，密钥索引号zip：可选，定义内容明文压缩算法 具体的加解密流程可以参考文档说明。 JSON Web Token的潜在风险JWT的规范不是作为一个数据加密的用途的，比如JWS的头部及有效载荷实际是明文传输的，主要是验证数据的有效性，避免被篡改。因此会有些潜在的问题需要注意的： 敏感信息泄露 JWT的重放风险 算法修改攻击 对称加密签名密钥破解 数据的传输阶段，有效载荷是明文的，所以不要传输敏感信息。而作为身份验证的一种手段，JWT存在伪造身份恶意攻击的风险。比如JWT的重放风险，虽然这个用其他的身份验证方式同样存在的。另一种问题是算法修改攻击，校验方应该限定Header中的sig，谨慎使用JWT库。如果JWT支持none算法，可能直接跳过签名的认证；或者攻击时将RS256修改为HS256，同样有签名验证的漏洞。可以参考这篇文章。 本文参考：Introduction to JSON Web Tokens"},{"title":"Gitlab的招聘条例","date":"2019-11-13T15:39:08.000Z","url":"/tech/gitlab-hiring-ban/","categories":[[" ",""]],"content":"Gitlab的事情有点儿，敏感。再碰上惦记流量的自媒体，效果可想而知。 但是，有接到相关通知的，该不只有Gitlab一家。 如果这些事情发生在某些公关“一流”的互联网公司，可能大众压根就不会知道——默然接受，并且心照不宣。即便是消息走漏，最终“因投诉太多”而被终止访问的，也是个大概率事件。 关于事情为什么公开了，Gitlab是这样说的： GitLab values transparency, and we run our business operations according to this value. We believe this transparency builds trust with our customers and team, encourages contribution and collaboration, and improves our efficiency and velocity. 关于transparency，Gitlab是这样说的： A category of information is public unless there is a reason for it not to be. 消息来源："},{"title":"SQLite的线程模型、事务与并发","date":"2019-08-15T13:49:00.000Z","url":"/null/sqlite-thread/","categories":[[" ",""]],"content":"两个互斥锁： fullmutex：连接锁，用于确保任何时候最多只能一个线程在同一个连接上执行事务 coremutex：文件锁，用于确保任何时候只有一个线程访问数据库 3种线程模型：（使用方式） single-thread：两个互斥锁都禁用，使用方需要保证单线程访问 multi-thread：fullmutex禁用，coremutex开启，可以多个线程通过不同的数据库连接进行访问（单个连接只能单个线程内） serialized：两个互斥锁都开启，多线程安全（影响效率） 配置： Compile time Start-time config：sqlite3_config(SQLITE_CONFIG_SINGLETHREAD||SQLITE_CONFIG_MULTITHREAD|SQLITE_CONFIG_SERIALIZED) Runtime：sqlite3_open_v2() 第三个参数，SQLITE_OPEN_NOMUTEX或SQLITE_OPEN_FULLMUTEX 事务是 SQL 数据库里的通用概念，它描述的是一个或一组数据库操作指令的执行单元；具有四个属性：原子性、一致性、隔离性、持久性，即所谓 ACID，关于它的概念本文不过多赘述。 两种日志模型：rollback与wal 可以参考官方说明：Atomic Commit In SQLite SQLITE_BUSY涉及到5种状态（Understanding SQLITE_BUSY rollback的几种 WAL 的全称是 Write-Ahead Logging wal 日志模式中，提供了另一种日志类型，常称为 wal 文件，记为 .db-wal，在这个模型中，写操作都发生在 wal 文件中；另一个不同点是，.db-wal 文件是持久存储的，它是数据库完整的重要组成部分。 读操作，先读wal文件，如果查询不到，再读db文件，如果wal有多条记录，以最后的为准 通过checkpoint触发写 "},{"title":"SQLite的C编程接口","date":"2019-08-13T08:44:07.000Z","url":"/null/sqlite-c-api/","categories":[[" ",""]],"content":"SQLite的C编程接口，可以简单总结为2个数据类型，8个接口 数据库连接 SQLite语句 开启一个数据库连接 SQLite编译：生成字节码 5个参数（db, statement, 语句的最大字节长度, 语句句柄, 未使用的SQL语句部分） 执行SQL语句： 对于SELECT语句的结果集，需要多次Step 销毁SQLite语句 关闭数据库连接： 另一个执行命令： 对于非SELECT语句可以使用。 在SELECT中的使用 带参数查询：//绑定 参数命名占位：是个方便的绑定值的方式 Named placeholders are prefixed with the colon (:) character or the at-sign (@) character. 二进制数据绑定 sqlite3默认运行在autocommit模式下（当当前连接关联的所有操作都已完成） In autocommit mode, all changes to the database are committed as soon as all operations associated with the current database connection complete. Autocommit mode is disabled by a BEGIN statement and re-enabled by a COMMIT or ROLLBACK."},{"title":"SQLite的基本用法介绍","date":"2019-08-12T12:14:01.000Z","url":"/tech/sqlite-basic/","categories":[[" ",""]],"content":"SQLite作为一个广泛使用的嵌入式数据库 关于SQLiteSQLite是一个嵌入式关系数据库引擎。 项目自2000年开始，iOS/Android内置，是目前非常流行的嵌入式数据库 轻量，官方称包含全部feature的库不到600KB 稳定，跨平台兼容，向后兼容，官方称支持到2050年 直接读写文件，一个完整的包含多个表、索引、触发器和视图的SQL数据库，可以包含在一个单一的文件中。 主流版本V3 SQL（Structured Query Language）是一门数据库计算机语言，设计来用在RDBMS中管理数据的。SQLite实现了SQL-92标准的大部分feature。 一些基本定义： 关系型数据库是一系列组织在表（table）中的数据的集合，表之间存在关系，表包含了行与列。 一张表（table）是一组值的集合，这些值以table的列为模型进行组织，列使用名称进行标识。一个数据库系统的scheme是其结构描述，定义了表、值域、关系、视图、索引、函数、触发器等。 数据表中的每一行（row）数据代表了一个单一的隐式结构化的数据，也称之为一个记录（record）。每一列（column）是一组特定类型数据的集合，其中每一个值是表格中每一行所在列的值。一个值域（field）是指一行一列交叉点的数据。一个主键（primary key）可以唯一标识表中的一个记录。一个外键（foreign key）是两个table之间的引用约束。触发器（trigger）是些响应作用在特定table中特定事件的一些程序代码。视图（view）是对一个或多个表的数据的具体的视角，用来以特定次序、突出或隐藏某些数据。视图由一些存储好的查询组成，就如同操作一个虚拟的由查询结果集组成的表一样。与普通表不同的是，视图没有物理的表结构，是动态的计算型的。 事务（Transaction）是一组对数据库数据操作的原子性的操作单元。事务中的SQL语句要么全部提交到数据库中，要么回滚。SQL的结果集（result set）是从数据库中执行SELECT语句的一系列行数据。索引（index）是一种用来提高数据操作。 基本命令 SQLite数据类型：Type Affinity SQLite语句 SQLite表达式 操作符（Operator） 一元、二元操作符：算术、布尔、关系、位 LIKE CASE WHEN ELSE表达式 CURD 约束 SQLite中有如下约束: NOT NULL UNIQUE PRIMARY KEY FOREIGN KEY CHECK DEFAULT 外键（FOREIGN KEY）指向另一个表中的PRIMARY KEY。外键约束： 注意：In SQLite, foreign keys are not enforced by default. To enforce the foreign key, the library must be compiled with proper flags, it must be at least version 3.6.19, and the pragma key for foreign keys must be set. CHECK约束 Default约束 JOIN语句，将数据库中两个或多个表，进行合并，有两种JOIN：inner / outer。inner join最常见，会从数据库表中SELECT仅查询出那些有匹配值的记录。inner join也有三种，INNER JOIN、NATURAL INNER JOIN、CROSS INNER JOIN。 NATURAL INNER JOIN automatically uses all the matching column names for the join. In our tables, we have a column named CustomerId in both tables. 也就是自动使用两个表名称相匹配的列 CROSS INNER JOIN就是相乘，没什么实用意义 OUTER JOIN不要求每个记录在两张表中能匹配，也有三种：LEFT OUTER JOINS、RIGHT OUTER JOINS、FULL OUTER JOINS，SQLite只支持left The LEFT OUTER JOIN returns all values from the left table, even if there is no match with the right table.也就是说LEFT JOIN会返回左边表的全部值，同时对右边表进行匹配，如果右边表的外键能匹配到左边，则相应有一条记录， 比如下例中，可以查询到所有客户的预定情况 SQLite核心函数 视图A view is a specific look on data in from one or more tables. It can arrange data in some specific order or highlight or hide some data. A view consists of a stored query accessible as a virtual table composed of the result set of a query. Unlike ordinary tables, a view does not form part of the physical schema. It is a dynamic, virtual table computed or collated from data in the database. 触发器Triggers are database operations that are automatically performed when a specified database event occurs. 事务A transaction begins with BEGIN TRANSACTION and ends with COMMIT. In SQLite, any command other than SELECT starts an implicit transaction. 第4个insert会失败，但前面3个会成功 要么全部成功，要么回滚"},{"title":"iOS开发：自定义通知横幅","date":"2019-03-30T03:16:11.000Z","url":"/ios/ios-lib-notification/","tags":[["iOS","/tags/iOS/"]],"categories":[[" ",""]],"content":"所有的终端产品都应该打造好自己的通知系统。 横幅通知，是终端应用实现消息传递的一种有效方式——它套用了「中断」这种经典的消息处理模式，可以穿透不同的上下文来投递消息。苹果是十分重视用户消息通知的。从一开始打造了APNs，到后来多次重构iOS系统的用户通知框架，足见其用心。 但对于App内的消息通知而言，iOS系统本地通知是比较鸡肋的——无法定制横幅的样式。现在要探讨的是，如何写一个自定义通知横幅的组件。 需求分析App内的自定义通知横幅跟App外的系统通知横幅，功能特性是基本一致的： 通知消息接收、UI展示事件回调 用户交互事件回调 消息展示的UI定制 消息展示队列实现 整体可以参考UserNotification框架：我们认为原始消息的有效载荷是核心，消息的展示过程是一个服务的过程。将消息加入队列，是发起申请服务的请求；展示给用户的是任务的描述（通知）；用户对消息的处置是服务对请求任务的响应。 有几个技术细节需要考虑： 数据的交付。从接收到消息，到UI展示，最后到交互事件回调，这里有明确的数据流动。通知组件，怎么建立模型，怎么将数据打包并交付到业务层？ 界面的定制。通知组件，如何支持业务层定制UI或交互特性？苹果是通过插件支持限制范围内的部分UI定制。交还多少控制权更合适？ 服务请求队列。FIFO、优先级、可取消等特性的实现。 数据的交付。假设我们从业务端拿到的是JSON数据，是否需要将JSON转为模型实体数据（约束为特定的字段）？如果UI是支持自由定制的，考虑拓展性，那么是不能将载荷数据转为实体模型的。我们最终也是选择始终提供原始载荷数据（Payload），也就是，在UI定制阶段或者用户交互阶段，业务层是可以直接拿到原始载荷数据的。 界面的定制。因为界面除了UI的展示，还直接有用户的交互事件，交互事件是直接影响消息的流转流程的——手动关闭或者查看消息后，消息的展示队列会流转到下一条消息来展示。事件处理，需要中转，在组件内部完成流转，以及对业务层做事件分发。这部分需要将依赖注入到UI控件内。UI的定制一般通过接口实现或类继承来实现，交互逻辑是完全定制的。 队列，其实可以分为消息队列与展示队列。消息队列接收业务层推入的消息载荷，优先级+FIFO；展示队列则只是FIFO，通常情况下，展示队列还是个串行的队列——同一时间只能展示一个。消息队列与展示队列其实是一个生产消费的问题。 设计方案 Payload 数据载荷，这是流程的起点； HLTNotificationRequest-&gt;Payload，Request是申请服务的请求，持有Payload； HLTNotification-&gt;HLTNotificationRequest，Notification是任务的描述，当任务进入展示队列后，Request转化为Notification； HLTNotificationView-&gt;HLTNotification，NotificationView是通知界面，这里实现为通过类继承来实现UI定制； HLTNotificationResponse-&gt;HLTNotification，服务的响应，从NotifiationView拿到的数据； HLTNotificationManager，流程流转的管理。 实际实现上可能有些出入，队列实现的比较简单，需要后续优化一下。 其他终端应用是直接面向用户的，用户体验为王。"},{"title":"iOS开发：苹果内购组件","date":"2019-03-18T14:16:11.000Z","url":"/ios/ios-lib-storekit/","tags":[["iOS","/tags/iOS/"],["IAP","/tags/IAP/"]],"categories":[[" ",""]],"content":"苹果内购代码组件的重构。 在iOS众多系统框架中，StoreKit算是被诟病得够多的了。StoreKit的设计，要求App来确保交易的最后交付——从苹果的生态来讲，这是可以理解的；但是交易流程中的错误，却很少返回有意义的错误码，“无法连接到iTunes Connect”成了无法明确的错误描述。 本文主要是组件代码重构的一个说明。 前置知识内购的交互/交易流程如下图所示： IAP相关的其他背景知识，不做具体介绍， App内购买项目配置流程，请参考官网； 订单凭据校验，请参考官网； App内购买测试，请参考官网； 苹果的官方示例； 有疑问请参考FAQ； 需要说明的几点是： Transaction必须关闭，无论成功或失败。Transaction关闭后，App必须负责确保完成业务端的交易流程； 需要考虑订单持久化问题； 业务端的订单生成与校验逻辑； 任务方案的设定，我们把每一次发起的交易作为一个任务，加入到任务队列，生命周期完成后移出队列。这样设计，一是可以保证各个任务（的处理逻辑）是独立的、生命周期是完整的，二是任务队列可以协调任务的并发情况。 任务的模型设计如下： 可以看到，Task维护了自身的taskStatus，它本身可以做状态流转的校验。 Task持有的订单模型HLTOrderModel，如下： Order作为贯穿整个交易流程的状态集合， ① 是需要持久化到本地的； ② 可以携带业务定义数据，这个是必然的； 这两点都实现了。 业务逻辑注入IAP内部的交易流程，业务方其实是不太关注的。业务方关注的是，它用这个组件的时候，如何根据业务定制“订单生成/验证”的逻辑，如何获取交易流程的状态回调。 ① 状态回调，其实在Task的定义中可以看到，是提供了事件代理的。 ② 业务定制，Task提供了orderGenerator与orderVerifier作为业务逻辑注入的入口，实现接口就可以了； 外部入口业务层看到的入口： 继续完善。"},{"title":"iOS开发：路由组件","date":"2019-02-21T13:16:11.000Z","url":"/ios/ios-lib-router/","tags":[["iOS","/tags/iOS/"],["架构","/tags/架构/"]],"categories":[[" ",""]],"content":"项目改造的需要，重新捣弄了路由的代码，抽离出来「路由组件」。 设计目标目前大部分的开源路由组件其实已经可以满足基本需求了，比如参数解析、scheme分离等JLRoutes也都支持。但有些别的特性，比如拦截器，比如更动态的配置，还需要重新实现，这也是本文的「路由组件」的主要目标。路由只是路由，关于模块化与路由，以前有简单表达过自己的看法，这里不再赘述。 本文将用接口的方式简要介绍「路由组件」的功能。 拦截器场景挺常见的。 拦截器接口定义如下： 对于一个可路由的URL，在发起路由请求后、实际执行路由前，我们提供拦截的机会： 中断路由 延迟路由 转发路由 拦截器由业务方定义的，只要遵循接口并在运行时注入到路由系统即可。 中断路由，是对于一些极端情况处理；延迟路由比较常见，比如对于用户未登录的情况，需要跳转到登录页面执行完登录流程后，再执行路由；转发路由也比较容易理解。 路由定义想要支持 多路径匹配，也就需要允许匹配一个路由后，可以允许继续进行后续的匹配； 匹配模式，是否严格匹配、或是允许fallback； 数据响应，允许返回Object； 以下是路由的定义： 动态配置指的是，可以在添加路由时，单独针对单个路由动态配置。 接口定义如下： 还差什么？首先，实现上可能还有bug，不过明显的bug肯定是容易发现、修复的。设计上的问题，可能要做一定调整。 再者，没有类似Java的注解功能，一些语法糖还不支持（但折腾宏的话，其实可以实现一部分的）。 另一方面，我们也要思考，需不需要，适不适合，值不值得。路由库尽量只做路由库的功能，业务嵌入的部分是要单独适配的。不是很喜欢侵入性太高的方案。"},{"title":"持续集成：搭建SonarQube","date":"2019-01-26T02:20:18.000Z","url":"/tech/ci-docker-sonarqube/","tags":[["docker","/tags/docker/"],["sonarqube","/tags/sonarqube/"]],"categories":[[" ",""]],"content":"SonarQube是一个开源的代码质量管理系统，可以将工程中代码问题，按预设的规则，输出代码质量报告。 本文记录在Mac上使用Docker Compose搭建SonarQube的过程，方便后来人。 在Mac上搭建SonarQube，以前一般是下载安装包安装的。除了SonarQube，还要手动安装数据库，因为开发机上依赖库不同版本等原因，通常是需要折腾好一阵的。 本文使用Docker，相当方便，无痛安装，值得拥有。 docker-compose.ymlDocker的基本知识请参考前文「Docker：基本知识」。 在指定目录下新建docker-compose.yml文件： 需要说明的是，配置sonarqube的容器，环境变量需要配置上postgres相关的参数。 同时在同级目录下新建.env文件： Docker的宿主机要求因为SonarQube内置了Elasticsearch，es对内存跟文件句柄有一定要求，如果不修改配置，启动容器的时候是可能会失败的。搜索了官网后，查到了相关处理方案： 启动服务在docker-compose.yml目录下，执行docker-compose up即可。如果希望后台执行，加上-d参数。浏览器访问即可（端口号与yml配置一致）。 Done！"},{"title":"持续集成：搭建Gitlab","date":"2019-01-20T16:02:10.000Z","url":"/tech/ci-docker-gitlab/","tags":[["Gitlab","/tags/Gitlab/"]],"categories":[[" ",""]],"content":"本文主要记录Mac上的Gitlab安装过程，使用Docker来安装Gitlab。 安装Docker官网下载安装即可，不赘述。 安装portainer这是一个可视化管理docker的工具， 安装完毕后，访问，需要设定管理员密码，设置完成后，进入系统。进入系统后，选择管理Local的Docker环境。 安装Gitlab 做了端口映射，并且做了数据卷，将Gitlab的目录挂载到本机指定目录下。 "},{"title":"持续集成：搭建Jenkins","date":"2019-01-20T14:34:20.000Z","url":"/ios/ci-docker-jenkins/","tags":[["docker","/tags/docker/"],["jenkins","/tags/jenkins/"],["ci","/tags/ci/"]],"categories":[[" ",""]],"content":"本文主要介绍在Mac上使用Docker的方式搭建Jenkins CI工具的过程。 持续集成（Continuous Integration，简称CI）是满足产品的快速迭代需求的一种技术支持。 产品需求在持续快速变更，怎么在快速实现的同时保证交付的质量，目前在业界已经有了标准的流程：持续集成、持续交付以及持续部署。CI是一种降低风险、减少人力的手段。常见的CI构建工具有： Jenkins Travis CI Gitlab-CI Jenkins是一款广为人知、成熟的工具，功能完整，插件丰富。Jenkins官网对Jenkins有一些基本介绍。 安装Jenkins安装镜像 启动服务 如果想指定Jenkins中的数据挂载到宿主机的目录： 请注意安装完成后，terminal提示： Jenkins已启动，浏览器打开  (默认端口)，输入admin用户跟密码（即上面提示的密码），进入初始配置。按推荐装好插件，创建好新的管理员帐号，就可以进入Jenkins的前端页面了。 添加插件建议先进入「管理Jenkins」/「管理插件」，选择「高级」，修改插件更新源，可使用： 在「可选插件」一栏，可以勾选比如Git相关的、SSH相关的、Sonar相关的，Xcode相关的，按需安装。 添加Credential对于Git仓库或者打包机，需要配置SSH访问的Credential。 对于Git仓库，比如是托管在Gitlab的代码仓库，一般是将生成的SSH的RSA密钥串的公钥配置到Gitlab上，私钥保存在开发机/打包机。把私钥copy配置到Jenkins上的Credential即可。 对于作为执行任务的打包机Slaver（下一节讲到），Jenkins需要通过SSH的方式访问打包机，因此打包机需要配置启动sshd服务。需要将访问slaver的公钥配置到authorized_keys，sshd的配置不赘述。 添加节点因为Docker安装的Jenkins是处于隔离的容器环境的，如果需要使用Xcode或者Node的环境来打包，是需要添加其他机器作为Jenkins的节点来执行任务的，Jenkins运行机器作为Master，其他节点作为Slaver。 确定好要执行任务的机器，配置并添加节点。 Slaver环境配置根据执行任务的需要来配置Slaver节点的环境。比如Mac节点执行iOS项目的打包任务，需要安装好基础的软件，比如：Xcode、CocoaPods、JDK等。 打开终端查找JDK路径：/usr/libexec/java_home -V，若未安装JDK，可以使用homebrew安装： 安装JDK后建议将JAVA_HOME的路径配置到Slaver的.bash_profile文件中。 若CocoaPods在系统更新后失效，可以尝试重装： Jenkins添加节点进入「管理Jenkins」/「节点管理」，新建节点： 启动方式可以选择SSH登录的方式，使用配置好的Credential即可（上一小节已说明）。 勾选工具位置，填好相关工具（主要是Git）在slaver的位置。勾选环境变量，配置好JDK的位置（JAVA_HOME）。 最好配置一下标签，后续配置任务的时候可以指定特定标签的机器来执行。 添加完节点后，可以回到节点列表，如果没有提示错误表明配置成功，可以使用该节点来执行任务了；如果有报错，则查看并根据具体的错误来修正。 打包任务对于iOS打包任务，主要包括： 配置Git仓库 参数化配置 打包脚本 Sonar Scanner 网上也有比较多介绍，不赘述。签名相关的问题，请参考「证书管理」。 证书管理请参考：Jenkins的Keychains and Provisionning Profiles Management插件。 如果确实有问题，需要访问打包机的keychain，可以： 可以在Keychain Access中，新建一个新的Keychain组方便任务使用。 其他安装过程中有遇到问题，可以到Jenkins官网查看有无解决方案。"},{"title":"Docker：基本知识","date":"2019-01-18T14:34:20.000Z","url":"/tech/docker-basic/","tags":[["docker","/tags/docker/"]],"categories":[[" ",""]],"content":"我们都在说未来要“云”化，那么我们应该要将服务打包放到“云”上。那么我们的应用需要容器化，那么我们要安装Docker。 Docker是一个开源的PaaS产品，2013年开源发布Docker引擎后，迅速崛起。 本文介绍Docker的基本概念跟入门使用。 Docker容器是什么？Docker跟虚拟机有些像，但Docker不是虚拟机。虚拟机是对硬件进行虚拟化，Docker则使用了操作系统级别的虚拟化技术。Docker容器运行在宿主机中，但容器之间是隔离的，并且将各自的依赖库、配置打包进了容器。 镜像（Image）操作系统分为内核与用户空间。对于Linux而言，内核启动后会挂载文件系统。Docker镜像是一个特殊的文件系统，除了提供容器运行时需要的程序、库、资源和配置外，还包含了一些配置参数，以支持运行时的一些功能。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 容器（Container）镜像（Image）和容器（Container）的关系，就像是类与实例一样：镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、暂停、停止、删除等。 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 文件系统、网络配置、进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。 前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 容器存储层。 仓库（Repository）镜像的分发到其他服务器上使用，需要一个分发中心服务。Docker Registry是这样的服务，而仓库则是镜像的仓储。一个Registry中可以包含多个仓库（Repository），每个仓库可以包含多个标签（Tag），每个标签对应一个镜像。 通常，一个仓库会包含同一软件的不同版本的镜像，我们可以通过 &lt;用户名&gt;/&lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体使用什么版本。latest是默认标签。比如nginx:latest。 Docker的基本命令Docker运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker会从镜像仓库下载该镜像。 获取镜像从公开的仓库（或私有仓库）可以获取镜像，如Docker Hub上： 列举镜像docker image ls 镜像包失去镜像名后（比如docker pull更新），旧的镜像没有名称了，称之为虚悬镜像（dangling）。通过命令docker image ls -f dangling=true可以查找到。一般来说，虚悬镜像是可以随意删除的，可以用下面的命令删除：docker image prune。 需要留意，可能有些依赖的镜像被下载下来，这些不是dangling。 删除镜像 运行容器基于镜像新建一个容器并启动。下例中启动ubuntu中的bash并进行交互式操作。以Jenkins的操作指令示例： docker run的参数：-it：-i是交互式操作，-t终端。在交互式终端运行容器。-d：守护式启动容器-p port1:port2 表示宿主机和容器的端口映射–name 表示给生成的容器起名字-v /volume/in/host:/var/volume/in/container 数据卷挂载 对于已创建的处于stop状态的容器，可以使用docker start $containerId再次启动容器。 查看容器 查看容器的日志： docker -f $containerId 进入容器如果要修改容器，可以用docker exec命令进入容器， 用-it指定交互式终端进入，最后的bash是指定进入容器后执行的命令。 进入容器后可能会修改到配置，定制后需要将容器存储保存下来，就是在原有镜像的基础上，成为镜像。 示例： 停止容器 使用docker stop来终止一个运行中的容器。 导出容器 可以将容器做一个快照，导出成为镜像。 以上是关于docker的container的一些入门介绍，进阶内容可以参考官网的介绍。 Docker Compose Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration. 绝大多数情况下，我们的应用都是有外部依赖的，比如数据库，MQ或者外部服务。当我们把服务都容器化的时候，管理和协调这些容器跟应用本身，就变成一件糟心的事儿了。Docker的解决方案是Docker Compose。 Docker Compose允许我们通过一个配置文件定义整个应用，包括它的依赖。这样会使开发变得相对incredibly容易。使用Compose可以： 一行命令启动整个应用：docker-compose up -d 简单的DNS解析：可以在service-a中直接使用调用service-b 一行配置挂载数据卷 下面是一个docker-compose.yml文件的示例： 第一行version定义了版本；services下配置了web跟redis两个服务（的容器）。ports定义了&lt;HOST_PORT&gt;:&lt;CONTAINER_PORT&gt;的端口映射；volumes定义了宿主机与容器文件系统的映射，例子中是将宿主机的当前目录挂载为容器内的/code路径；environment定义了环境变量。 实际上还可以配置网络，这一点没有谈到：容器间是隔离的，网络不是直接相通的。这是官网的一个示例图： 有兴趣可以从官网文档了解。 反向代理为了让非宿主的机器能访问容器的服务，需要做反向代理。创建一个包含web应用的容器，一般会做宿主机到容器的端口映射，如： 使用了宿主机8080端口映射到容器的80端口。如果使用NGINX做反向代理，需要配置转发，参考配置如下： 如果是uWSGI应用 还有什么想说的？ There is no problem in computer science that can’t be solved by adding another level of indirection. 嗯！"},{"title":"Flutter上手指南（环境搭建）","date":"2019-01-15T05:53:20.000Z","url":"/ios/flutter-dev-start/","tags":[["Flutter","/tags/Flutter/"]],"categories":[[" ",""]],"content":"“Write once, run anywhere”，在移动互联网时代是一个难以抗拒的诱惑。 自2018年2月27日发布Beta版以来，Flutter在国内移动端的「讨论」越来越活跃。再加之咸鱼团队的押注加持，越来越多的团队开始打起了Flutter的主意。 是的，”Write once, run anywhere”，在移动互联网时代是一个难以抗拒的诱饵。接入端的分化，对服务商是一个成本问题，产品亦在朝着淡化接入端的差异性的方向发展。H5、React Native、Weex、Lua、Xamarin都不失为一种值得考虑的方案。而小程序这两年的强势突进，各个互联网Giant不得不警惕和防守。而对开发人员来说，又是另一抉问题的抉择了。 Flutter不是第一个跨平台开发的框架，当然也不会是最后一个。与上述提到的方案不同的是，Flutter不是对原生平台底层框架的桥接，而是另起炉灶基于Skia引擎进行渲染。但毕竟UI只是业务开发的一部分，具体还看性能及框架提供的能力。 本文先介绍上手指南之环境搭建（Mac平台），再来简单看看Flutter的基础原理知识。 # 环境要求 Mac OS 64位 磁盘空间700MB（不包括IDE 命令行工具：bash、curl、git、mkdir、rm、unzip、which Xcode 9.0+(请确保xcode-select指向正确的版本) # 下载SDK下载地址可在官网获取，本次使用地址：v1.7.8（约600M） 下载完成后解压缩SDK到工作目录。可考虑预加载依赖项、执行命令flutter precache 。 # 环境配置终端执行flutter doctor检查环境，检查是否需要安装其他依赖项来完成。 可能遇到报错： GIH-D-11754% flutter doctor Doctor summary (to see all details, run flutter doctor -v): [✓] Flutter (Channel stable, v1.7.8+hotfix.3, on Mac OS X 10.13.6 17G65, locale ​ zh-Hans-CN) [✗] Android toolchain - develop for Android devices ​ ✗ Unable to locate Android SDK. ​ … ​ If the Android SDK has been installed to a custom location, set ​ ANDROID_HOME to that location. ​ You may also want to add it to your PATH environment variable. ⣟ideviceinfo returned an error: ERROR: Could not connect to lockdownd, error code -17 修改bash配置，将flutter的可执行文件路径配置到PATH中： export PATH=/Users/cc/Kernel/0xFlutter/flutter/bin:$PATH export PUB_HOSTED_URL= export FLUTTER_STORAGE_BASE_URL= 后面两个是避免网络环境问题，可使用国内站点。 若已安装Android Studio，配置： export ANDROID_HOME=/Users/cc/DevEnv/Android/sdk #Android 模拟器路径 export PATH=${PATH}:${ANDROID_HOME}/emulator #Android tools 路径 export PATH=${PATH}:${ANDROID_HOME}/tools #Android 平台工具路径 export PATH=${PATH}:${ANDROID_HOME}/platform-tools #Android NDK路径 export ANDROID_NDK_HOME=/Users/cc/DevEnv/Android/ndk/android-ndk-r10e 若暂时不使用Android开发，可暂不安装Android Studio（而且这货也挺大的） 。 # 创建Demo终端运行：flutter create 可能会遇到失败的情况： … All done! ideviceinfo returned an error: ERROR: Could not connect to lockdownd, error code -17 继续。 安装将flutter安装到设备的工具：（官方） brew install –HEAD libimobiledevice brew install ideviceinstaller ios-deploy cocoapods #注：若已安装旧版本可能有不兼容情况，删除重装 安装libimobiledevice失败，需要安装usbmuxd：（若原已安装，可以先brew unlink usbmuxd ） brew install –HEAD usbmuxd 重新安装工具： brew install –HEAD usbmuxd brew link usbmuxd brew install –HEAD libimobiledevice brew install ideviceinstaller ios-deploy cocoapods 此时，flutter run 是成功的了，可以跑demo。 （在启动模拟器后可以运行，若存在多台设备，需要-d指定；若需真机调试，需要确保设备id已加入调试设备列表） # IDE及配置一般建议使用VS Code，上面也有很多相关插件，比如Dart、Flutter这些是必装的。看自己喜好。 # Flutter基本知识基本环境配置完，可以来了解一下Flutter基本知识了。以下是Flutter官方给出的系统架构图： 可以看出Flutter框架分为三层：Framework层、Engine层和Embedder层。 Embedder层是平台相关的实现，主要包括事件循环、打包、线程设置、原生插件、渲染相关； Engine层则是Flutter的核心，使用C++开发的，主要包括Skia渲染引擎、Dart 虚拟机、文本布局渲染等； Framework层是Dart语言实现的应用层。最顶层是Material与Cupertino两种Widge，往下则是渲染、绘画、动画、手势等基础功能的封装了。 那Flutter是怎么渲染的呢？可以看看官方提供的流程图： 小结关于后续。个人感觉按目前单凭宣称的内置Skia渲染引擎不足以撬动整块大石头。何况Dart是单线程执行模型，很多以前遇见的问题，换成Flutter依然需要解决。热加载不一定一直试一直爽。而且Flutter需要学习新的语言及框架，相对RN等等的门槛还是提高了一点。 建议就是，不妨跟进与关注吧。"},{"title":"Mac常用软件推荐","date":"2018-11-29T06:38:09.000Z","url":"/undefined/mac-software-list/","tags":[["Mac","/tags/Mac/"]],"categories":[[" ",""]],"content":"介绍一些Mac平台常用的工具。 效率工具 Evernote Microsoft Todo Vitamin-R Trello 阅读工具 Reeder/NewsBlur：RSS Pocket：Read it later iBook 写作工具 Typora：最好用的mark down编辑器，没有之一 Alternote：连接EverNote的笔记应用 iThoughtsX / Xmind ：思维导图 OmniGraffle 开发工具 SourceTree/Cornerstone：版本管理工具 RubyMine/PyCharm/AppCode/VS Code/Xcode/CodeFlow/Sublime Text Docker Base：数据库 Knuff：推送测试 Understand：静态分析 Reveal ProtobufViewer：ProtoBuf查阅 MachOView Hopper Disassembler/iDA Pro：反汇编 Cyberduck：加密FTP Charles/Wireshark：代理&amp;抓包 Postman：模拟请求 通讯工具 Shadowsocks Telegram Gitter 设计工具 Sketch PxCook 设计师软件 Eagle 蓝湖 日常工具 Paste：剪贴板 Sip：颜色提取 Kap：简单录屏 Xnip：截图 Skim：PDF阅读 The Unarchiver：压缩工具 Elmedia Player：播放器 Alfred 3：快捷工具 GPG resilio sync "},{"title":"如何写一个可用的SDK？","date":"2018-10-11T12:13:31.000Z","url":"/tech/how-to-write-a-sdk/","tags":[["技术","/tags/技术/"]],"categories":[[" ",""]],"content":"有些第三方平台的SDK有点儿难用，大概很多人都有过这样的感慨。 如果是你来写，怎么写出一个别人觉得可以用的SDK？ 从使用者的角度，SDK要遵循组件封装的一些基本要求： 稳定性 易用性 灵活性 稳定性稳定性是基础要求。你能接受一个动不动会触发Crash的组件库吗？不可能的。稳定性压倒一切——这句话怎么这么熟悉。组件再重要，可不能影响主要业务的运行。 如何保证稳定性？ 从源头上说，肯定是先得保证代码质量。如果能维护一份“SDK开发设计文档”，那更好不过了——当然你得知道，90%的维护者是不会看你这个的，除非出了问题。请坚持保持清晰的代码结构、入参检查、错误/异常处理，这些都是提高代码质量的通用之道。然后，是的，每一个项目都会经过众多维护者的“洗礼”，SDK也不例外。在SDK迭代过程中，要保证后续开发者能准确理解SDK的设计思路。保持一致的代码风格尤其重要——即使你认为你创造的模式更好，也不要混杂多种代码风格/模式。除非推倒重来。记录SDK开发/发布日志。“设计文档”不常有，但发布日志可以有。记录项目的更新内容，对问题排查检查是一个有效工具。 从输出来说，需要保证产品的质量——SDK是平台方向它的用户提供的产品。发布前经过QA的测试与质量检查是必不可少的。另外，对功能模块进行单元测试，也能保证迭代过程中，不会意外导致功能异常。 一些具体的check list： 兼容测试：不同系统版本、机型设备的兼容问题。新出的系统API，请务必检查API的可用性。 覆盖测试：缓存问题是日常出bug的主力。请检查覆盖安装的情况下，是否存在异常。 帐号切换测试：缓存问题。 易用性简单而言，就是直观、易上手。这个就涉及开发者的设计能力了。有一些常见的指标，让我们回答几个问题：1、接口优雅吗？接口优雅，则产品的使用体验是极大提升的。首先一点，接口尽量要所见即所得，参数类型必须是明确的。其次，可以考虑使用者的接口调用场景，提供替代方案。 2、细节隐藏了吗？配置项请尽量简化。合理使用默认参数。使用者无关的参数不需要暴露。可以考虑将常用的配置项打包成一个选项，Builder模式。 3、内部重试机制？内部维护的参数请内部保证可用性。内部流程失败，应该设定重试机制。这里有一个很新鲜的例子：我司有维护了一个SDK，封装了微信授权、拉取用户信息并映射到公司用户系统的功能。该SDK会在SDK初始化时，向服务器登记并获取一个设备ID，并且该ID在后续的所有接口调用中都会使用到。结果在某些产品更新微信登录流程时，出现了SDK初始化设备ID失败的情况，而SDK内部没有重试机制，效果可想而知。大多数情况SDK初始化只会进行一次、调用方不会重复初始化SDK，几乎是常识性的错误。 4、API稳定吗API接口声明请保持稳定。动不动只能改API来适配新需求，是一种可耻的行为。 5、接入方便吗？准备了demo了吗？README能按条理写明白主要功能了吗？现在CocoaPods创建个组件库都十分方便了，能简化项目的接入成本又何乐不为呢。 灵活性SDK面对的开发场景复杂，应当提供一定的灵活性，满足开发需要。 调试日志。调试日志对开发者很重要，SDK应该支持输出一定的日志，至少保证错误日志。如果能提供日志格式化器、控制日志输出级别则更好。 减少依赖项。尽量避免依赖外部项目。一些稳定并且持续跟进维护的可以考虑引入，建议谨慎，如果只为了一点工具就引入整个第三方库，不值得。引入第三方库需要进行符号重命名，mangling。 降低模块耦合度。"},{"title":"iOS开发：Xcode10兼容libstdc++","date":"2018-09-19T12:38:19.000Z","url":"/ios/xcode10-adaption-libstdcpp/","tags":[["iOS","/tags/iOS/"]],"categories":[[" ",""]],"content":"Xcode10正式版已发布，苹果在Xcode10中已移除了对libstdc++的支持。本文主要介绍临时处理方案。 编译失败，会提示： library not found for -libstdc++.6.0.9 解决编译的问题，主要是解决符号搜索路径的问题。 10.0版本之前Xcode支持libstdc++，可以将旧版本的libstdc++的tbd拷贝到新Xcode的SDK目录下即可通过编译。其中，ARM架构SDK目录是/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib/，x86架构SDK目录是/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/。将两个SDK目录下的libstdc++相关tbd文件拷贝到新Xcode目录下即可编译成功。 此时运行iOS12模拟器，会提示： 这是因为iOS12的模拟器运行时找不到libstdc++动态库，其路径为链接时所指定的/usr/lib/libstdc++.6.dylib。解决方法是，将x86架构的dylib拷贝到新Xcode的iOS12模拟器运行时相应目录下即可。具体目录是：/Users/Jetsam/Downloads/Software/Xcode/10.0/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/usr/lib（请替换Xcode10安装路径）。 上述处理之后，重新运行即可。建议先clean一下工程并删除模拟器上旧包。否则可能会出现类似这样的报错（报错为开启了address sanitize）： 当然了，最好是及时从libstdc++迁移到libc++了，具体步骤不赘述。附苹果的Xcode发布日志： Building with libstdc++ was deprecated with Xcode 8 and is not supported in Xcode 10 when targeting iOS. C++ projects must now migrate to libc++ and are recommended to set a deployment target of iOS 7 or later. Besides changing the C++ Standard Library build setting, developers should audit hard-coded linker flags and target dependencies to remove references to libstdc++ (including -lstdc++, -lstdc++.6.0.9, libstdc++.6.0.9.tbd, and libstdc++.6.0.9.dylib). Project dependencies such as static archives that were built against libstdc++ will also need to be rebuilt against libc++. (40885260) 对于本文的trick，苹果的工程师这样说： libstdc++ was deprecated 5 years ago. Apple’s more recent platforms (tvOS and watchOS) don’t support it.Support was removed from the iOS 12.0 Simulator runtime, but it remains in the iOS 12.0 (device) runtime for binary compatibility with shipping apps.You should update your project to use libc++ rather than libstdc++ by setting the CLANG_CXX_LIBRARY build setting (“C++ Standard Library”) to libc++.If you have any static libraries that depend on libstdc++.tbd, you can workaround it for now by copying the file from the SDKs in Xcode 9.4 (and libstdc++.*.dylib in the iOS simulator runtime), but that is not a long term solution. You should contact the provider of those libraries and request versions built using libc++. 最后附上脚本： 对于一些旧项目，或所依赖的第三方库有链接libstdc++动态库的项目，必须替换为libc++才可正常编译运行。还是建议及时跟进更新。"},{"title":"技术碎片：一条命令\"拯救\"移动硬盘","date":"2018-08-13T13:13:59.000Z","url":"/tech/fsck-disk-rescue/","tags":[["技术","/tags/技术/"]],"categories":[[" ",""]],"content":"今天一时疏忽同学突然找我说，移动硬盘挂了，工作资料的盘一直打不开！ 找我是因为前不久将某同学之前的移动硬盘重新分了区，常用Mac，偶尔需要用在Win上。所以备份分区用APFS，工作分区用Mac日志式，另两个分区用exFAT。回来赶紧打开磁盘工具，工作分区确实挂载不上！ 试了NTFS for Mac，确实无法挂载我说不急不急，我们还有命令呢，我来试试肯定没事的。。 diskutil list可以看到设备列表： /dev/disk2 (external, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *1.0 TB disk2 1: EFI EFI 209.7 MB disk2s1 2: Apple_APFS Container disk3 400.3 GB disk2s2 3: Microsoft Basic Data 学习资料 249.5 GB disk2s3 4: Microsoft Basic Data 个人资料 100.0 GB disk2s4 5: Apple_HFS 工作资料 249.8 GB disk2s5 试一下： sudo diskutil mount /dev/disk2s5这个如果硬盘挂载失败，通常使用这个命令可以的。 这次提示失败！有点瑟瑟发抖。。那就是硬盘分区确实出问题了。 最快的方式，Google一下，果然遇到的都是别人遇过的问题😃 sudo fsck_hfs -fy /dev/disk2s5 会提示检查到的错误并尝试去修复！然后检查完毕就可以正常挂载了！ 后来问了一下，是用CC 2018直接打开了移动硬盘上的psd进行编辑，估计是频繁保存导致出错了。"},{"title":"iOS开发：输入字数限制","date":"2018-06-17T13:29:38.000Z","url":"/ios/ios-textfield-restriction/","tags":[["iOS","/tags/iOS/"],["TextInput","/tags/TextInput/"],["文本","/tags/文本/"]],"categories":[["iOS","/categories/iOS/"]],"content":"字数限制是所有iOS开发都会遇到的一个问题。业务场景非常常见的，譬如，在微信中，用户昵称限制纯英文32个纯中文16个而emoji是8个，而微博发布动态则是有140字数的限制。但就实现出来的效果看，体验还是不够好的。这篇文章来聊聊文本输入字数限制的正确姿势。 # 限制输入先上图，这是微信修改昵称的页面： 当你在中文输入法状态下，连续输按下12个h之后，原先文本框内的高亮不见了，并且仍可继续键入1个h，文本框内留下的是”h h h h h h h h h h hh”，一共12个h。不是说好的英文32个吗？是不是很刺激？ 不如先埋个坑，说回文本限制输入的基本思路： 在文本输入框已达到限制长度之后，就不应再接受键盘的输入了。实现的方法也很简单。单行文本输入的控件UITextField提供了键盘输入事件代理，代理（遵循UITextFieldDelegate）只要实现了方法- textField:shouldChangeCharactersInRange:replacementString:， 在此方法中返回NO，键盘的输入将不再影响文本控件。然后做个文本截断，当真是顺其自然。微信的小伙伴，看表现必然也是在这里趟的坑了。 对于多行文本控件UITextView同样如此。事实上，是因为两者作为文本输入控件都是遵循UITextInput协议的，通过实现该协议方法可以获得键盘的输入。自定义的文本输入控件，自然也是类似，不赘述。下文将继续以UITextField作为典型。 先上代码再解释： 代码中3个注释，都是关键。 注1，文本的字数计算。我们的产品同学经常有些特殊的爱好，比如中文按2个英文字数算，emoji按4个。参考文章开头提到的微信规则。字数的统计我们将在第三部分来介绍，这里暂时跳过。你大可以相信-composedCharLength:这个方法是正确的。 注2，键盘输入模式，事实上主要用来查询键盘使用的语言。这里的处理是，如果当前是中文输入法，并且有高亮选中（即备选词尚未键入文本框），那么是允许用户继续输入的。即使还只能输入一个字，也是允许用户连续按下”hhhhhhh”的。体验是很直观的。假如昵称只允许3个中文字，按微信的做法，很可能你连张三（zhang san）都没办法输入。(当然如果只是纯英文的需求，请忽略！) 注3，超长限制输入。这个是这个方法的核心也是最简单的。请注意，请勿在注3逻辑中进行超长截断，这将犯微信错误！只需处理超长不允许输入即可！ # 超长截断源码胜过语言： # 字数统计1中文=2个字，1英文=1个字，1emoji=4个字 "},{"title":"技术碎片：Git代码仓库迁移","date":"2018-02-01T14:53:22.000Z","url":"/tech/git-repo-migrate/","tags":[["Git","/tags/Git/"]],"categories":[[" ",""]],"content":"接锅不可怕，最怕没有Log。一份代码，有完整提交记录对项目维护是十分重要的。 如何将Git代码从原来的仓库迁移到新的托管站点，并且保留历史提交记录？ 有两种方案： 方案一修改远程仓库路径，并推送代码到新的托管点。 1、修改远程仓库的路径： 上面，$remote_git_address是新的托管服务器上新建的同名项目地址。nie就是远程仓库的别名了，跟origin一样意思。 2、推送： 会推送主干和所有分支。但是注意，这个命令不会推送标签。需要： 方案二将远程仓库检出镜像到本地，再推送到新的托管点。 如果在迁移过程中，旧的代码仓库又有了新的提交（我们需要假设总会有”异常“），需要更新并推送："},{"title":"iOS开发：UITableView自适应高度","date":"2017-08-20T13:20:54.000Z","url":"/ios/ios-tableview-autoheight/","tags":[["iOS","/tags/iOS/"],["UITableView","/tags/UITableView/"],["AutoLayout","/tags/AutoLayout/"]],"categories":[["iOS","/categories/iOS/"]],"content":"人都是想偷懒的，技术因为”偷懒”而进步。造出来的轮子，让键盘上的双手得以腾出空来，可以干点别的事情。比如画画比如写书，所以我们有黑客与画家。 从iOS8开始，iOS提供了对UITableViewCell自适应高度的支持。而在此之前，假如你需要编写一个异构的列表，你可能会觉得很不想动手：你需要计算每一种结构的Cell的高度，-tableView:heightForRowAtIndexPath:会是你最不想看到的方法之一。 所幸的是，你现在只需要设置，_tableView.rowHeight = UITableViewAutomaticDimension，大体来说，这样就可以了。Cell内部使用AutoLayout，对于这样异构的列表，并不大影响它的用户端性能表现。 # iOS8的魔法iOS8之前，UITableView并无自适应高度一说。所谓的自动适配高度，即是手动计算并触发重新布局，具体细节就不赘述了。 那么转念一想，iOS8难道就不一样了吗？如果你理解Auto Layout，自然是知道，Auto Layout是布局系统在计算布局前的一个约束系统。在更新界面布局前，通过约束计算可以得出实际的布局数据，然后按传统流程，触发界面重新布局及渲染了。核心确实是一样的。 理解这个很重要，出现问题时可以按图索骥来解决。 iOS8在UITableView这个UI组件层面加上自适应高度的支持，可谓聊胜于无，但对一些特定业务开发来讲亦是省心省力。 关键代码示范： 没有开玩笑，这几乎是UITableView自适应高度需要的所有代码了。 但有几个问题是需要注意的： Cell内部的Auto Layout约束，在y方向必须确保与contentView的top/bottom的连接能确定contentView的尺寸； rowHeight = UITableViewAutomaticDimension或者实现相应的代理方法； estimatedRowHeight需要设置； # 常见的问题 iOS 10（及以下）并没有自适应？ 请检查_tableView.estimatedRowHeight = xxx;是否设置了。在iOS11+，即使不设置该方法也是没问题的，但旧版本就没那么幸运了。如果没意识到这个，在设备兼容上你可能得多花一点时间来排查问题了。 iOS11+也没自适应？ 请检查Cell内部的Auto Layout约束是否确保了Cell的contentView尺寸被subviews约束了。重点留意y方向top/bottom属性的约束。 部分Cell高度没自动更新高度 请留意该Cell内部有没有子控件是UIScrollView的子类，这个问题请看下一节。 # UIScrollView 与 intrinsicContentSizeiOS6新增了一个UIView的属性方法，- (CGSize)intrinsicContentSize。学习Auto Layout最终必然要认识这一属性的。平时写布局时经常没设置UILabel、UIImage的大小，但出来效果毫不影响，正因为此属性的功劳。 什么是intrinsicContentSize呢？字面理解，称作固有大小。简单来说，如果布局系统没有给UIView指定大小，那么就按intrinsicContentSize作为其大小——言下之意，如果指定了视图大小，那断然是按指示办的。UILabel、UIImage、UIButton等UI组件是有固有大小的，根据字体、文本、图片来确定其大小。但不是所有View都有intrinsicContentSize的，UIView默认实现是返回UIViewNoIntrinsicMetric。UIScrollView因为其可滚动特性的特殊性，其intrinsicContentSize同样被设定为UIViewNoIntrinsicMetric。 这就是为什么当你遇到UITextView、UICollectionView等等作为Cell子视图时，魔法不奏效的原因了。 解决方法就是，指定UIScrollView布局的”固有内容大小”了。譬如，将UIScrollView嵌入到一个container中，指定container的intrinsicContentSize，不失为一种方法。 问题总是会遇到的，具体就请自行实践了。事不亲历，难说感同身受。 顺便提一下，与intrinsicContentSize相关还有一关键问题：假如两个组件都没显式约束了大小，但是就intrinsicContentSize布局的话，可能会发生冲突！此时，Content Hugging与Content Compression这两个配置可以帮助解决冲突的。用俗话讲，Content Hugging是不想变大约束，Content Compression是不想变小约束，优先级越高越符合其初衷。 # 其他问题 设备尺寸兼容问题 可能要回退到手动设定高度。举个业务场景，比如可滚动（变长）的列表，希望尽可能内容铺满页面。在小尺寸设备内容会超过页面大小，而大尺寸设备内容无法铺满一屏、但希望铺满一屏。 仅提供参考： UICollectionView自适应 UICollectionView同样类似，需要使用layout.estimatedItemSize而不是layout.itemSize，具体要自行尝试。 性能问题 使用Auto Layout后性能是会比手动布局稍低一些，具体视布局复杂度而定。 性能敏感的请另行考虑方案。 # 小结UITableView的高度自适应为我们某些业务场景的界面编写带来了些便利，可以显式地减少很多繁琐的计算，在复杂的多尺寸设备环境下可以说是很贴心了。并且对于不可重用界面减少自定义Cell，对整体项目而言也是有利的。 具体情况具体分析，也就各取所需了。"},{"title":"iOS开发：多线程之GCD基础知识","date":"2017-07-04T05:12:41.000Z","url":"/ios/mutilthread-gcd-basic/","tags":[["iOS","/tags/iOS/"],["GCD","/tags/GCD/"],["多线程","/tags/多线程/"]],"categories":[["iOS","/categories/iOS/"]],"content":"写在前面llibdispatch是苹果开发的一套C接口的库（苹果官方称之为GCD，Grand Central Dispatch），多线程技术的封装是其核心之一。GCD内部管理线程池，对上层以队列的形式提供操作接口，任务则以block的形式提交到队列，最终由GCD决策如何将任务派发到线程执行。 之前有翻译过raywenderlich中关于GCD的两篇文章，里面比较清楚的讲解了串行、并发的概念以及基本的API说明。今天来重新整理一遍libdispatch相关内容，其缘由是前不久项目中发现对队列与线程的一些误解。记录与分享之。 背景知识并行与并发parallelism与concurrency的区别，这个在raywenderlich也有说明。简而言之，并行（parallelism）在计算机领域则指的是机器指令的同时执行，也就是多个处理器执行；并发（concurrency）指的是逻辑层面的同时进行，其对立面是sequentially、任务间有先后顺序的处理方式。不太恰当的举个例子，项目开发上我们不同团队之间会是并行开发，比如后端、前端、美术团队是同时进行；而至于你，则一边听着音乐、一边码着代码。前者强调的是物理线路的分离，后者强调的是逻辑依赖的分离。并行的必要条件是并发，但并发不是并行的充分条件。放到所举栗子中，项目中不同团队的并行开发要求不同团队中的任务是没有依赖的，而就算任务不存在依赖，如果没有这样的团队划分（比如人员紧缺、职责混乱）也无法达成并行开发。 同步与异步synchronous与asynchronous，同步/异步在计算机领域多线程的语境下，通常用来用来描述两个（及以上）操作之间的协作关系。程序执行中的状态通常称之为上下文（Context），切换进程、线程以及函数调用都需要切换上下文。我们知道，每个线程是一个无分叉的CPU命令执行序列。我们发起一个过程调用时，函数调用栈会将上一个函数的上下文信息（栈幁，活动记录，可参考wiki）push到栈中，直到函数处理结束后栈幁pop出，指令执行指针（如PC或IP）才会被重置到发起调用前代码的下一条指令。同步调用或异步调用（回调），描述的是消息的通知模式，也就是被调用的函数过程的执行结果，是通过返回值还是通过回调函数/闭包的形式来通知调用者，前者是同步调用后者是异步调用。这是两个函数过程的不同的协作模式。所以，像“异步函数”这种是很不恰当而奇怪的称呼。 所以所谓“同步队列”、“异步队列”这些是误用。 多线程方案按抽象层次从低到高列举简单介绍如下： pthread 符合POSIX标准的libc（或glibc）中的线程库实现 NSThread 苹果的基于pthread实现的OC接口的线程管理类 GCD 苹果实现的C接口的任务/队列管理，线程池管理 NSOperation 基于GCD的OC接口的任务管理，添加了任务依赖等特性 目前最常用莫过于GCD与NSOperation了。 GCD基础知识串行、并发队列GCD中所有队列都是FIFO的方式对任务的出列进行管理，可以分为两大类：串行队列、并发队列。 其中串行执行队列，必须等每个出列的任务执行完后才将下一个任务出列；而并发执行队列则是当前任务出列后，无需等待执行完毕，在并发数允许的情况下，可以将下一个任务出列。 需要先提一下，GCD中的任务dispatch通常会有两组接口，一组是dispatch[_xxx]_sync(queue, task)，一组是dispatch[_xxx]_async(queue, task)，其功能都是将任务task提交到队列queue中执行。这里的sync与async的概念可能与&quot;过程阻塞调用&quot;更接近。前者是派发同步调用的任务，后者派发异步调用的任务。dispatch[_xxx]_sync(queue, task)的函数调用，会想办法实现，在task执行完之后才继续执行调用前的下一条指令；而dispatch[_xxx]_async(queue, task)则仅是将task添加到queue中，然后该函数执行完毕继续下一条指令，至于task`什么时候执行它不关心。当并发数为1时，并发队列等同于串行队列。 GCD的队列细分可按下表所示划分为4种（见下表示）。主线程队列是个特殊的串行队列，可通过dispatch_get_main_queue()来取得。对于并发队列，提供提供了几个不同优先级的全局的并发队列。用户可自定义队列，接口为dispatch_create_queue(label, attributes)。 队列 类型 创建/获取 备注 主队列 串行 dispatch_get_main_queue() 全局并发队列 并发 dispatch_get_global_queue(priority, flag) 自定义串行队列 串行 dispatch_create_queue(“com.queue.name”, NULL) 需锚定 自定义并发队列 并发 dispatch_create_queue(“com.queue.name”, DISPATCH_QUEUE_CONCURRENT) 需锚定 示例： 线程池GCD对上层提供的概念是队列的概念，并自身维护了线程池，libdispatch会按需将队列中的任务派发到具体的线程中执行。 但队列与线程并非一一对应的关系。这是个很容易被误解的地方。（当然我这次也踩了这个坑） 提交到同一个队列的任务，并不一定在同一个线程中执行。即使是串行队列。 举个实际的例子： 为了解决数据访问的不一致问题（实际是Realm数据库读写），我们创建了一个串行队列syncqueue，会有dispatch_sync()以及dispatch_async()两种调用。我们的预期是，这不是串行队列吗？上面两种调用，是会在同一个线程中执行的。你觉得呢？sync与async的调用并不能保证是同一个线程中的操作，而Realm本身为速度而生、是一种mvcc结构，是允许多线程的同时读写，它的数据一致性是通过数据更新来实现的。结果可想而知，调用了delete异步写入之后，并不能反映到随后的同步query结果中。 事实上，是我们混淆了队列与线程的概念、关系。在上面例子中，sync与async的操作依然是遵循队列FIFO串行出列的特性的，但sync操作往往被dispatch到调用线程中执行，而async操作往往被dispatch到一个新的线程中执行。（可通过下面的测试进行验证） 所以务必记住线程池的概念，区分队列与线程。 主线程队列主线程队列有什么特殊？简要的说，这是个跟应用主线程关联的队列。 首先，只有主线程队列结合到主runloop中去了，主线程队列提交的任务一定在主线程执行。因为是串行队列，所有任务按提交的时间先后执行，在每次runloop循环中检查是否有任务并执行。非线程安全的UI操作，默认都需要在主线程（队列）中执行。 再者，在主队列异步提交的任务，也只会在主线程执行，而不会开辟新的线程执行。这是个容易被忽略的常识。因为对于异步提交到非主线程队列的任务，通常会被提交到另一个具体线程（与当前线程不同）执行。 目标队列主线程队列任务会在主线程中执行，全局并发队列中任务会被派发到具体线程中执行。但自定义队列中的任务不会直接被提交到具体线程中，而是需要锚定以上两种队列，称之为目标队列。自定义队列中的任务会被提交到目标队列中。 可使用dispatch_set_target_queue(object, targetqueue)来指定目标队列。 一些坑点 dispatch[_xxx]_sync的不当使用导致死锁 在串行队列中，派发同步调用的任务，必定导致死锁。例如在主线程中（或dispatch_async()到mainQueue的任务block中），调用dispatch[_xxx]_sync必定死锁；在其他串行队列同样如此（但并发队列不会，虽然官方不建议）。 dispatch_after(delta, queue, task)，在指定时间追加任务到队列中。 测试以下是一些基本测试，通过这些测试代码，你可能更好的体会串行/并发、同步/异步的概念。以下代码均在主线程调起。其中，syncq、syncq2为2个新建的串行执行队列，asyncq为新建的并发执行队列。 本文主要介绍GCD的一些基本背景知识以及基础知识，更详细的介绍以及拓展知识，将在后续系列中介绍。 本文完。"},{"title":"iOS开发：NSZombie的实现","date":"2017-03-31T12:54:38.000Z","url":"/ios/ios-nszombie-implementation/","tags":[["iOS","/tags/iOS/"],["runtime","/tags/runtime/"]],"categories":[["iOS","/categories/iOS/"]],"content":"写在前面在iOS开发调试内存问题时，Xcode提供了一个内存管理调试选项：Zombie Objects。打开这个选项，可以在访问已释放内存对象的方法时，进行警告。这里探讨下这个僵尸对象内部实现原理，以及动手去实现自定义的一个僵尸对象类。相关知识点主要涉及Objc的对象模型及消息机制。 属性修饰符Objc中对象是基于引用计数进行内存管理的。并且编译器支持由开发者通过声明的方式定义属性，而由编译器自动合成相应的访问方法。对象的属性特性由我们声明的、用于控制由编译器生成的存取访问接口的特性（attribute），正确的使用特性修饰符才能有效避免对象内存管理错误。 Objc的对象属性声明主要包括以下四种特性修饰符： 原子性 主要包括atomic及nonatomic两个修饰，默认情况下编译器会添加加锁代码来保证原子性访问。如果自行编写访问器代码，则自行控制加锁提供原子性访问。 读写控制 主要包括readonly、readwrite控制是否可读写，即是否相应提供getter、setter访问方法。 需要注意的是，这仅是对由编译器生成的属性存取接口的控制，对属性所指向的对象本身没有约束。举例，如若一个属性指向一个NSMutableArray类型对象，并且声明为readonly，那么只提供了getter属性访问器，但是对应的属性对象本身是可变的。 内存管理 属性封装的是数据，而数据必须有明确的所有权管理，这也是只影响setter访问器的，也就是在setter方法中，是否需要持有新值亦或是单纯的赋值给相应的实例变量。主要包括： assign：仅用于对数值类型的值的简单赋值； strong：声明了持有关系，当一个新值被设置时，新值首先被retain持有，旧值被release释放，然后执行赋值； weak：声明了非持有关系，新值被设置时，新值不会被retain，旧值也不会被release，基本与assign相同，但当对象被释放时，该值还会被设置为nil； unsafe_unretained：类似于assign，声明了非持有关系，但是用于对象类型，对象被释放时不会被置空； copy：声明了持有关系，但不同于strong的是，它不对新值做持有而是做了复制；常用于NSString这种内部可变的类型。 还有对应实例变量的几个修饰符：__strong、 __weak、 __unsafe_unretained、 __autoreleasing。 方法名称 也就是用于指定getter及setter的名称。 需要关注的也就是上述的“内存管理”的属性特性修饰，通常因为不当的使用assign或unsafe_unretained导致野指针及对野指针访问crash。 僵尸对象的内存诊断当访问野指针时，如果野指针所在的内存区域尚未被覆盖使用，则一切方法调用如常；一般情况下该野指针原先占用内存区域会被覆盖，此时访问野指针行为将是不确定的。比如，开发过程中可能会遇到这样的情况：crash并报错”[classXXX methodYYY]….unrecognized selector sent to instance 0x608000001fc0”，而classXXX没有这样的方法声明，相反selector是另外一个类的方法。这种情况是，野指针所指向区域刚巧覆盖了一个classXXX的实例对象。而大多数情况可能是其他未知类型数据，所报的则是“EXC_BAD_ACCESS”之类错误。 Xcode所加的Zombie Object的内存诊断则可以明确的指出错误原因是因为实例对象被释放、野指针访问的内存问题。测试报错如下：“ -[NTLObject call]: message sent to deallocated instance 0x608000036040”。 既然测试对象NTLObject已经被“释放”了，那具体报错信息是怎么得到的？怎么知道野指针原来指向的对象类型？以及当前所调用导致出错的方法？ 事实上测试对象并未被释放（这导致调试时大量对象得不到释放会有内存问题），因为编译器替换了根对象的释放方法，并将原对象的isa指针指向了动态生成的一个僵尸类，来实现对旧对象指针访问时的报错处理。这是基本的处理思路。 NSZombie实现原理在测试例子中，添加调试代码输出释放前后对象的类信息（包括类名、父类、元类、实例变量、方法列表等），可以看到，对于测试对象NTLObject，在对象“释放”后，对象isa指向了一个_NSZombie_NTLObject的类，其父类为空，元类为_NSZombie_。下面我们来重建自定义的僵尸类如NTLZombie，实现： 对象僵尸化，也就是对象释放后会变成一个“僵尸对象” 方法捕获，因为对象重新指向了新的类，新的类不可能全部实现原类的方法； 对象的内存释放对象僵尸化，我们首先需要阻止对象被释放，否则对野指针的调用直接导致内存访问错误（这正是NSZombie要监测的问题）。 Objc中的对象（继承NSObject）都是在堆中分配的内存（关于这点另有撰文介绍），libobjc（实际上还有Core Foundation框架）将对象实例其实现为一个objc_object的结构体（参考objc4-647源码）： 对于对象的创建，所有对象创建时都调用基类NSObject的+alloc方法（不自定义构建函数的话），将通过： (id)alloc _objc_rootAlloc(self) callAlloc(cls, false /*checkNil*/, true /*allocWithZone*/) 申请内存后进行isa的初始化及构建函数的调用。 对于对象的释放，则是编译器添加代码，自动调用各继承层次的-dealloc方法，进行非自动管理内存的释放；对于实例变量及本身堆内存的释放则是在根类调用： [NSObject dealloc] _objc_rootDealloc(self); obj-&gt;rootDealloc(); object_dispose((id)this); _object_dispose(obj); objc_destructInstance(anObject); free(anObject) 释放内存，并将原内存块数据isa指向一个“已释放类”（freedObjectClass，12字节的被特殊置位的内存块），避免消息发送时对Nil类的检查。关键步骤是objc_destructInstance，其实现为： 主要包含三个步骤： object_cxxDestruct，对象的析构 _object_remove_assocations，移除关联对象，从AssociationsManager中移除相应的ObjectAssociationMap objc_clear_deallocating，清理弱引用 步骤1，沿继承链向上逐级调用析构方法（类中对应selector为SEL_cxx_destruct的方法，.cxx_destruct），这个方法是编译器添加的实现，大概过程是遍历声明中的所有实例变量，调用objc_storeStrong函数进行release及置空操作。（注：SEL_cxx_destruct对应的是.cxx_destruct方法，这个是编译器添加的代码，后来搜索到了swift开源代码中的CodeGenModule.cpp，再然后发现sunny也做过相应的介绍，可以参考sunny的介绍） 步骤3，另外对于对象弱引用，libobc是将其保存到一个SideTable的类对象（C++）中，步骤3调用objc_object::sidetable_clearDeallocating()进行弱引用清理，具体可见后文的附1。 因此，为避免对象被真的释放了，我们需要替换根类的-dealloc方法。 对象僵尸化我们对象原本被释放后再访问需要触发警告，首先原本的方法调用不能正常进行，再者要能记录调用的方法进行报警。被“释放”后的对象需要能实现这点，就需要我们所谓对象僵尸化，将被“释放”的对象的isa指向另一个类型，否则原本的类实例依然能查找到相应的方法实现（后文有介绍），达不到警告的需求。 所以所谓的对象僵尸化，是我们将被“释放”的对象的isa指向一个新的“僵尸”类，并由僵尸类处理方法调用异常问题。这里有一个问题，我们如何保存对象原来的类信息？既然原本的对象已经被“释放”了，内存空间作废了，能不能利用上？ 对象实例objc_object的内存布局中，首先是isa指针，紧跟着各继承层次的ivar实例变量。假如使用实例变量所在内存区域来保存原来的类的信息的话，是没有保证的（有些类并没有声明实例变量）。因此，原来类信息无法保存到实例对象内存区域，僵尸对象类也不能是一个固定的类，否则实例对象无法识别原来类信息。因此对于每一个被僵尸化的类，需要动态注册一个类，并保存原来的类信息。通过log出来可以看到，苹果的做法是，将原来类名作为僵尸类的后缀，并且替换了旧的dealloc方法为__dealloc_zombie。 具体实现，可以通过objc/runtime提供的接口，动态创建一个僵尸类：（代码应加锁，代码示例参考mikeash） 替换dealloc方法，修改对象的isa类型指针： 并在僵尸化时进行方法替换：（注意，不是对僵尸类添加dealloc方法） 此后当对象被释放时，其isa将指向_NSZombie_XXXObject类对象，由后者进行消息传递的管理。 消息捕获新的僵尸类，未实现任何方法，在未做任何处理时，向原来的对象指针发送消息，会导致异常抛出。当然也不能继承原有类，否则消息方法的IMP还是能被搜索到。（注：实际上苹果的Zombie实现中，动态生成的僵尸类，其superclass为nil） 再来回顾一下objc的消息机制（消息查找具体可见源码lookUpImpOrForward方法实现），举例：调用[object message]向Object对象发送消息message 首先编译器层面会转换为objc_msgSend函数的调用：((void (*)(id, SEL))(void *)objc_msgSend)((id)object, sel_registerName(&quot;message&quot;));，对父类发消息或者根据函数返回值不同objc_msgSend会被替换为objc_msgSendSuper或objc_msgSend_stret。 根据isa继承链，在类信息中进行方法查找，若能找到相应的方法IMP则调用该方法，否则按以下3-6进行动态消息解析、消息转发（及异常抛出）。方法IMP的查找见下面附3详述。 动态消息解析（Method Resolution） 当步骤2中无法查找得到方法实现时， 将调用+resolveInstanceMethod: 或者 +resolveClassMethod:方法，可以动态提供一个函数实现。如果你添加了函数并返回 YES， 那运行时系统就会重新启动一次消息发送的过程（triedResolver保证仅一次）。对对象进行respondsToSelector 自省也可能会导致动态消息解析。（题外话，动态消息解析可以用在ORM方案中，\b我们可以在类初始化或者调用时进行方法的绑定） 在无法动态解析方法时，将在类对象的方法缓存中加入占位的方法缓存入口，进入消息转发。（CoreFoundation中forwarding_prep_0_ -&gt; _forwarding_） 快速消息转发（Fast forwarding） 对象实现-forwardingTargetForSelector:方法时，若返回非空对象，则消息被转发到该对象。（注：可以利用这个作为proxy） 若返回空的快速转发对象，则进行正常的消息转发。 消息转发（Normal forwarding） 基类的实现是：调用基类的-doesNotRecognizeSelector抛出异常。 这通常是我们对消息处理的最后时机。runtime会构建一个NSInvocation的对象作为参数，调用方法forwardInvocation： 首先，调用-methodSignatureForSelector:（CF实现）获得函数的方法签名（参数及返回值类型），若无法获得方法签名、返回nil，则直接导致-doesNotRecognizeSelector: 错误；否则可以对NSInvocation进行唤起：-invokeWithTarget:。（注：可以自行提供类型编码字符串获得方法签名[NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;] ） NSInvocation 是对一个消息的描述，包括selector 以及参数等信息，还可以在 -forwardInvocation: 里修改传进来的 NSInvocation 对象，然后发送 -invokeWithTarget: 消息给它，传进去一个新的目标等，可以控制消息的转发。 methodForSelector 获取IMP时，在没有对应方法时，返回的是 _objc_msgForward ，\b但不会有消息转发的过程。 因此我们可以在methodSignatureForSelector方法中捕获到方法调用进行处理，或者提供相应的方法签名，在forwardInvocation中处理。 僵尸对象方法调用主要是修改方法签名的获取方法： 并在上文代码“// … 消息捕捉处理”中添加方法： 僵尸对象的处理即完成。 其他附1：对象释放清理弱引用过程 SideTable是用来保存对象引用计数及弱引用的类，其中包括3个公开属性自旋锁slock、引用计数散列表refcnts、弱引用表weak_table，并使用一个静态数组table_buf保存所有SideTable实例，提供工厂方法tableForPointer查找对应的table。 首先是查找refcnts得到其引用计数，它是一个DenseMap类型，其值为site_t类型（其低位第0位是标记是否被弱引用），若存在弱引用则执行weak_clear_no_lock清理： weak_table_t以被引用对象指针哈希化（ptr_hash）之后作为索引，weak_entry_t类型作为值，weak_entry_t保存了所有weak引用了该对象的指针的指针。对象dealloc后执行到该步骤，会将该对象的所有弱引用指针置为nil，并从weak_table中移除该entry。 另外，上面所提到的table_buf是在可执行文件被操作系统加载、链接符号绑定之后的初始化进行创建的，具体调用可查看入口点_objc_init方法。 附2：objc_class 以上是Objc-2.0以前的类对象结构定义，Objc-2.0之后大概是这样 主要是对类信息等数据的封装，从概念上没有太大差异。 附3：IMP查找objc_msgSend()会调用class_getMethodImplementation(cls, sel)继而调用lookUpImpOrNil进行方法查找，若查找失败，则返回_objc_msgForward的IMP，这个实现了具体的消息转发过程（见上文）。 lookUpImpOrForward正是上文提到的消息查找： 上述代码中的realizeClass主要处理类对象初始化过程： 父类（superclass）、元类（metaclass）及根类处理 实例大小设置 构造函数调用 附加类别方法（到方法列表）（所以方法的查找以类别的优先，类别的加载在符号绑定后的回调） 另外需要说明的是SEL类型，这实际上可以看做是一个整型值，实际有一份字符串与SEL之间的映射表，详细可查看__sel_registerName方法。这个在方法缓存中也可以看到，缓存的存取是以SEL为key的，key的类型被定义为typedef uintptr_t cache_key_t;、typedef unsigned long uintptr_t;。"},{"title":"VPS搭建博客——不完全指南","date":"2017-03-20T13:41:36.000Z","url":"/undefined/vps-hexo-blogging/","tags":[["VPS","/tags/VPS/"],["hexo","/tags/hexo/"]],"categories":[[" ",""]],"content":"一开始折腾Jekyll，后来使用hexo搭建博客托管在了Github Page上。再后来，买了VPS（主要是为了学习Sock5！），博客便迁移到自己的服务器了。本文主要记录使用CentOS结合hexo搭建个人博客的流程。 更新：因为IP间歇性被封，重新部署了一遍，配置HTTPS，Hexo发布流程也改了。有时间再整理出来！ 本人使用的是Vultr的VPS，Vultr实际上官网有专门撰文介绍了在CentOS上搭建hexo。下面看实际踩坑后的总结： # 基本原理hexo的发布其实比较简单，就是将静态博客站点托管在VPS上而已。请看流程： hexo在本地机器生成发布文件后，通过git推送到VPS上，并且VPS上的git仓库配置了git-hooks，在接收到git仓库更新后，将内容拷贝到web服务站点即可。 # 环境配置本地： Mac OS 10.13.6 (默认包含git、ssh等工具) Node.js (使用nvm管理) hexo: 3.8.0（请参照官网搭建） VPS：(Vultr) CentOS 7 git 2.17.1 nginx 环境搭建、ssh连接vps这些自不必多说了，参考官方介绍或Google一下即可。 # 整体流程参照基本原理图，整体流程如下： 1、服务器基本环境搭建，安装Git、Nginx等 2、服务器配置Nginx 3、服务器创建Git仓库，配置git-hooks 4、本地发布并部署 VPS安装Git及Nginx 使用git —version及nginx -v检查是否安装成功。 VPS配置Nginxnginx的目录一般是在/etc/nginx/，建议先备份一下nginx.conf文件。 cd /etc/nginx/ cp nginx.conf nginx.conf.backup 需要修改配置文件中http配置，可自行了解nginx后再处理，我的配置如下： 在http末尾添加include /etc/nginx/vhost/*.conf;。这是为了将多个不同服务隔离配置。对于有多个（子）域名的时候，就非常方便了，并且互不影响。 在/etc/nginx/vhost目录（若没有请新建）下建立配置文件，比如我的技术博客是 tech.kernelsense.com.conf，配置如下： 主要是配置server_name以及对应的服务根目录root。你姑且可以参考我的配置来。 配置保存后，可以nginx -t检查配置文件语法是否有问题。systemctl status nginx检查nginx状态，running为运行中正常。 VPS创建git仓库创建git用户首先需要创建git用户，专门用来管理git仓库，方便ssh访问。 基本命令记录如下：(有问题请自行Google解决) 在以下内容下方： 添加一行： 保存后恢复sudoers权限为400：chmod 400 /etc/sudoers。 配置ssh访问su git切换用户后，将本地机器的相关服务的ssh的rsa公钥添加到vps上： 在本地机器进行测试： 创建博客的git仓库在git用户目录下创建： 是在su git情况下，否则需要修改权限： 创建git-hooks在切换到git用户后，在相应的git仓库下 配置如下： 原理如上所述。 根据个人需要修改目录。保存后执行chmod +x post-receive添加执行权限。 本地部署修改本地hexo的站点配置文件_config.yml，一般在末尾，配置： 若未安装deploy插件，请安装： 部署步骤很简单： "},{"title":"VPS搭建博客——购买及环境配置(2018)","date":"2017-03-17T14:29:16.000Z","url":"/ios/vps-vultr-tour/","tags":[["VPS","/tags/VPS/"],["博客","/tags/博客/"]],"categories":[[" ",""]],"content":"作为软件研发人员，我们对国外优秀技术平台、技术资源是有一定偏好跟需求的。搭梯子是一个非常规操作，这里按下不表。本文主要介绍VPS购买及基础环境配置，后文还有介绍搭建博客的过程。躺了坑也公开说一下，方便后来人。 VPS是什么？VPS全称 Virtual Private Server。虚拟专用服务器技术，是将一台服务器分隔成多个虚拟专享服务器的服务。每个VPS可配置独立公网IP、操作系统、内存、CPU资源和系统配置的隔离，为用户模拟出”独占”计算资源的体验。简单可以理解VPS是一台拥有公网IP的服务器。 VPS提供商有很多，譬如Vultr、Digital Ocean、Linode等等。本文将介绍的是Vultr，它的费用最低甚至到每月2.5美元（只能IPv6），对于搭建博客及学习是足够的。学习的话，虽然现在使用docker同样方便的，但对于需要公网访问的服务，比如捣鼓点个人项目时，就需要VPS了。当然，也有人拿来学习sock5协议，这不在本文介绍范围内。 购买及部署VPSVultr 提供多个地区的节点，按时间计费，并且根据选定的配置有费用上限。性价比较高，服务也比较稳定，在我使用这么长时间以来，暂时还没发现博客无法访问的情况。 创建帐号等流程就不用多说了，访问Vultr注册帐号即可。可以使用我的推荐链接，，优惠时时变、可以关注一下官方说明。 利益相关：推荐链接可能给双方带来优惠，如果不需要刻意直接打开  。 注册完成后，会弹出Billing账单支付页面，其实就是预充值的意思，避免后续部署流程中断、推倒重来较为麻烦。建议先充值最低$10即可。 支付方式目前支持PayPal、Bitcoin、支付宝以及微信支付等。我个人选择是使用PayPal，这个无所谓的，后续也可以修改。选择PayPal主要是自动扣费，免得有时懒或者忘记了~~~ 登录之后，选择Products，点击右侧加号（Deploy New Server）。 Choose Server选择Cloud Compute。Server Location就个人喜好了，我选择Los Angeles的。Server Type个人喜好，我选择CentOS。Server Size个人喜好，我选择$5/m的，搭建博客、科学上网都是够的。Server Hostname是管理后台别名的，如果有多台机器实例，方便区分而已。 SSH Keys的步骤需要将你访问终端也就是你电脑上的SSH公钥（一般是.ssh目录下.pub文件，譬如id_rsa.pub）配置上去，可以参考这里。 如果你机器配置了多个SSH的密钥的话，可以单独创建一个公私钥对： ssh-keygen -f id_rsa_vultr -C “SSH_GIT_ON_MBP” 建议配置一下.ssh目录下的confg文件，譬如 Host vultr ​ HostName XX.XX.XX.XXX # 注：VPS的IP ​ User git #请使用实际登录帐户，如root ​ PreferredAuthentications publickey ​ IdentityFile ~/.ssh/id_rsa_vultr ​ IdentitiesOnly yes ​ AddKeysToAgent yes 之后就可以 ssh git@vultr 来免密登录服务器了。 然后点击Deploy部署，等待部署完毕即可。 登录VPS在Vultr上选择Products，Instance栏下可以看到刚才创建的实例： 点击进入服务器信息页面： 可以看到页面显示该VPS的IP地址、Username、Password等。 打开终端登录该服务器即可。(若VPS上未配置好SSH免密登录，需要输入上述管理后台记录的密码) 登录之后，可以学习操作的东西就比较多了，，这个看个人兴趣了。 其他Vultr支持一键备份、恢复，好处是：更换IP！建议全部配置完成后，做一次Snapshot保存一下。"},{"title":"Lua语言入门基础","date":"2017-03-14T13:02:00.000Z","url":"/ios/lua-basic/","tags":[["Lua","/tags/Lua/"],["Wax","/tags/Wax/"]],"categories":[["编程","/categories/编程/"]],"content":" Wax是一个不怎么热门的App脚本化的框架，基于Lua引擎与Objc运行时特性来实现。苹果对JSPatch着力打压，而刚好我之前有过Wax相关的实践，正好可以介绍下。Wax相关内容主要包括（一）Lua语言基础（二）Wax的实现原理。 本文主要介绍Lua的一些基础概念与入门知识。 需要说明的是，Wax是基于Lua的v5.1版本的（Wax第一次提交是在2009年6月），v5.2是在2011年末发布，C API有变动，且不兼容。本文中主要基于v5.1的manual对与wax框架相关的内容进行介绍。 写在前面Lua是一个开源的脚本语言，官网是www.lua.org。但除了语言作者的Lua实现之外，还有LuaJIT这样的非官方实现。我们讨论的是Lua官网的标准实现。 Lua跟JavaScript有着很多相似的地方。比如JavaScript的prototype对应Lua的元表、元方法，还有变量对象与执行环境。当然Lua其实更早出现，v1.0在1993年发布（公众版本是’94年v1.1），一直至今遵循其简洁高效的设计目标。且作为一门TIOBE前30、核心库只有100KB（v5.1），且广泛应用于游戏编程、嵌入脚本的语言，也是非常值得学习的。 Lua语法简单且有强大的数据描述结构。相比而言，JavaScript要复杂很多——至少看上去specification也是多很多。Lua是动态类型的，通过一个基于寄存器的虚拟机来解析字节码，并且是支持递进式垃圾回收的自动内存管理；被实现为一个用纯C编写的代码库（Lua核心，其他都是基于这些库来开发）。 Lua通常是作为一个拓展语言被嵌入到宿主程序中，宿主程序可以调用Lua函数、读写Lua变量以及注册C函数提供给Lua调用。Lua核心库的C-API不多，能方便的被嵌入主程序提供脚本化支持，这也是Lua的设计目标及优点所在。 需要说明的是，Lua编程其实涉及两方面：除了Lua脚本编程，还有与宿主程序的对接（基于Lua的C API编程）。像Wax这样的框架，主要是处理与宿主程序的对接，也就是Objc与Lua的互调与数据通信。 学习线路对于希望了解Lua的童鞋，建议根据需要选择学习路线： 入门了解：可以参考Coolshell的“简明Lua教程”； Lua语法与C API：“Programming in Lua”（简称PIL，Lua作者编写），主要介绍语法及Lua标准库、C接口API等细节； Lua的语言设计：语言手册，manual，是Lua的语言规范，可以理解为原理介绍； Lua5.0的实现：作者的语言设计论文。 学习Lua脚本编程的话1、2就够了。 Lua基本概念基本数据类型Lua中有8中基本类型：nil, boolean, number, string, function, userdata, thread, 以及 table。Lua是动态类型语言，这意味着变量没有类型，值才有类型。所有的值都是一等公民（first-class values），也就是包括function、thread等在内的所有类型值都可作为参数或返回值。 nil是一个值，表示一个有意义的值不存在时的状态。这个得提一下作者关于值的数据结构设计： 称之为tagged-union，打了标签的联合体，(t, v)标签-值对。 在Lua的实现中，用t一个标志位即可表示nil值。具体的值则通过Value这个联合体表征，可以是由GC管理的对象GCObject *gc、C指针p表示的轻量用户数据、lua_Number表示double类型（number）、整型b表示boolean。GCObject可表示string、table、function、heavy userdata及thread。 string是有明确大小的字节数组，因此可以包含任意二进制数据，包括”\\0”。 userdata （通常译为”用户数据“，若非特别指明，指的是”完全用户数据“）类型允许将 C 中的数据保存在 Lua 变量中。 用户数据类型的值是一个内存块。有两种用户数据：完全用户数据，指一块由 Lua 管理的内存对应的对象；轻量用户数据，则指一个简单的 C 指针，内存由宿主程序负责管理。用户数据在 Lua 中除了赋值与相等性判断之外没有其他预定义的操作。 通过使用 元表 （元表在下文介绍），程序员可以给完全用户数据定义一系列的操作。 你只能通过 C API 而无法在 Lua 代码中创建或者修改用户数据的值，这保证了数据仅被宿主程序所控制。wax有使用userdata将Objc中的值传递给Lua中使用。 table类型是Lua中主要的数据结构（通常译为”表“，下文中如无歧义”表“指代table类型的值），也是Lua脚本中唯一的可自定义的数据结构。table在lua中被实现为关联数组，它的索引可以是任意非nil值，值可以是任意值，table的大小动态增减。在Lua5.0之前table被实现为哈希表，v5.0中则针对数组做了优化：由哈希及数组组成，数组可以减少key的存储，且访问更直接，参考图： thread则代表协程，协程是一种并发编程方式，高大上的内容Wax框架中没有涉及，不做介绍。 function表示Lua中的方法或者遵循Lua虚拟机交互接口的C函数（因为可以注册C函数到Lua中使用）。 table、function、thread以及userdata完全用户数据在 Lua 中被称为对象： 变量并不持有这些对象的值（value），而仅保存了对这些对象的引用（reference）。 赋值、参数传递、函数返回，都是针对引用而不是针对值的操作， 不会做任何形式的拷贝。 使用type库函数可以返回一个string格式的值类型的描述。 关键词主要是以下这些： 真的是很少的了！ 错误处理作为嵌入式语言，Lua中所有行为始于宿主程序中C代码对Lua库函数的调用，因此它也将错误处理的主导权交给宿主程序。 在Lua中可以使用error来显式抛出错误，若希望在Lua中捕获错误，则使用pcall或xpcall在保护模式下调用函数。出现错误时，会抛出一个错误对象。使用 xpcall 或 lua_pcall 时， 需提供一个 消息处理函数用于错误抛出时调用。该函数需接收原始的错误消息，并返回一个新的错误消息。它在错误发生后栈尚未展开时调用， 因此可以利用栈来收集更多的信息， 比如通过探知栈来创建一组栈回溯信息。 若需在C中捕捉异常，使用lua_atpanic指定一个回调方法。 垃圾回收Lua自动内存管理，运行GC（Garbage Collector，垃圾收集器）来回收内存，所有由Lua使用的内存都遵循自动内存管理，包含table、function、string等。使用两个参数来控制垃圾收集循环：垃圾收集间歇率及步进率，具体参数意义可参考manual中说明。可以通过在 C 中调用 lua_gc 或在 Lua 中调用 collectgarbage 来改变参数。主要介绍垃圾回收元方法及弱表，这在wax中都有使用。 垃圾回收元方法对于userdata用户数据类型，可以通过C API来设置垃圾回收器元方法，这些元方法也被称之为“终结器（finalizer）“。”终结器“允许你来协调Lua的GC与外部的资源管理（如文件管理、网络、数据库连接或内存释放等）。 对于元表中包含__gc元方法的userdata用户数据类型，GC不做立即回收，而是将userdata放到一个列表中，等当前回收循环接收后，以LIFO的方式，分别调用其__gc垃圾回收元方法，参数为userdata，此步骤中交由宿主程序处理其内存释放问题，而userdata用户数据类型值本身将在下一轮垃圾回收循环中被释放。 弱表弱表指的是内部元素是弱引用的表。GC会忽略弱引用的对象，除非该对象只被弱引用。 弱表可以有弱键、弱值或键值都是弱引用。弱键的表允许GC回收它的键而阻止回收它的值；键值都是弱引用的表则允许GC回收其键值。在任何情况下，只要键或值被回收，该键值对也会从表中移除。 表的键值弱属性，由其元表的__mode域进行控制，弱键或弱值分别对应k或v。在将一个表指定为元表后，其中的__mode域就不应再修改，否则由这张元表控制的表的弱属性行为是未定义的。 语法规则主要提供完整的扩展BNF范式描述的语法规则（v5.3）。BNF中，{}表示0或多个，[]表示可选，|表示或者，:=表示定义。详细看PIL介绍，不展开介绍语法规则了。对于一些关键的概念则在下文中介绍。 元表及元方法Lua中的每一个值都可以有一个元表（metatable），这个元表是一个普通的Lua表，其中定义了原始值在特定操作下的行为。可以通过修改元表的相应的域，来改变这些行为。例如，当一个非数值的值作为加法操作的操作数时，Lua会检查其元表中对应”__add“域的方法，若存在则调用该方法来执行加法操作。 元表中的这些键对应被称之为事件，对应的值则称之为元方法（metamethod）。在上面的例子中，”add“是事件而元方法则是执行加法操作的函数（function）。在Lua中可以通过getmetatable方法来获取任何值的元表；对于table类型的值可以通过setmetatable方法来替换其元表，但对于其他类型除非使用debug库不能修改其元表，如要改则需要调用C类型API。gc也是一个特定的事件，其对应的元方法用于配合GC进行内存处理等。 table及userdata（完全用户数据）类型的值可以有独立的元表（当然也可以多个table或userdata共享同一张元表），而其他类型的值每种类型共享一个元表。 元表中以”前缀+事件名“作为对应的键，用来存放对应事件操作的元方法。如对应”add“操作（事件）的key为”__add“。元方法的访问不会触发另外的元方法，访问一个没有元表的对象的元方法不会失败（仅返回nil）。在Lua或C中可以通过rawset或rawget的方式，在不触发访问元表的情况下进行访问。 有诸多内置的操作和元方法，如算术操作add等、比较操作eq等、索引index、索引赋值newindex以及函数调用call等。如果需要比较的话，大概相当于操作符重载的概念。具体可查看manual，这里主要介绍比较重要的三个： indexindex操作主要是对值进行索引（或者称为subscript），对table类型相当于调用 table[key]，也就是一个查找操作。 当 table 不是表或是表 table 中不存在 key 这个键时，index被触发。 此时，会调用__index相应的元方法，可以是一个函数也可以是一张表。 如果是一个函数，则以 table 和 key 作为参数调用它。 如果它是一张表，最终的结果就是以 key 取索引这张表的结果。 （这个索引过程是走常规的流程，而不是直接索引， 所以这次索引有可能引发另一次元方法。） 需要先指出的是，通过C API可以向Lua注册函数，因此同样可以在C中注册__index这些域对应的函数，在宿主程序中接收相应的事件并将处理结果回传到Lua。这也是Wax中所使用到的，用来索引Objc类及创建对象实例。 newindexnewindex操作对值相应的域进行赋值，相当于 table[key] = value，赋值操作。和索引事件类似，当table 不是表或是表 table 中不存在 key 这个键的时候，会触发newindex事件，调用__newindex元方法（若存在的话）。 callcall操作是函数调用， 当 Lua 尝试调用一个非函数的值的时候会触发这个事件 （即 func 不是一个函数）。 查找 func 的元方法， 如果找得到，就调用这个元方法， func 作为第一个参数传入，原来调用的参数（args）后依次排在后面。 Lua的元表跟JavaScript的prototype有几分相像，在JavaScript中可以通过prototype原型链支持面向对象等特性，其实在Lua中同样可以利用元表及执行环境来实现。 执行环境除了元表，thread、function、usertable这些类型的对象还绑定了另外一张表，称之为其执行环境（environment）。与元表类似，执行环境也是一张普通的table类型的表，多个对象也可以共享同一个表。 对thread类型，协程创建时，得到的thread对象与创建时的协程共享执行环境。 userdata类型及C函数与其创建函数共享执行环境。非嵌套Lua函数（由loadfile、loadstring、load创建）于创建时的协程共享执行环境。内嵌的Lua函数与其创建时的Lua函数共享执行环境。userdata绑定的执行环境对Lua是无意义的。 Lua函数绑定的执行环境被用于访问函数中的全局变量，也作为其内部创建的内嵌Lua函数的默认执行环境。 可以通过调用setfenv来改变Lua函数或者当前运行协程的执行环境，同理通过getfenv来获取其执行环境。对于其他类型的对象（userdata、C函数及其他协程），必须通过C的API来操作修改执行环境。 另外，Lua 中含有一个被称为全局环境的表，它被保存在 C 注册表（后面还有介绍）的一个特别索引LUA_RIDX_GLOBALS下。 在 Lua 中，全局变量 _G 被初始化为这个值。 但是，执行环境表有什么用，有什么必要修改？先来看一个实际的例子： Security:verify(pwd)以及self:checkPwd(pwd) 这些方法调用为什么能正常？明明verify并不是Security这个值的一个\b域，它仅是模块中定义的一个全局function变量吧？实际上，这个正是通过替换执行环境来实现的。（注：function及self的说明见后文） 因此，执行环境可以简单理解为包含其可访问全局变量的表。下例中会报错“attempt to call global ‘print’ (a nil value)”，因为当前执行环境被替换一张空表，并没有print的域。 通过setfenv可以指定函数的执行环境，第一个参数1表示当前执行环境，2表示上层调用方的执行环境，以此类推。Wax实现的正是将waxClass定义类所在的模块中的所有function的执行环境指定为对应class的userdata相关表了。 另外，还需要指出的是，新版本的Lua已经废弃了setfenv的接口，而是采用了直接设置_ENV的方式来指定执行环境。 脚本加载及requirepackage库提供了Lua中加载与编译模块的基本工具，导出了两个方法require及module到全局环境。 requirerequire (modname)用来加载模块代码，首先会查找缓存表package.loaded，若modname模块被加载过，require 返回 package.loaded[modname] 中保存的值，否则尝试为该模块查找加载器 。 加载器的查找，require是由package.loaders数组来引导的，默认配置的查找如下： 首先 require 查找 package.preload[modname] 。 如果存在一个值，那它（应当是一个函数）就是那个加载器。 否则 require 使用package.path 配置的路径来查找Lua加载器。 如果也查找失败了，则使用package.cpath配置的路径去查找一个C加载器。 如果都失败了，就是用默认的all-in-one加载器 。 一旦找到一个加载器，require将调用这个加载器（参数为modname），若加载器返回任何值（非空），则require将赋值到package.loaded[modname]；若没有返回值且package.loaded[modname]为空，则require将其赋值为true。require返回package.loaded[modname]最终的值。 那么加载器会返回什么值呢？其实一般就取决于当前Lua模块的返回，加载器读入代码进行解析，当前模块可以返回一个function、table或者不返回等。在使用waxClass时，其实一般也没有返回。 package.loaders这是一张用来控制模块加载的表。这张表中每一项都是一个搜索函数（接受一个modname的参数），require按升序调用其中的搜索器函数，调用结果返回另一个函数（也就是模块加载器函数）或者一个错误描述字符串。Lua初始配置了4个搜索函数，正如上面require中阐述那样。（注：v5.3修改为package.searchers） modulemodule (name [, ···])创建一个模块。按以下顺序创建模块： package.loaded[name]包含一个表，否则如果有一个同名的全局表，否则创建一个表t并赋值给全局同名变量及package.loaded[name]。 module这个方法还初始化了t.Name，t.M以及t._PACKAGE（分别是参数name、模块自身以及包名），最后，模块设置t作为当前函数的新的执行环境及package.loaded[name]，使得require返回t。 初次之外还提供了dofile、loadfile相关的函数。 那可以自定义加载器吗？因为默认的加载器执行的是默认的文件读取并作为一个chuck读入执行，假如我们需要加解密脚本，这是不够的。答案也是明确的，可以自定义，这个将在wax中再介绍。另外，wax中还没有用到module。 function与self闭包首先，什么是闭包？摘录Wikipedia上的定义如下： In programming languages, closures (also lexical closures or function closures) are techniques for implementing lexically scoped name binding in languages with first-class functions. 中文解释是，引用了自由变量的函数称之为闭包。闭包最初是函数式编程语言实现的，现在如C这样的命令式编程语言其实也已经支持（Apple以block的形式为C添加了闭包的特性，由LLVM编译器支持）。 当Lua编译一个function时，它生成了一个包含该函数的虚拟机指令、常量值以及一些调试信息的原型。在运行时，当Lua执行一个function...end表达式的时候，它创建一个新的闭包，每个闭包包含对相应函数原型的引用、环境表（查找全局变量）的引用以及一组upvalue（用于访问外部局部变量）的引用。 对于访问外部局部变量，词法作用域与一等公民函数（闭包）的组合制造了众所周知的难题。下面的例子中，当add2函数调用时，其函数体访问了外部局部变量x，然而此时创建add2的函数add已经返回了，如果x是存在栈中的，这个变量所在栈幁理应已被回收导致访问出错。那Lua是怎样实现闭包捕获外部局部变量的？ Lua使用了一个称之为upvalue的结构来实现的。任意的外部局部变量都是通过一个upvalue间接访问的，该upvalue最初指向局部变量所在的栈元素，当变量离开作用域后，它会从栈移到upvalue中。因为所有对这个变量的访问是间接通过指向这个upvalue的指针来实现的，因此读写对Lua是透明的。不同于内部的函数，声明该变量的函数是直接访问栈来访问局部变量的。 熟悉Objc中的block的实现的，是不是觉得有些似曾相识（关于block的实现另有说明 ）。对于堆中的对象，不做说明，因为它始终都是通过指向堆上的指针来访问的，前后一致。简单提一下，对于需捕获的栈中的局部变量，用__block修饰后，事实上编译器已经将其修改为__Block_byref_{$var_name}_{$index}命名的结构体了，也是通过间接访问来实现，该结构体中保存了原始的变量值。另外该结构体中包含一个指向本身类型的指针__forwarding，用来支持__block变量从栈转移到堆内存中，其访问方式为 __blockVar-&gt;__forwording-&gt;localVar。所以，原理是相通的，增加间接层。 Lua通过保存一个仍指向栈中变量（称之为pending var）的链表来索引upvalue以供重用保证每个局部变量的upvalue唯一性。当Lua创建一个闭包时，会扫描它所有的外部变量，通过重用索引链表中的upvalue或新建一个来捕获外部局部变量。 selfself是Lua中的一个关键字，用法请参照上面的 iPhone.lua。但上面的self用法其实只是个语法糖，下面的调用是一样的： 在以冒号:调用的语法中， self是将调用者作为第一个隐含参数传递给函数。 C编程接口这里主要是描述与宿主程序通信的C编程接口。主要关注几个关键的点：栈、索引、C闭包、注册表以及一些关键的API。 Lua中的虚拟机状态机： 这是个线程独立的参数，所有的接口调用都基于这个状态变量，这是所有C接口函数都必须接受第一个参数。 栈与索引Lua脚本与C之间的互调必须能进行参数传递、数据通信，Lua 使用一个虚拟栈来和C数据通信，栈上的的每个元素都是一个 Lua 值（nil，数字，字符串，等等）。 当一个C函数被Lua中调用时，将得到一个新的独立于C函数的调用栈及原先Lua调用C的栈，包含了Lua传递给C函数的所有参数，且C函数可以将返回结果放入栈中返回给调用者。 C接口中对栈的操作，通常可以通过一个索引参数来指定操作栈中特定位置的元素。索引可以是1~n的正索引（n为栈大小），也可以是-n~-1的负索引，负索引表示从栈顶开始的偏移量。举例，lua_isnumber(L, i)是读取栈中第i个元素判断是否数值类型。 另外，一些接口方法隐含了入栈或出栈的操作，如lua_gettable (lua_State *L, int index);会读取index索引位置的表t，并以栈顶的值作为key，读取t[key]并将该值入栈。具体行为需要仔细阅读API说明。 lua_CFunctiontypedef int (*lua_CFunction) (lua_State *L); 这是能提供Lua调用的C 函数的类型定义，除此之外还约定了参数及返回值传递方法：C函数通过上述所提的栈来接受参数，参数以正序入栈，在函数开始时可以通过lua_gettop(L)来获取函数接收到的参数个数；返回值同样正序分别压入堆栈，并返回返回值的个数。在返回值之下的栈元素将被Lua丢弃。 下面这个例子中的函数将接收若干数字参数，并返回它们的平均数与和： C闭包上面提到的，绑定自由变量的函数就是闭包。当一个C函数创建后，可以将其与某些值（称之为upvalue）绑定，生成C闭包。当C函数被调用时，它的那些upvalue位于伪索引处，这些索引由lua_upvalueindex产生，其中第n个upvalue位于lua_upvalueindex(n)的索引位置。该函数参数超过函数本身的总上值个数（但&lt;=256）时，产生一个可接受但无效的索引。 void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);这个是将C闭包压栈的接口函数。为了将值绑定到函数，需要先将这些值正序压入堆栈，然后调用上述函数创建出闭包并将这个C函数压到栈中。参数n告知需绑定的上值总数，该方法也会将这些值弹出栈。n最大值为255，当n为0时将创建一个轻量C函数，也就是一个指向C函数的指针。 void lua_pushcfunction (lua_State *L, lua_CFunction f);将一个 C 函数压栈。 这个函数接收一个C函数指针，并将一个类型为 function 的 Lua 值压栈。当这个栈顶的值被调用时，将触发对应的 C 函数。注册到 Lua 中的任何函数都必须遵循正确的协议来接收参数和返回值 （参见 lua_CFunction ）。该函数作为一个宏：#define lua_pushcfunction(L,f) lua_pushcclosure(L,f,0)。 注册表（registry）Lua提供了一个预定义的表，称之为注册表（registry），提供给C来存放任意Lua值。该表可以通过伪索引LUA_REGISTRYINDEX来访问。因为是全局的，所以应当注意选择合适的key以防碰撞/覆盖。 注册表中的整数键用于引用机制，因此不应将整数键用作其他用途。 LUA_RIDX_GLOBALS则是全局表在注册表中的伪索引。 相关API简单列举几个常用的API如下： 其他说明可以考虑阅读Lua的源码！"},{"title":"iOS开发：跨开发商的应用数据共享","date":"2017-02-19T07:04:58.000Z","url":"/ios/ios-safari-cookie/","tags":[["iOS","/tags/iOS/"]],"categories":[["iOS","/categories/iOS/"]],"content":"iOS上App都是沙盒隔离的，如何做广告效果跟踪、用户拉新邀请奖励？ 本文将介绍一种可以跨开发商App进行数据共享的方法，基本原理是通过与Safari共享Cookie来实现。已实现放到github。 更新：据闻iOS新版本不支持了，请自行测试确认。 写在前面说下实际需求场景： 项目组开发的一个系列app，包括一个主应用（暂且称之为AppM）以及一系列子应用（暂且称之为AppX），AppM包含全部功能，而AppX则是另一个代码模板生成的多个应用，上线时AppM使用了公司开发者帐号Acc1，AppX则用了另外的多个帐号Accx。问题来了，产品功能合并，AppM中部分功能（比如攻略资讯）同步到AppC中了，原先分开的业务推送，现在也合并了，（可能）出现的问题是，假如需要对AppX及AppM同时推送同一条资讯，对于安装了多个这样应用的设备而言，用户有可能是接收到多条一模一样的推送消息。 原始需求就是要解决这个，服务端要过滤设备令牌，必须客户端能提供设备识别码。场景虽然不普遍，但有些公司在App Store上上架的多款app，确实会以不同开发者帐号提交的，每个帐号就是独立的开发商。 解决方案，一是能否在不同app中获取/生成相同的设备识别码？二是绕一下弯路，我们提供一个唯一码，但要求能在各个App间共享。我们分别来讨论两种方案。 设备识别码其实广告商也很关心这个事情。 设备识别码，要求稳定、唯一，通俗讲就是今天跟昨天取到的是一致的、你的设备跟我的设备是不一样的。 MAC地址 &amp;&amp; UDID传统的获取方式，包括其他平台设备中使用的，比如说mac地址啊，确实可以！获取方法就是调用系统库网络相关接口： 但是Apple家不开心了啊！为什么我家的东西你们知道的一清二楚！所以基于mac地址的几种方案，在Apple屏蔽mac地址获取的高版本系统中都失效了，基于mac地址的OpenUDID都无效 Twolow-level networking APIs that used to return a MAC address now return thefixed value 02:00:00:00:00:00. The APIs in question are sysctl(NET_RT_IFLIST) and ioctl(SIOCGIFCONF). 同样的还有苹果自身提供的UDID：[[UIDevice currentDevice] uniqueIdentifier]，40个字符的设备码，在iOS7之后被换成了prefix+IDFV。 IDFViOS6之后提供的，\u001c同一开发商在同一设备上的不同app能共享相同的IDFV，但对不同开发商是不一致的。获取方法：[[[UIDevice currentDevice] identifierForVendor] UUIDString]。同一开发商的app全部卸载后将重置。 IDFA这是个提供给广告商的设备识别码，获取方法：[[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString];，问题是，苹果继续加强隐私权限，用户可以手动关闭广告跟踪了，这时候拿到的IDFA也是非法值。 以上这些都是适用条件下理论唯一的识别码，除此之外，还有几个开源的设备识别码，不唯一（具体看碰撞率）不稳定但是可以应用在特定条件下，如OpenIDFA、SimuIateIDFA，详细可以看这篇介绍，但在实际业务上操作会复杂。比如OpenIDFA是有日期的加成，每天都变动，SimulateIDFA有启动日期及设备名称等信息加成，重启会变动。 单一的获取设备唯一码，都不太理想，对吧？再来看下数据共享的方案。 iOS应用间通信/数据共享iOS应用间数据共享有许多应用场景，但实现方式却是屈指可数。首先，iOS中每个app都是独立的单一进程，且受限于iOS的沙盒隔离机制，app进程的访问权限是有限的。我们先看下目前进程间通信及数据共享的几种方式。 传统的IPC方式 管道、共享内存、信号量 本地socket 传统的共享内存（shmget等）等方式，苹果会允许？socket要求两端在线，普通应用进入后台后存活时间很短，现实意义不大。 URLScheme这是常用的通信方式，目前也广泛使用在各大平台App的授权及OAuth2/SSO登录上。通过URL链接的形式调用，系统可以启动相关配置的应用，参数可以通过URL传递，或者下面介绍的粘贴板。目前的常用形式是，通过URLScheme发起调用，通过粘贴板共享数据。 粘贴板（UIPasteboard）提供了三种粘贴板： 第1种粘贴板是系统级别，各应用均可访问修改；第2种，可以在同一开发者开发的其他应用程序中共享数据；第3种是第2中特例。有个关键方法：- (void)setData:(NSData *)data forPasteboardType:(NSString *)pasteboardType;，支持现有UTI类型数据或任意二进制，往粘贴板的第一个item写入数据。 这样的话，岂不是可以利用keychain（下文介绍）+ pasteboard的方式实现应用间数据共享？试了一下，使用keychain持久化，使用pasteboard共享，差点就完美了， 但存在问题： 微信、微博、QQ等平台分享会导致粘贴板清空，共享失效 即使粘贴板未被清空，【VendorA_APP_A】将数据共享到粘贴板（及keychain）后，设备重启，下次启动直接使用【VendorB_APP_B】，无法拿到共享数据，将提供与【VendorA_APP_A】完全不一致的设备标识信息 没有保证的，一口老血。 Keychain（Access Group）Keychain是Apple提供的又一套数据共享、数据持久化的方案，实质上是对存放在/private/var/Keychains/keychain-2.db上的一个sqlite数据库的操作。当然这么好用的东西，苹果怎么可能没有权限控制。 苹果通过内置到app中的权限文件限制应用可访问的共享数据，还有所有访问自然都是限制在同一开发商中的。 之前我们也通过Keychain提供了一个设备识别码获取保存的框架，主要思路是，将IDFV及设备参数等发到后台获取一个GUID，将GUID写入keychain特定Access-Group中，这样同一个开发商便能够通过配置相同的Access-Group在设备上始终获取到同一个设备码，即使是原先所有app都被卸载后（IDFV会重置，见上文描述）。 可以通过Security框架进行keychain中内容的CURD操作，具体配置及操作其实已经有很多文章介绍就不啰嗦了。 实际上可以通过组合以上的几种方式来实现自己的需求的。微信、微博平台的授权登录、分享等是URLScheme+UIPasteboard组合的经典。在下面的介绍的SFCookie中，同样是多种方式组合。 SFCookie这个方案主要是因为iOS9新增的SafariServices框架。SafariServices新增类SFSafariViewController允许app内使用Safari访问Web页面，数据互通（关于Safari数据互通，还有个“共享Web凭证”）。我们将通过访问Safari的Cookie来实现数据共享。 但是它也是受限的，SFSafariViewController不允许访问本地html（所以必须将html配置到服务端站点），且iOS10之后应用审核规范中冒出了一条，明确不允许隐藏Safari视图。实际测试发现，如果SFSafariViewController的视图被hidden或者alpha值过小，它是不会加载页面内容的，其他方面限制暂未发现。适当规避这个还是可以利用它来实现我们的功能的。 SFCookie提供的是，通过SFCookie来访问存放在Safari中的Cookie，至于Cookie内容是什么根据业务而定。就文章开头所举的例子的话，可以是一个简单的设备令牌。提供的接口如下： 以上调用均为异步回调，默认回调到主线程。 SFCookie实现比较简单，仅提供了UIApplication+SafariCookie这样一个拓展方法分类，以及一个简单的包含内嵌JS处理Cookie的html文件“sfc.html”。给项目加入SFCookie的支持，需要 将“sfc.html”放到服务端站点上，并使用setNTL_SafariCookie_WebURL配置好加载的地址 配置appScheme，以确保能从SFSafariViewController得到回调 将UIApplication+SafariCookie分类拓展的代码加入项目，或使用pod的方式亦可 回调正是通过URLScheme的方式实现。AppScheme是可以各个客户端动态配置的，并作为参数传递给Web页面来保证正确的回调。需注意的几点： 参数尽量不要掺杂特殊符号，虽然内部已经做了URL编解码处理；如果有特殊符号需测试检验； AppScheme在设备上唯一（默认是safaricookie），否则从Web页面发起调用后，由系统决定跳转； 回到文章开头所提的需求，我们可以结合keychain，基本流程是： 从SFCookie获取特定键的cookie，若能取到并检验有效，便是所需要的设备码，结束 获取keychain保存的共享的设备码，若存在便是所需设备码，并将结果写入SFCookie，结束 生成/获取设备码，写入keychain及SFCookie，结束 具体查看源码。"},{"title":"iOS开发：关于模块化与路由","date":"2016-12-03T08:18:28.000Z","url":"/ios/ios-modularization-router/","tags":[["iOS","/tags/iOS/"],["架构","/tags/架构/"]],"categories":[["iOS","/categories/iOS/"]],"content":"说一下iOS应用开发中的模块化跟路由的事情。 前一段时间，一位同事一直怂我折腾这件事，关于组件化。组件化成了今年的热门，然后还有瓜。我大概也看了FRDIntent的邮件的探讨，挺有意思的。 我觉得大家也都认同一点，没有任何一套程序架构是通用的。大家都在谈组件化或者模块化（下文统一用”模块化”），瓜吃到了最后的时候，我觉得争辩的时候都混淆这个了——他们讨论的原本不是同一件事情。一个在说模块化怎么解耦，一个在说路由。 路由是路由，模块化是模块化。二者并不对立。 关于路由路由本来就是一个提供寻址的功能，你可以使用路由表（或其他映射手段），来减少调用路径的硬编码；如果没有路由，顶多也就是手动写死功能调用的逻辑。但毕竟使用路由，还是可以通过注册/回调来减少一些麻烦。假如用推送的场景举个例子： 在推送的payload中使用一个action的字段来标记推送业务类别，那么可以将各个不同业务的推送消息的处理逻辑，分别抽离成一个个单独的service（遵循特定的推送处理接口），并建立映射表action-&gt;service 。当接收到推送时，按约定的格式打包好数据，查找对应的service进行处理即可。 我们建立的映射表也是一种路由。这样的好处是，无论是否添加新的推送业务，推送的核心处理模块无需修改，只需要新增相应的service即可。这是一层解耦。再有，如果旧版客户端接收到了一个新的推送业务，因为映射表查找不到相应的service可以直接忽略了也不会有其他并发症。 跟原先的做法相比，可维护性提高，易于动态调用，并且单独的业务便于测试。 关于模块化再说到模块化。大家的标题都是“组件化”，但是实际讨论的貌似是“业务模块”或者说“功能模块”？“组件”，Components，更偏向于独立、可重用的系统“零部件”，所以个人觉得业务层面或许称之为“模块”更合适些。按照分层架构，业务模块层会基于下层的基础服务（组件）进行开发。组件处于纵向的层级中，组件的职责相对单一，对上层不能有依赖关系；而业务模块是在整个架构的最上层，模块间存在横向的关系——某种程度来说，业务间存在无可避免的耦合。这个逻辑依赖关系，是业务内置的，是没办法通过软件工程的手段去除的。 这样模块化就更好理解了。要尽量做到高内聚。要面向接口编程，提供接口、依赖接口，尽可能将耦合度降低到内在要求。路由当然也会起到一部分解耦的功用。 说到底，都是通过增加”间接层”来实现。 There is no problem in computer science that can’t be solved by adding another level of indirection. 显式的命名为“Mediator”也好，还是实现成一个“Router”也好，其实不重要。"},{"title":"iOS开发：自定义转场动画","date":"2016-11-06T13:04:08.000Z","url":"/ios/ios-view-transitioning-animation/","tags":[["iOS","/tags/iOS/"],["动画","/tags/动画/"],["转场","/tags/转场/"]],"categories":[["iOS","/categories/iOS/"]],"content":"写在前面转场动画（Transitioning Animation）顾名思义，是场景/界面转换的一种过渡动画；系统默认的push/pop/present以及iOS的相册浏览其实都是系统实现的转场过渡动画。本文主要是对自定义转场动画的一个梳理及说明。 先来看看iOS7之前系统提供的转场动画API： API注释如下： Transitions between two of the view controller’s child view controllers.This method adds the second view controller’s view to the view hierarchy and then performs the animations defined in your animations block. After the animation completes, it removes the first view controller’s view from the view hierarchy. 可以得知，这是对容器控制器控制子控制器视图进行切换的转场动画方法。其中，container是容器视图控制器，from与to是container的子视图控制器，animation是具体动画的实现代码块，completion是动画的完成回调块。但是这个限制了，一是动画只能提交到animation中、没有可交互特性，二是动画效果没有被重用，所有container进行转场时都需要实现一遍animation，或者需要另外封装转场的API。 iOS7后公开的的自定义转场动画API，可以理解为是对上面转场方法的拓展，功能的分离跟封装。导航栏、tabbar控制器以及modal转场都是系统内置的转场动画器管理，本文以modal转场介绍为主。 基本概念与APIiOS7之后，Apple提供了自定义转场动画的&lt;UIViewTransitioningDelegate&gt;系列接口。我们需要清楚基本转场概念，来更好理解这套API。 转场也是因为iOS的单视窗的机制，在需要展示新场景的UI时，必须将新场景的视图结构添加到应用窗口中。举个例子，在iOS7以前做类似微博图片点击放大预览效果，通常的做法，一是将预览视图直接添加到window上（动画简单、事件管理麻烦），二是将预览视图控制器引入到新的window视图结构中（动画麻烦、存在多window管理问题）。实际上更好的方式是像原生的push/present那样，将视图控制器纳入当前的视图结构管理中。 可以再看一遍上文引用的视图转场API及文档描述，这是转场的核心概念。所谓“转场”（transition），是场景的过渡，是容器控制器对其子控制器视图切换的管理。 iOS7以一套协议的方式暴露了转场的接口，主要提供了以下几个方面的动画控制： 动画控制，主要负责界面切换的（非交互式）动画； 交互控制，主要负责交互管理（如手势管理）、基于交互去驱动动画； 自定义展示样式控制，继承UIPresentationController进行控制，默认的界面展示是铺满全屏的，这里提供自定义接口； 这三个方面是独立的（但可以组合），针对不同控制层面提供的转场管理。（有些文章的介绍中将这些作为并列概念似乎不太合适） 这一套主要包含以下几个协议/概念： Delegate： Animator： InterativeControllerr： PercentInteractiveController：UIPercentDrivenInteractiveTransition Context： Coordinator： 联系文章开头列举的API，考虑下如果由我们自己来实现自定义转场动画的基础API，我们需要处理什么、怎样提供接口给开发者？\b以下是相关对象的详细行为规范： Context对象，遵循，context对象的存在因为动画过程被重用，它提供了动画需要能获取的动画上下文数据（如容器视图、切换前后场景视图、视图控制器等参数，参照文章开始的转场API）；而对于动画过程中的参数获取，则由Coordinator动画协调器对象提供。 Delegate，转场的委托，主要是提供场景切换使用的animator、interactiveController及presentationController，需要实现以下协议： - (nullable id )animationControllerForPresentedController: presentingController: sourceController: -(nullable id )animationControllerForDismissedController: -(nullable id )interactionControllerForPresentation:(id )animator; -(nullable id )interactionControllerForDismissal:(id )animator; -(nullable UIPresentationController )presentationControllerForPresentedViewController:(UIViewController )presented presentingViewController:(nullable UIViewController )presenting sourceViewController:(UIViewController )source NS_AVAILABLE_IOS(8_0); -(void)completeTransition:(BOOL)didComplete; 对于自定义样式的场景展示，需要实现上面第5个方法，提供presentationController控制器；对于需要交互式转场的，需要提供interactiveController控制器。 Animator，动画器对象，遵循协议，主要用于确定动画时间（非交互式动画）及执行具体场景切换动画： -(NSTimeInterval)transitionDuration:(nullable id )transitionContext; -(void)animateTransition:(id )transitionContext; 这是提供转场动画的具体实现位置，并且仅对于非百分比驱动的交互式转场允许空实现。另外需特别注意，一般在animator执行转场动画后，需调用context对象的-completeTransition:方法来结束转场状态，否则转场可能导致视图结构错误（比如被一个TransitionView覆盖到window顶部、导致底下视图无法接收事件）；而对于纯交互式转场，则由interactiveController调用该方法。 interactiveController，可交互动画对象，遵循，基本协议约束的是交互式动画开始的调用： -(void)startInteractiveTransition:(id )transitionContext; context对象提供了更新进度的接口。另外，系统封装了百分比驱动的交互动画对象：UIPercentDrivenInteractiveTransition，实现了对CA动画的可逆的进度控制（具体原理需参考Core Animation的时间系统）。主要方法： -(void)updateInteractiveTransition:(CGFloat)percentComplete; -(void)finishInteractiveTransition; -(void)cancelInteractiveTransition; 一般而言，我们需要做的，是在手势/事件回调中，进行进度的更新及转场的结束/取消操作。 调用逻辑&lt;UIViewControllerTransitioning&gt;中的接口注释，解释了转场过程中涉及的基本调用逻辑，摘抄如下： A transition context object is constructed by the system and passed to the animator in its animateTransition: and transitionDuration: methods as well as to the interaction controller in its startInteractiveTransition: method. If there is an interaction controller its startInteractiveTransition: is called first and its up to the the interaction controller object to call the animateTransition: method if needed. If there is no interaction controller, then the system automatically invokes the animator’s animateTransition: method. The system queries the view controller’s transitioningDelegate or the navigation controller’s delegate to determine if an animator or interaction controller should be used in a transition. The transitioningDelegate is a new propery on UIViewController and conforms to the UIViewControllerTransitioningDelegate protocol defined below. The navigation controller likewise has been augmented with a couple of new delegate methods. The UIViewControllerContextTransitioning protocol can be adopted by custom container controllers. It is purposely general to cover more complex transitions than the system currently supports. For now, navigation push/pops and UIViewController present/dismiss transitions can be customized. Information about the transition is obtained by using the viewControllerForKey:, initialFrameForViewController:, and finalFrameForViewController: methods. The system provides two keys for identifying the from view controller and the to view controller for navigation push/pop and view controller present/dismiss transitions. All custom animations must invoke the context’s completeTransition: method when the transition completes. Furthermore the animation should take place within the containerView specified by the context. For interactive transitions the context’s updateInteractiveTransition:, finishInteractiveTransition or cancelInteractiveTransition should be called as the interactive animation proceeds. The UIPercentDrivenInteractiveTransition class provides an implementation of the UIViewControllerInteractiveTransitioning protocol that can be used to interactively drive any UIView property animations that are created by an animator. 目前支持导航栏控制器的push/pop以及控制器的present/dismiss转场的自定义。来实例看下执行控制器A-&gt;控制器B的自定义动画转场调用逻辑（Present方式）： 设置B.transitionDelegate = Delegate A以animated=true的方式调用-presentViewController:animated:completion 回头看上面的文档说明， 首先系统向Delegate（对于present方式是transitionDelegate，对于navigation/tab是其delegate）询问，是否存在转场动画器（Animator）或者交互控制器（InteractiveAnimator）（另外还有自定义present样式的UIPresentationController）； 若存在InterativeAnimator，则调用-startInteractiveTransition:携带上下文参数Context对象，开始交互式动画转场（留意API，在询问获取interactiveController时，是有参数animator的）；否则 若存在Animator，则调用-animateTransition:携带Context对象，直接执行动画转场，动画在该方法中定义；若不使用自定义PresentationController，则视图结构关系与相应的presentationStyle相关（下文有提到），一般需要处理presented控制器的视图添加/移除。 对于Animator，动画应当在容器视图之内执行；对于交互式控制器，则应当更新执行进度（update/cancel/finish，这是基于手势/触控事件的）；所有动画必须调用-completeTransition结束转场。Context对象实际则由自定义容器控制器Container所维护（系统提供）。 以上是iOS7新增的自定义转场的全部内容，可以按“调用逻辑”进行相关配置、提供相应的控制对象即可。 上面提到的，转场其实涉及的是视图场景的切换，因此附带上视图结构等转场前提知识介绍。 Present转场基本知识基本知识可以查看Apple文档说明，几个知识点列举如下： 视图控制器结构：文档 Present视图控制器：文档 自定义转场动画：文档 自定义转场样式：文档 视图控制器结构视图控制器间的关系，决定了视图控制器的行为，UIKit为我们默认预定义了以下的视图控制器结构关系： 根视图控制器：通过UIWindow关联的rootViewController，将根视图控制器内容铺满窗口； 容器视图控制器：通过子控制器及自定义视图组织复杂界面，主要包括UINavigationControllr、UITabBarController、UIPageViewController、UISplitViewController，容器控制器主要是管理子视图，但子视图控制器对其无依赖；对于如何自定义一个容器视图控制器，传送门在这里，简单来说就是，建立parent-child关系、实现转场动画以及事件传递； Presented视图控制器：是指以模态（modal）的方式展示新的视图内容（通常也移除旧的内容，具体下文有描述）。在Presentation时，通常UIKit查询到最近的容器控制器来提供上下文信息（context），或者可以主动告诉UIKit哪个视图控制器提供context及处理Presentation过程； 主要图示如下： 展示视图控制器：展示及转场过程展示过程，主要是如何将一个新的内容呈现到屏幕上的过程，涉及几个方面的配置： 展示样式（Presentation Style） 转场样式（Transition Style） 展示样式主要包括： fullscreen：全屏 pagesheet：这是一个scaleToFit的样式 formsheet：样式同iPad上Appstore下载弹出页面 当前context：与1的区别在于不一定全屏 OverXXX：区别于无Over的是，展示控制器内容不会被系统主动移出界面 popover：样式同iPad的PopOver（OverXXX及Popover等部分样式是iOS8后提供的） 自定义样式：可控制展示视图大小以及presenting控制器内容是否移出界面等 转场样式，也就是内置动画样式，系统主要提供： .CoverVertical，这是默认的从屏幕底部弹上覆盖最终区域的动画样式 .CrossDissolve，溶入动画 系统不可能提供应用业务所需的所有动画，这是开放转场动画的原因之一吧。 实例我们简单实现一个相册图片预览的缩放转场动画，并添加交互手势支持，最后使用自定义展示控制器。基本实现都比较简单，但对于理解自定义转场基本原理正好足够了。为了明确基本逻辑，我们将transitioningDelegate、animator、interactiveController以及presentationController都分离来实现，实际上也可以合并到一起减少参数传递。三个示例是逐步添加内容完善。 实例1 动画转场缩放动画式Presentation。 实例2 交互式转场支持交互式dismissal。 实例3 自定义展示控制器添加淡入淡出黑色背景。 懒得贴代码了。。还是看demo吧（到时统一po到github）。"},{"title":"iOS开发：CAMediaTiming与动画","date":"2016-10-23T03:35:58.000Z","url":"/ios/ios-animation-mediatiming/","tags":[["iOS","/tags/iOS/"],["动画","/tags/动画/"]],"categories":[["iOS","/categories/iOS/"]],"content":"写在前面在体验至上的时代，\b一些自然酷炫流畅的动画无疑能提高用户对app好感度以及留存率。常见动画有如下拉加载、加载进度以及转场动画等，iOS开发中的动画大家都不陌生。Core Animation框架提供了一套CALayer层动画接口。因为CALayer作为UIView的backing layer的关系，UIKit基于CA框架也提供了一套视图动画接口，归根到底还是CA动画。 这篇文章，主要是来聊聊动画的一些基本概念，不是来解析具体的动画效果实现。不妨先停下来想一想，动画是什么，它的基本实现原理是什么，我们能做什么。我们从框架提供的接口的角度来认识动画。 动画是什么：CAAnimationCAAnimation是Core Animation框架中的一个基类，但并不实际用于动画实现，只是定义了“动画”对象所遵循的基本接口，具体动画效果通过子类提供。其子类有如：CAPropertyAnimation属性动画及其两个子类CABasicAnimation、CAKeyFrameAnimation，iOS9推出的CASpringAnimation、CATransition（都是继承CABasicAnimation）以及动画组CAAnimationGroup（继承于CAAnimation）。我们主要基于基本动画进行分析，动画组及帧动画也是基本动画的组合。 CAAnimation遵循两个关键的协议：CAAction以及CAMediaTiming。 CAAction是一个事件处理的接口（动画行为），要求实现接口的对象实现-(void)runActionForKey:(NSString *)event object:(id)anObject arguments:(nullable NSDictionary *)dict进行事件处理（\b也就是执行动画）。通常而言，object是layer，event则是key，每个layer保存了一份从event到action的映射表（可参考接口- (void)addAnimation:(CAAnimation *)anim forKey:(nullable NSString *)key）。对于系统支持的隐式动画，每当layer的（可动画）属性被修改时，会触发相同名称（属性名）的事件，系统有相应的CAAnimation对象与该事件绑定。另外，系统提供了两个非直接关联到属性的事件：onOrderIn及 onOrderOut，当layer可见或非可见时触发。 CAMediaTiming是一个关键的协议，也是本文所关注的点。CALayer及CAAnimation都遵循实现了该协议。CAMediaTiming对分层时间系统进行了建模，每个对象描述了其父对象时间（parent time）到本身时间（local time）的映射，local time包含两个：active local time及basic local time。时间的转换包含了两个阶段：一是，从父对象时间（parent time）转换为本地活跃时间（active local time），包含了本对象出现在父对象时间线上的点以及其相对（父对象）时间速度；二是，从active local time到basic local time，允许对象本身时长的周期性重复以及逆向播放。 除此之外，CAAnimation定义了另外一个关键属性：timingFunction，类型是CAMediaTimingFunction，这是一个动画时间控制函数。 看完了基本接口，回想一下最初提出的问题，“动画是什么？”。举些大家日常都比较熟悉的例子：电影慢镜头及GIF。电影慢镜头可以将一些短时间内发生的变化场景捕获后，以更长的时间来展示；GIF简单来说，将很多张图片进行合并到同一个图片文件就可以制作出一个GIF，每张图片可以控制周期内播放时长。这些都跟“时间”紧密相关，我们对场景变化的感知是基于时间的。动画，是一定时间内场景（状态）的变化所创造的效果。 CAMediaTiming就如Core Animation框架的时间系统。我们接触的基本动画、交互动画以及物理模拟动画，其实都跟这个概念密切相关。 时间系统：CAMediaTimingCAMediaTiming提供了8个属性，分别是： duration：“The basic duration of the object. Defaults to 0.”（API的解释，下同），这个不一定是真实的动画时长，真实的还跟速度speed以及上层对象时间体系有关。 speed：“The rate of the layer. Used to scale parent time to local time, e.g. if rate is 2, local time progresses twice as fast as parent time. Defaults to 1.”，当前层的速率，用于将父对象时间拉伸到本身时间。 beginTime：“The begin time of the object, in relation to its parent object, if applicable. Defaults to 0.”，本对象在父对象的时间线中开始的位置，比如本身一个anmation添加到一个animation group中时，beginTime设定了动画组开始后当前动画的开始时间（也即是延迟）。但对于将animation添加到layer中时，layer作为parent object它的开始时间是过去时间不能这样使用，需要明确确定其beginTime可以选择对当前绝对时间的偏移。当前绝对时间可通过CACurrentMediaTime()获取并[layer convertTime:CACurrentMediaTime() fromLayer:nil]转换到layer的时间坐标系中。 timeoffset：“Additional offset in active local time. i.e. to convert from parent time tp to active local time t: t = (tp - begin) * speed + offset. One use of this is to “pause” a layer by setting speed to zero andoffset to a suitable value. Defaults to 0.”，这里给出了一条时间转换关系公式，对于父对象中的时间点tp，在本身时间坐标系统时间为t = (tp - begin) * speed + offset，也就是父时间进行伸缩并加上偏移就得到当前对象的时间点。不是很直观理解，举个例子：动画组anigroup（作为parent object）时长3秒分别对应状态p1、p2、p3，一个动画anim时长6秒分别对应状态a1~a6，其动画速度speed为2、偏移offset为1，被添加到动画组anigroup中；那么当动画组anigroup状态为p2时，动画anim的状态为a5。 fillmode、repeatCount ,repeatDuration及autoreverses动画重复及逆向播放的控制属性。 如上面提到的，动画是一定的时间规律下的状态切换，这包含两层含义：一是时间变化规律，二是状态切换。动画效果需要分别对这二者进行控制（或者可以认为是动画状态变化的两面体现，动画既包括值的变化也包括时间的变化；动画的插值与时间相关，时间变化规律指的也是插值的变化，否则感知上时间就是线性变化的）。不过实际上，开发中通常是指定动画的状态切换效果，其时间规律通常是采用已有的动画时间控制函数。除此之外，时基动画需要对时间进度进行管理，上面所列的公式t = (tp - begin) * speed + offset不是用来直接确定动画状态切换的时间规律（效果）的，而是用于确定父对象时间到本对象时间映射（进度）的。其中三组控制变量：父时间进度（tp-begin）、速度（speed）、偏移（offset）。 举几个例子说明时间的进度控制： Xcode模拟器的动画调试慢放，通过修改动画播放的speed； 动画暂停，将speed置为0，并指定相应的offset；甚至还可以通过定时器控制offset的方式，来实现逆向播放等。 插值与时间控制函数：CAMediaTimingFunction时基系统的动画，\b按时间的步进更新动画对象的状态，这涉及了动画状态的插值问题。 比如说一个位置平移动画（比如说弹簧效果），仅知道动画时间duration、始末状态valueBegin、valueEnd是不够的，动画的过程需要知道动画时间t时的位置状态valueT。实现这个具体的动画也很简单，我们需要定义一个以时间t为控制变量的插值函数value=mapfunc(t, duration, valueBegin, valueEnd)，随着时间t的步进对location进行更新即可。 但上述的插值函数mapfunc的问题在于，它是与具体特定动画的动画时间duration、始末状态值相关的。即使是同一效果，不同振幅或不同动画时间都需要提供一个相应的插值函数！不具备可重用性。那假如把动画定义为一种“效果”（比如，弹簧震荡效果），我们如何将这种效果抽象出来？ CAMediaTimingFunction登场。那CAMediaTimingFunction做了什么？CAMediaTimingFunction能将某种“效果”的插值过程抽象出来吗？最初的需求，动画状态的插值还是要实现的。 回到问题的本质，动画的状态切换是基于时间的插值，其实是一个映射问题，value=mapfunc(t, duration, valueBegin, valueEnd)是从线性变化变量t到value的一个非线性变换。为了将动画效果与具体动画状态区分开来，我们需要将时间参数t与其他参数分离，分别构造两个映射函数： mapvalue(tProgress, duration, valueBegin, valueEnd) tProgress = maptime(tReal) 将状态的切换转换为基于进度的插值，tProgress是一个进度值，mapvalue进行线性映射；另外增加一个时间映射函数maptime，将（单位）动画时间映射为状态切换进度tProgress，动画效果将时间控制部分分离了。这正是CAMediaTimingFunction的职责：时间控制（时间映射）。 CAMediaTimingFunction做了动画时间到动画进度（映射到始末状态的线性插值）的映射，其中系统预定义了五种时间控制方法，另外支持定义三次贝塞尔曲线的控制函数。 然后我们回到UI及动画的渲染过程，结合上面所说的时间控制理解一下UI渲染的过程。 ####CALayer的渲染及动画 图层树CALayer拥有与UIView一样的树状层次结构，实际上作为UIView的backing layer是用做内容显示的管理，而UIView则主要添加了事件机制。对应UIView树形结构，\bCALayer有它的图层树（模型树）、呈现树及渲染树，对应每个CALayer的modelLayer，presentationLayer及renderLayer。modelLayer是我们代码层面反应对layer的属性的修改，presentationLayer则是动画过程中与界面展示一致的图层数据，renderLayer则是框架私有的（见上图）。可参考Apple官网的图示： 作为UIView的layer也被称为Root Layer，其代理指定为关联的UIView，用于管理layer的绘制/渲染，代理事件主要包括： 界面的渲染过程在objc.io有一期介绍。下面是渲染的基本过程图解： 总的来说，每次运行循环CPU按需要创建好UIView的缓冲区，对view内容进行绘制（CPU工作），然后缓冲区交给GPU渲染，最后实际显示到屏幕上： 每个UIView的backing layer有一个content字段，指向的是一块位图缓冲区，称为backing store（可以理解成CGImageRef）； CPU对UIView的绘制，主要在动画事务（下文详细介绍）提交、完成布局工作后，[CALayer display]触发的各层事件回调（[CALayer drawInContext:]、[UIView(CALayerDelegate) drawLayer:inContext:]、[\bUIView drawRect:]）中在CPU层面对界面的绘制，数据通过CGContextRef 写入backing store； backing store写完后，通过渲染服务交给GPU进行渲染，将backing store中的位图数据进行显示。 每当修改视图或层的属性，将导致位图缓冲区的重新创建，重新绘制后，layer的content字段会重新指向新的位图缓冲区。CPU影响的是布局与CPU层面的渲染。 GPU是基于OpenGL对\bTexture纹理数据进行处理的，Core Animation框架可以创建Texture并将其与位图数据绑定。整个过程如下图示： GPU处理需要将位图数据从RAM搬到VRAM，主要是处理Texture的渲染工作，包括： 纹理组合，相当于UIView的层次叠加处理，公式R = S+D*(1-Sa)，图层的透明度有重大影响； 像素缩放采样，位图数据与最终渲染的数据大小不一致需调整 离屏渲染 动画事务：CATransactionCore Animation假设屏幕上所有东西均可进行动画，对CALayer的可动画属性进行修改时，默认会导致动画的发生来保证平滑过渡，这便是隐式动画。之所以称之为隐式，是因为没有指定它的动画时间、类型等。实际上，动画的执行时间取决于当前事务的设置，动画类型取决于图层行为。 动画事务CATransaction是Core Animation用来包含一系列属性动画集合的机制，用于将多个可动画属性的修改集中提交执行。任何用指定事务来改变图层的可动画属性时，不会立即发生变化而是等事务提交后才有动画过渡，所有动画属性的修改都应处于事务中。CATransaction分为显式及隐式事务，显式的事务使用如下： 动画事务可嵌套，嵌套的动画事务，只有最外层事务提交时才执行整个动画。CATransaction没有实例属性，对duration及是否动画等配置的修改会影响当前事务。对于想无动画设置属性可以设置kCATransactionDisableActions的key或+setDisableActions（停止了动画action查询）。 Core Animation在每个Runloop周期中自动开始一次新的事务，任何一次Runloop中的动画属性的修改都被集中起来，做一次0.25s（默认）的动画。这也是隐式动画的所使用事务。只有非Root Layer的可动画属性修改会触发隐式动画，因为Root Layer有关联的UIView作为其delegate，在查询对应属性key的action时返回了nil。 UIView中的类方法+beginAnimations:context:及+commitAnimations以及基于block的动画接口中，都有添加了事务。 动画的创建与执行iOS显示系统是vSync信号驱动，硬件中断信号之后，会通知到runloop，在新的一轮runloop循环中CPU完成好界面布局及绘制。对于动画，首先是上面所提的CATransaction事务会将我们认为的“动画”行为提交到Core Animation，Core Animation在runloop中注册了事件状态监听，并在回调中，将中间状态提交到GPU处理。硬件时钟的回调基本是线性时间的，这也是为什么需要“时间控制函数”的原因。另外GPU或CPU层面的处理耗时过长会导致直接丢弃当前帧渲染，表现出来就是界面卡顿。 篇幅过长，有部分简单带过，有时间再补上。"},{"title":"Core Data 数据版本/迁移","date":"2016-08-07T16:08:33.000Z","url":"/ios/core-data-versioning/","tags":[["iOS","/tags/iOS/"],["CoreData","/tags/CoreData/"]],"categories":[["iOS","/categories/iOS/"]],"content":"CoreData基本入坑指南 写在前面开发中使用Core Data的确是要配置挺多内容的，首先要配置Model-Context-Coordinator-Store、配置Store的数据迁移策略(以及可能的数据迁移)，还要处理多线程读写的问题。想用CoreData但又不想写太多这样业务无关代码时，MagicalRecord算是一个不错的选择。但像我这样用上了Core Data但没用（或者不想用）MagicalRecord之类的工具库时，做数据版本迁移是迟早的事情嘛。 使用Core Data，基本问题涉及数据模型定义、Model-Context-Coordinator-Store配置、CURD操作，还有现在要说的数据版本/迁移，以后要说的多线程问题。最近刚好处理版本迁移问题，简单记录下，基本配置以及多线程等问题迟些再补充。 关于Core Data以及它的数据版本迁移，可以先看下以下资料： Core Data Programming Guide Core Data版本/数据迁移 Programming Guide 自定义Core Data迁移（objc.io好文） 数据模型版本/映射模型数据模型Xcode可以直接在模型文件上创建不同版本的模型定义。 定义新版本：选中.xcdatamodeld模型文件（其实是文件夹），菜单Editor-&gt;Add Model Version，可选择基于当前特定版本的模型创建新版本的模型定义；创建后，.xcdatamodeld文件夹下增加.xcdatamodel的模型文件（其实也是文件夹）； 指定使用版本：选中.xcdatamodeld模型文件，在Xcode右侧工具栏中，Model Version可以选择模型所使用的版本，选中的版本带有绿色勾选高亮； sublime打开.xcdatamodeld目录可以一窥CoreData的模型文件（都提供给IDE使用）：首先是增加了一个.xccurrentversion的plist版本记录文件，内容很简单，仅是用一个key来表明当前所选的model文件： .xcdatamodel/contents则是模型定义的xml文件（仅作示例）： 内容除了记录编辑器的一些信息，主要还是模型信息，且基本与Xcode上可视化的配置是对应的。 elements包含模型文件中的实体(Entity)列表，positionX、positionY、width、height暂未去探讨实际意义(可能是跟序列化过程中的数据布局相关)； entity则是每个实体的配置信息，包括普通属性attribute、关系(属性)relationship（当然还有fetched property此处未有）。name是实体名称，representedClassName则是类名（syncable是iCloud相关?）；可以看到Core Data实体名称跟类名是可以独立的，这也是我们项目重构时可以利用的特性（已有开源库）。 attribute属性，包含属性名name、是否可选optional、属性类型attributeType、默认值defaultValueString、syncable未知特性 relationship关系，包含关系名name、是否可选optional、关联数maxCount（一对多|一对一）、删除规则deleteRule、目标实体destinationEntity、本实体在目标实体中的关系名inverseName、inverseEntity，syncable 这些模型定义配置文件由Xcode编译后，会在.app目录下生成CoreData运行时使用的模型定义文件（夹）XXXModel.momd。 对于单一版本的模型文件，.momd中包含二进制格式XXXModel.mom模型定义以及一个biplist格式的版本信息文件VersionInfo.plist。对于多版本的模型文件.momd中则对应每个版本的模型定义生成一个.mom，以及.omo文件。你可能会好奇mom文件是什么呀？其实在Xcode5之后，通过 .xcdatamodel &gt; Editor &gt; Import可以完全复原数据模型的定义。omo又是什么呢，其实是当前版本模型定义数据的另一种格式，stackoverflow上已经有回答了： At WWDC this year I talked to the Core Data engineers in the labs and they told me that the .omofile is just an optimized version of the .mom file. The .mom file is a binary plist while the .omo is some other sort of format that’s faster to load. They told me that you could safely remove the .omo file and Core Data would load from the—slightly slower—.mom file instead. They told me that doing so would only result in an additional few milliseconds of load time (which begs the question of why they bothered to optimize it in the first place). —stackoverflow by Ben Dolman, Jun 9’ 14 转换一下格式plutil -convert xml1 VersionInfo.plist -o Version.plist可以看到VersionInfo.plist记录的是模型各个版本文件中实体配置的哈希： 可以看到在v2版本中实体XXXXPostBar改变了。CoreData将对发生改变的实体、依赖版本间映射关系进行数据迁移。（p.s .xcdatamodel文件Xcode不支持直接delete，可以尝试对.xcdatamodeld先remove reference，手动删除.xcdatamodel，再重新将.xcdatamodel添加到project） 映射模型不同版本的数据迁移，需要知道模型版本间的数据关系，Xcode使用.xcmappingmodel来编辑记录这种映射关系。.xcmappingmodel同样是一文件夹，包含xcmapping.xml。.xcmapping.xml内容示例如下： databaseInfo记录了数据库元信息，metadata中包含了持久化框架版本(CoreData)、存储版本哈希（包括涉及的Attribute、Entity、MappingModel、Property、Relation）；object包含好几种不同type的信息，如XDDEVENTITYMAPPING、XDDEVATTRIBUTEMAPPING、XDDEVMAPPINGMODEL等，XDDEVMAPPINGMODEL包含了映射源模型及目标模型的model文件路径、model二进制数据（大概是为了分离datamodel与mappingmodel； databaseInfo中的meta字段sqlite中SELECT Z_PLIST FROM Z_METADATA;比较类似；可通过以下方法获取元数据：-[[NSPersistentStoreCoordinator metadataForPersistentStoreOfType:nilURL:urlerror:]，读取结果如下： .xcmappingmodel经Xcode编译后在.app目录中生成.cdm文件。 轻量级数据迁移当数据模型的改变仅是实体或属性重命名、增删实体属性、属性可选特性更改或定义默认值等改变时(所有支持类型看这里)，使用轻量级数据迁移即可；NSPersistentStoreCoordinator 会自动推断出mapping model(因为VersionInfo及mom中包含了足够的信息)，实现代码寥寥数行： 只需要添加持久化存储时添加选项支持自动推断mappingModel进行数据迁移即可。虽然可以手动迁移数据，苹果还是推荐尽可能利用自动推断方式进行迁移： A further advantage of using lightweight migration—beyond the fact that you don’t need to create the mapping model yourself—is that if you use an inferred model and you use the SQLite store, then Core Data can perform the migration in situ (solely by issuing SQL statements). This can represent a significant performance benefit as Core Data doesn’t have to load any of your data. Because of this, you are encouraged to use inferred migration where possible, even if the mapping model you might create yourself would be trivial. 另外，要支持lightwight的方式，Core Data必须要能在运行时找得到源模型及(迁移)目标模型，这个搜索路径默认是[NSBundle allBundles]以及[NSBundle allFrameworks]，模型文件存放在此外的需要使用Migration manager，见此处说明。 自定义数据迁移当模型修改较多导致NSMigrationManager无法推断出mapping model时，Core Data需要我们明确提供mapping model才能完成数据迁移。 创建映射模型（mapping model）创建mapping model其实很简单，当你新建了model版本后，可以创建一个mapping model的文件，需要你确认指定映射模型的基准模型（也就是上一版本的Model）及目标模型（当前版本的Model）。 需要注意进行渐进式数据迁移，也就是每次模型版本更新后都需要创建一个mapping model。否则如果用户跳跃版本更新，会缺失部分版本之间数据迁移的映射模型，这可能是灾难性的错误；而如果要创建所有不同版本之间的映射关系，O(n^2)的复杂度，这是另一个灾难。 迁移过程先看下数据迁移的入口，入参主要是数据库的路径及数据模型： 简单来说，需要递归进行版本v和版本v+1之间的数据迁移。具体包括：1、检查当前数据版本与模型版本的兼容性2、查找与当前数据版本v兼容的模型版本v，以及从该模型版本v到下一模型版本v+1的映射模型mapping model，这是自动查找的3、是否有指定的mapping model4、构建NSMigrationManager，执行迁移5、数据备份及继续递归迁移 // 注：参考Martin Hwasser的代码，具体可见代码仓库。 迁移策略对于更复杂的迁移，比如需要在实体之间新建关系等，则需要定制迁移策略了。定制迁移策略可以继承NSEntityMigrationPolicy，并重载-createDestinationInstancesForSourceInstance:entityMapping:manager:error:方法。 就如同Model与Entity的关系，NSMappingModel中包含了多个NSEntityMapping，NSEntityMapping是具体的实体映射的描述。NSEntityMapping在Xcode面板中可以配置User Info，这里可以做一些自定义的标识定义。 方法-createDestinationInstancesForSourceInstance:entityMapping:manager:error:中，我们可以根据需要创建实体的实例以及手动构建关系： 对于需要建立关系的迁移策略而言，还需要考虑实体迁移的顺序，否则在建立关系时，对应的实体还未迁移无法建立关系。实体迁移的顺序其实就是MappingModel中的EntityMapping的次序，按需修改便可。 从上面的流程可以看到，Core Data自定义数据迁移实际还是比较复杂的过程。希望客户端完善、好用的关系数据库ORM能早日出现。 参考资料： 1、"},{"title":"GCD in depth（GCD深入理解）","date":"2016-08-03T14:21:53.000Z","url":"/ios/translated-gcd-in-depth-i/","tags":[["iOS","/tags/iOS/"],["GCD","/tags/GCD/"]],"categories":[["iOS","/categories/iOS/"]],"content":"本文原文为raywenderlich“GCD深入理解”。一贯的风格，示例图解GCD的日常用法；part 1介绍GCD/多线程的基本背景，part 2介绍GCD常用API。（本文节选） GCD是什么GCD是指libdispatch，Apple公司的一个代码库，用来支持多核设备(iOS/OS X)上的代码并发执行。使用有如下好处： 通过后台执行计算密集任务、提高app响应速度 提供比锁/线程方便的并发模型、减少并发bug 代码优化、以原语(primitives)方式为常见模式提供更高的性能（如单例模式） GCD术语串行 vs. 并发（Serial vs. Concurrent） 描述的是当前任务与其他任务之间的关系，或者说是对任务管理队列执行形式的描述。串行执行，同一时间只有一个任务被执行；并发执行则同一时间可以有多个任务被执行。这里的「同一时间」我们指的是面向用户的时间，因为对于单核计算机，在指令执行层面都是串行的。另一个相关的概念“并行”将在下文中单独探讨。 同步 vs. 异步（Synchronous vs. Asynchronous） 描述的是提交任务到dispatch的函数何时返回的问题。一个“同步”的函数，必须等待它提交的任务执行完之后才返回；而“异步”的函数则是将任务提交给dispatch后立即返回。因此“同步”的函数是会阻塞当前线程的，而“异步”的函数则不然。当然“异步”的函数也不管任务的具体执行问题，这是dispatch内部的事情。 临界区（Critical Section) 临界资源是指需要互斥访问的共享资源，临界区则是指访问共享资源的一段代码，临界区处理不当会导致变量不合预期的被修改。 竞争条件（Race Condition） 多个线程或进程在读写一个共享数据时结果依赖于他们执行的相对时间。因此不同的时机会影响系统以不受控的方式运行。 死锁（Deadlock） 两个或多个任务（大多数情况下是线程），如果都陷入等待对方的执行完成来结束自己的执行，会导致死锁。 线程安全（Thread Safe） 线程安全的代码能被多个线程或并发任务调用而不会产生任何问题（数据污染、闪退等），非线程的代码一次只能被运行在一个环境（context）下；线程安全的例如非可变集合类型NSDictionary。 上下文切换（Context Switch） 上下文切换指的是在一个进程中切换执行不同线程时进行的状态存储或恢复的操作； 并发 vs 并行（Concurrency vs. Parallelism）并发及并行总被一起提及，因此这里需要解释以区分它们。并行指的是指令级别的同时执行，是需要设备多核心的支持；并发代码的”同时“执行，指的是任务级别的“同时”执行，是在任务的时间尺度里，可以在多核设备上通过并行来支持，也可以通过上下文切换(Context-Switch)来支持。多核设备上通过并行(parallelism)来同时执行多个线程，而在单核设备上则需要进行上下文切换；关系如下图示： Parallelism requires concurrency, but concurrency does not guaranteeparallelism 并发实际上描述的是结构（structure），这是实质的不同。作者荐读 队列（Queues）GCD提供了dispatch queue来处理代码块；这些队列管理着你提交给GCD的任务（tasks）并以FIFO的方式来执行他们。所有dispatch queues本身是线程安全的，因此可以在多线程中同时访问他们。关键在于选取合适的分发队列（dispatch queue）以及正确的dispatch方法来提交你的任务到队列。 GCD中两种不同的dispatch队列，串行及并发执行队列。 串行队列（Serial Queue）串行队列中的任务每次只执行一个，每个任务只能等待前面的任务完成后才会开始执行。当然你并指导一个代码块结束与下一代码块开始之间的耗时，如下图所示： 这些任务的执行时间由GCD来控制，你唯一得到的保证就是，GCD每次仅执行一个任务并且任务执行顺序跟他们添加的顺序是一致的。串行队列中任务不可能并发执行，因此不会有临界区访问竞争条件等的问题/风险。因此也可以使用串行队列来规避一些多线程问题。 并发队列（Concurrent Queues）并发队列中的任务唯一能保证开始执行时机与被添加的顺序一致。任务能以任意的顺序结束，而你也不知道将耗费多长时间来启动下一个任务或者特定时间点有多少任务在执行。这些都是由GCD来控制。并行队列中的任务执行如下图所示： GCD提供了至少5种特定的队列类型。 队列类型（Queue Type）1、主队列（main queue）：首先系统提供了一个特殊的串行队列也就是熟知的主队列。跟其他串行队列一样，主队列中的任务同一时间也只能执行一个。但是它保证了所有任务都是在主线程中执行的，这是唯一允许更新UI的线程。这个队列用来给UIView发消息或者发送通知。 2、全局队列（Global Dispatch Queues）：系统提供了几个并发队列，也就是所谓的全局派发队列。目前有四个不同优先级的全局队列：background，low，default以及high。需要注意的是，苹果的API也会调用这些队列！ 3、自定义队列：系统允许我们创建自己的串行或并发队列。 GCD的“艺术”在于选择正确的队列和正确的分发方法(dispatch function)来提交你的任务。可以跟下面的例子走一遍，来理解这一点。 实例使用dispatch_sync/dispatch_async处理后台任务示例代码： 使用dispatch_async将一个代码块提交到队列中，然后立即返回；代码块任务将在之后由GCD决定决定何时执行。下面是几个使用dispatch_async的几个不同队列的介绍： 自定义串行队列：任务在后台同步执行，消除了资源竞争。注意若需要从一个方法获取数据，你必须在block中内联一个block来获取，或者使用dispatch_sync。 主线程队列（串行）：这是在并发队列中完成任务后更新UI的常用方法。 同步队列：在后台执行非UI工作的常用方法。 dispatch_sync与dispatch_async是串行/异步的区别(见上文)；dispatch_sync会向队列提交任务，然后等任务完成后才返回（执行下一个指令）。使用dispatch_sync及__block可以捕获任务执行中的变量。 注意！假如你调用dispatch_sync并且将目标队列设置为你当前运行的队列，这将会导致死锁。因为dispatch_sync的调用需要等待任务block执行完成来返回，但是任务block不会结束（其实甚至还没开始）直到队列当前执行的任务结束，而这是办不到的！因此调用dispatch_sync时你必须清楚自己所处的队列以及目标队列。快速预览dispatch_sync的使用场景： 自定义串行队列：务必小心，如果你调用dispatch_sync时指定的目标队列跟调用时所处是同一个队列，这必然会形成死锁！ 主线程（串行）：务必小心，理由同上 并发队列：就这样可以的！可以使用dispatch_barrier_(a)sync或者dispatch_sync 栗子： 使用dispatch_after延时处理示例代码： 使用dispatch_once构建单例 使用dispatch-barrier处理“读者-写者问题” 上述的NSMutableArray类型的属性不是线程读写安全的，即使dispatch_once保证了单例的，photos属性也对外暴露inmutable的接口，但是并不能避免多线程读写的问题。 这个经典读写者同步的问题可参考这里。GCD提供了一个优雅的解决方案，通过dispatch barriers创建读写锁。懒，直接看原文 Dispatch barriers are a group of functions acting as a serial-style bottleneck when working with concurrent queues. Using GCD’s barrier API ensures that the submitted block is the only item executed on the specified queue for that particular time. This means that all items submitted to the queue prior to the dispatch barrier must complete before the block will execute.When the block’s turn arrives, the barrier executes the block and ensures that the queue does not execute any other blocks during that time. Once finished, the queue returns to its default implementation. GCD provides both synchronous and asynchronous barrier functions. dispatch-barrier图示如下：dispatch-barrier提交的代码块执行时的队列就如串行队列（队列中只有barrier的代码执行），但除此外队列恢复原本的方式（通常是并发队列）。下面是你是否应该使用barrier方法的一些说明： 自定义串行队列：这是个糟糕的选择，串行队列本身就是每次只有一个任务在执行，dispatch-barrier在这里帮不上什么忙 全局并发队列：小心！因为之前提过的，其他系统可能也在使用这些队列！（据为己有是危险的。。 自定义并发队列：对于原子操作或临界区代码执行，这是个很好的选择。设置或者实例化需要线程安全的地方，这是个很好的选择。 //创建信号量，参数：信号量的初值，如果小于0则会返回NULL dispatch_semaphore_create（信号量值） //等待降低信号量 dispatch_semaphore_wait（信号量，等待时间） //提高信号量 dispatch_semaphore_signal(信号量) "},{"title":"The DES Algorithm Illustrated（DES算法阐释）","date":"2016-07-23T15:40:57.000Z","url":"/tech/des-illustrated-translated/","tags":[["DES","/tags/DES/"],["Security","/tags/Security/"]],"categories":[["Security","/categories/Security/"]],"content":" “They say this like it’s a choice. But it’s not.” ⌜DES算法阐释⌟，感谢原作者J. Orlin Grabbe ，原文@2006。 The DES (Data Encryption Standard) algorithm is the most widely used encryption algorithm in the world. For many years, and among many people, “secret code making” and DES have been synonymous. And despite the recent coup by the Electronic Frontier Foundation in creating a $220,000 machine to crack DES-encrypted messages, DES will live on in government and banking for years to come through a life- extending version called “triple-DES.” How does DES work? This article explains the various steps involved in DES-encryption, illustrating each step by means of a simple example. Since the creation of DES, many other algorithms (recipes for changing data) have emerged which are based on design principles similar to DES. Once you understand the basic transformations that take place in DES, you will find it easy to follow the steps involved in these more recent algorithms. But first a bit of history of how DES came about is appropriate, as well as a look toward the future. The National Bureau of Standards Coaxes the Genie from the Bottle On May 15, 1973, during the reign of Richard Nixon, the National Bureau of Standards (NBS) published a notice in the Federal Register soliciting proposals for cryptographic algorithms to protect data during transmission and storage. The notice explained why encryption was an important issue. Over the last decade, there has been an accelerating increase in the accumulations and communication of digital data by government, industry and by other organizations in the private sector. The contents of these communicated and stored data often have very significant value and/or sensitivity. It is now common to find data transmissions which constitute funds transfers of several million dollars, purchase or sale of securities, warrants for arrests or arrest and conviction records being communicated between law enforcement agencies, airline reservations and ticketing representing investment and value both to the airline and passengers, and health and patient care records transmitted among physicians and treatment centers. The increasing volume, value and confidentiality of these records regularly transmitted and stored by commercial and government agencies has led to heightened recognition and concern over their exposures to unauthorized access and use. This misuse can be in the form of theft or defalcations of data records representing money, malicious modification of business inventories or the interception and misuse of confidential information about people. The need for protection is then apparent and urgent. It is recognized that encryption (otherwise known as scrambling, enciphering or privacy transformation) represents the only means of protecting such data during transmission and a useful means of protecting the content of data stored on various media, providing encryption of adequate strength can be devised and validated and is inherently integrable into system architecture. The National Bureau of Standards solicits proposed techniques and algorithms for computer data encryption. The Bureau also solicits recommended techniques for implementing the cryptographic function: for generating, evaluating, and protecting cryptographic keys; for maintaining files encoded under expiring keys; for making partial updates to encrypted files; and mixed clear and encrypted data to permit labelling, polling, routing, etc. The Bureau in its role for establishing standards and aiding government and industry in assessing technology, will arrange for the evaluation of protection methods in order to prepare guidelines. NBS waited for the responses to come in. It received none until August 6, 1974, three days before Nixon’s resignation, when IBM submitted a candidate that it had developed internally under the name LUCIFER. After evaluating the algorithm with the help of the National Security Agency (NSA), the NBS adopted a modification of the LUCIFER algorithm as the new Data Encryption Standard (DES) on July 15, 1977. DES was quickly adopted for non-digital media, such as voice-grade public telephone lines. Within a couple of years, for example, International Flavors and Fragrances was using DES to protect its valuable formulas transmitted over the phone (“With Data Encryption, Scents Are Safe at IFF,” Computerworld 14, No. 21, 95 (1980).) Meanwhile, the banking industry, which is the largest user of encryption outside government, adopted DES as a wholesale banking standard. Standards for the wholesale banking industry are set by the American National Standards Institute (ANSI). ANSI X3.92, adopted in 1980, specified the use of the DES algorithm. Some Preliminary Examples of DES DES works on bits, or binary numbers–the 0s and 1s common to digital computers. Each group of four bits makes up a hexadecimal, or base 16, number. Binary “0001” is equal to the hexadecimal number “1”, binary “1000” is equal to the hexadecimal number “8”, “1001” is equal to the hexadecimal number “9”, “1010” is equal to the hexadecimal number “A”, and “1111” is equal to the hexadecimal number “F”. DES works by encrypting groups of 64 message bits, which is the same as 16 hexadecimal numbers. To do the encryption, DES uses “keys” where are also apparently 16 hexadecimal numbers long, or apparently 64 bits long. However, every 8th key bit is ignored in the DES algorithm, so that the effective key size is 56 bits. But, in any case, 64 bits (16 hexadecimal digits) is the round number upon which DES is organized. For example, if we take the plaintext message “8787878787878787”, and encrypt it with the DES key “0E329232EA6D0D73”, we end up with the ciphertext “0000000000000000”. If the ciphertext is decrypted with the same secret DES key “0E329232EA6D0D73”, the result is the original plaintext “8787878787878787”. This example is neat and orderly because our plaintext was exactly 64 bits long. The same would be true if the plaintext happened to be a multiple of 64 bits. But most messages will not fall into this category. They will not be an exact multiple of 64 bits (that is, an exact multiple of 16 hexadecimal numbers). For example, take the message “Your lips are smoother than vaseline”. This plaintext message is 38 bytes (76 hexadecimal digits) long. So this message must be padded with some extra bytes at the tail end for the encryption. Once the encrypted message has been decrypted, these extra bytes are thrown away. There are, of course, different padding schemes–different ways to add extra bytes. Here we will just add 0s at the end, so that the total message is a multiple of 8 bytes (or 16 hexadecimal digits, or 64 bits). The plaintext message “Your lips are smoother than vaseline” is, in hexadecimal, “596F7572206C6970 732061726520736D 6F6F746865722074 68616E2076617365 6C696E650D0A”. (Note here that the first 72 hexadecimal digits represent the English message, while “0D” is hexadecimal for Carriage Return, and “0A” is hexadecimal for Line Feed, showing that the message file has terminated.) We then pad this message with some 0s on the end, to get a total of 80 hexadecimal digits: “596F7572206C6970 732061726520736D 6F6F746865722074 68616E2076617365 6C696E650D0A0000”. If we then encrypt this plaintext message 64 bits (16 hexadecimal digits) at a time, using the same DES key “0E329232EA6D0D73” as before, we get the ciphertext: “C0999FDDE378D7ED 727DA00BCA5A84EE 47F269A4D6438190 9DD52F78F5358499 828AC9B453E0E653”. This is the secret code that can be transmitted or stored. Decrypting the ciphertext restores the original message “Your lips are smoother than vaseline”. (Think how much better off Bill Clinton would be today, if Monica Lewinsky had used encryption on her Pentagon computer!) How DES Works in Detail DES is a block cipher–meaning it operates on plaintext blocks of a given size (64-bits) and returns ciphertext blocks of the same size. Thus DES results in a permutation among the 2^64 (read this as: “2 to the 64th power”) possible arrangements of 64 bits, each of which may be either 0 or 1. Each block of 64 bits is divided into two blocks of 32 bits each, a left half block L and a right half R. (This division is only used in certain operations.) Example: Let M be the plain text message M = 0123456789ABCDEF, where M is in hexadecimal (base 16) format. Rewriting M in binary format, we get the 64-bit block of text: M = 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111L = 0000 0001 0010 0011 0100 0101 0110 0111R = 1000 1001 1010 1011 1100 1101 1110 1111 The first bit of M is “0”. The last bit is “1”. We read from left to right. DES operates on the 64-bit blocks using key sizes of 56- bits. The keys are actually stored as being 64 bits long, but every 8th bit in the key is not used (i.e. bits numbered 8, 16, 24, 32, 40, 48, 56, and 64). However, we will nevertheless number the bits from 1 to 64, going left to right, in the following calculations. But, as you will see, the eight bits just mentioned get eliminated when we create subkeys. Example: Let K be the hexadecimal key K = 133457799BBCDFF1. This gives us as the binary key (setting 1 = 0001, 3 = 0011, etc., and grouping together every eight bits, of which the last one in each group will be unused): K = 00010011 00110100 01010111 01111001 10011011 10111100 11011111 11110001 The DES algorithm uses the following steps: Step 1: Create 16 subkeys, each of which is 48-bits long. The 64-bit key is permuted according to the following table, PC-1. Since the first entry in the table is “57”, this means that the 57th bit of the original key K becomes the first bit of the permuted key K+. The 49th bit of the original key becomes the second bit of the permuted key. The 4th bit of the original key is the last bit of the permuted key. Note only 56 bits of the original key appear in the permuted key. Example: From the original 64-bit key K = 00010011 00110100 01010111 01111001 10011011 10111100 11011111 11110001 we get the 56-bit permutation K+ = 1111000 0110011 0010101 0101111 0101010 1011001 1001111 0001111 Next, split this key into left and right halves, C0 and D0, where each half has 28 bits. Example: From the permuted key K+, we get C0 = 1111000 0110011 0010101 0101111D0 = 0101010 1011001 1001111 0001111 With C0 and D0 defined, we now create sixteen blocks Cn and Dn, 1&lt;=n&lt;=16. Each pair of blocks Cn and Dn is formed from the previous pair Cn-1 and Dn-1, respectively, for n = 1, 2, …, 16, using the following schedule of “left shifts” of the previous block. To do a left shift, move each bit one place to the left, except for the first bit, which is cycled to the end of the block. This means, for example, C3 and D3 are obtained from C2 and D2, respectively, by two left shifts, and C16 and D16 are obtained from C15 and D15, respectively, by one left shift. In all cases, by a single left shift is meant a rotation of the bits one place to the left, so that after one left shift the bits in the 28 positions are the bits that were previously in positions 2, 3,…, 28, 1. Example: From original pair pair C0 and D0 we obtain: C0 = 1111000011001100101010101111D0 = 0101010101100110011110001111 C1 = 1110000110011001010101011111D1 = 1010101011001100111100011110 C2 = 1100001100110010101010111111D2 = 0101010110011001111000111101 C3 = 0000110011001010101011111111D3 = 0101011001100111100011110101 C4 = 0011001100101010101111111100D4 = 0101100110011110001111010101 C5 = 1100110010101010111111110000D5 = 0110011001111000111101010101 C6 = 0011001010101011111111000011D6 = 1001100111100011110101010101 C7 = 1100101010101111111100001100D7 = 0110011110001111010101010110 C8 = 0010101010111111110000110011D8 = 1001111000111101010101011001 C9 = 0101010101111111100001100110D9 = 0011110001111010101010110011 C10 = 0101010111111110000110011001D10 = 1111000111101010101011001100 C11 = 0101011111111000011001100101D11 = 1100011110101010101100110011 C12 = 0101111111100001100110010101D12 = 0001111010101010110011001111 C13 = 0111111110000110011001010101D13 = 0111101010101011001100111100 C14 = 1111111000011001100101010101D14 = 1110101010101100110011110001 C15 = 1111100001100110010101010111D15 = 1010101010110011001111000111 C16 = 1111000011001100101010101111D16 = 0101010101100110011110001111 We now form the keys Kn, for 1&lt;=n&lt;=16, by applying the following permutation table to each of the concatenated pairs CnDn. Each pair has 56 bits, but PC-2 only uses 48 of these. Therefore, the first bit of Kn is the 14th bit of CnDn, the second bit the 17th, and so on, ending with the 48th bit of Kn being the 32th bit of CnDn. Example: For the first key we have C1D1 = 1110000 1100110 0101010 1011111 1010101 0110011 0011110 0011110 which, after we apply the permutation PC-2, becomes K1 = 000110 110000 001011 101111 111111 000111 000001 110010 For the other keys we have K2 = 011110 011010 111011 011001 110110 111100 100111 100101K3 = 010101 011111 110010 001010 010000 101100 111110 011001K4 = 011100 101010 110111 010110 110110 110011 010100 011101K5 = 011111 001110 110000 000111 111010 110101 001110 101000K6 = 011000 111010 010100 111110 010100 000111 101100 101111K7 = 111011 001000 010010 110111 111101 100001 100010 111100K8 = 111101 111000 101000 111010 110000 010011 101111 111011K9 = 111000 001101 101111 101011 111011 011110 011110 000001K10 = 101100 011111 001101 000111 101110 100100 011001 001111K11 = 001000 010101 111111 010011 110111 101101 001110 000110K12 = 011101 010111 000111 110101 100101 000110 011111 101001K13 = 100101 111100 010111 010001 111110 101011 101001 000001K14 = 010111 110100 001110 110111 111100 101110 011100 111010K15 = 101111 111001 000110 001101 001111 010011 111100 001010K16 = 110010 110011 110110 001011 000011 100001 011111 110101So much for the subkeys. Now we look at the message itself. Step 2: Encode each 64-bit block of data. There is an initial permutation IP of the 64 bits of the message data M. This rearranges the bits according to the following table, where the entries in the table show the new arrangement of the bits from their initial order. The 58th bit of M becomes the first bit of IP. The 50th bit of M becomes the second bit of IP. The 7th bit of M is the last bit of IP. Example: Applying the initial permutation to the block of text M, given previously, we get M = 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111IP = 1100 1100 0000 0000 1100 1100 1111 1111 1111 0000 1010 1010 1111 0000 1010 1010 Here the 58th bit of M is “1”, which becomes the first bit of IP. The 50th bit of M is “1”, which becomes the second bit of IP. The 7th bit of M is “0”, which becomes the last bit of IP. Next divide the permuted block IP into a left half L0 of 32 bits, and a right half R0 of 32 bits. Example: From IP, we get L0 and R0 L0 = 1100 1100 0000 0000 1100 1100 1111 1111R0 = 1111 0000 1010 1010 1111 0000 1010 1010 We now proceed through 16 iterations, for 1&lt;=n&lt;=16, using a function f which operates on two blocks–a data block of 32 bits and a key Kn of 48 bits–to produce a block of 32 bits. Let + denote XOR addition, (bit-by-bit addition modulo 2). Then for n going from 1 to 16 we calculate Ln = Rn-1Rn = Ln-1 + f(Rn-1,Kn)This results in a final block, for n = 16, of L16R16. That is, in each iteration, we take the right 32 bits of the previous result and make them the left 32 bits of the current step. For the right 32 bits in the current step, we XOR the left 32 bits of the previous step with the calculation f . Example: For n = 1, we have K1 = 000110 110000 001011 101111 111111 000111 000001 110010L1 = R0 = 1111 0000 1010 1010 1111 0000 1010 1010R1 = L0 + f(R0,K1) It remains to explain how the function f works. To calculate f, we first expand each block Rn-1 from 32 bits to 48 bits. This is done by using a selection table that repeats some of the bits in Rn-1 . We’ll call the use of this selection table the function E. Thus E(Rn-1) has a 32 bit input block, and a 48 bit output block. Let E be such that the 48 bits of its output, written as 8 blocks of 6 bits each, are obtained by selecting the bits in its inputs in order according to the following table: Thus the first three bits of E(Rn-1) are the bits in positions 32, 1 and 2 of Rn-1 while the last 2 bits of E(Rn-1) are the bits in positions 32 and 1. Example: We calculate E(R0) from R0 as follows: R0 = 1111 0000 1010 1010 1111 0000 1010 1010E(R0) = 011110 100001 010101 010101 011110 100001 010101 010101 (Note that each block of 4 original bits has been expanded to a block of 6 output bits.) Next in the f calculation, we XOR the output E(Rn-1) with the key Kn: Kn + E(Rn-1).Example: For K1 , E(R0), we have K1 = 000110 110000 001011 101111 111111 000111 000001 110010E(R0) = 011110 100001 010101 010101 011110 100001 010101 010101K1+E(R0) = 011000 010001 011110 111010 100001 100110 010100 100111. We have not yet finished calculating the function f . To this point we have expanded Rn-1 from 32 bits to 48 bits, using the selection table, and XORed the result with the key Kn . We now have 48 bits, or eight groups of six bits. We now do something strange with each group of six bits: we use them as addresses in tables called “S boxes”. Each group of six bits will give us an address in a different S box. Located at that address will be a 4 bit number. This 4 bit number will replace the original 6 bits. The net result is that the eight groups of 6 bits are transformed into eight groups of 4 bits (the 4-bit outputs from the S boxes) for 32 bits total. Write the previous result, which is 48 bits, in the form: Kn + E(Rn-1) =B1B2B3B4B5B6B7B8,where each Bi is a group of six bits. We now calculate S1(B1)S2(B2)S3(B3)S4(B4)S5(B5)S6(B6)S7(B7)S8(B8)where Si(Bi) referres to the output of the i-th S box. To repeat, each of the functions S1, S2,…, S8, takes a 6-bit block as input and yields a 4-bit block as output. The table to determine S1 is shown and explained below: RowNo. 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0 14 4 13 1 2 15 11 8 3 10 6 12 5 9 0 7 1 0 15 7 4 14 2 13 1 10 6 12 11 9 5 3 8 2 4 1 14 8 13 6 2 11 15 12 9 7 3 10 5 0 3 15 12 8 2 4 9 1 7 5 11 3 14 10 0 6 13If S1 is the function defined in this table and B is a block of 6 bits, then S1(B) is determined as follows: The first and last bits of B represent in base 2 a number in the decimal range 0 to 3 (or binary 00 to 11). Let that number be i. The middle 4 bits of B represent in base 2 a number in the decimal range 0 to 15 (binary 0000 to 1111). Let that number be j. Look up in the table the number in the i-th row and j-th column. It is a number in the range 0 to 15 and is uniquely represented by a 4 bit block. That block is the output S1(B) of S1 for the input B. For example, for input block B = 011011 the first bit is “0” and the last bit “1” giving 01 as the row. This is row 1. The middle four bits are “1101”. This is the binary equivalent of decimal 13, so the column is column number 13. In row 1, column 13 appears 5. This determines the output; 5 is binary 0101, so that the output is 0101. Hence S1(011011) = 0101. The tables defining the functions S1,…,S8 are the following: Example: For the first round, we obtain as the output of the eight S boxes: K1 + E(R0) = 011000 010001 011110 111010 100001 100110 010100 100111. S1(B1)S2(B2)S3(B3)S4(B4)S5(B5)S6(B6)S7(B7)S8(B8) = 0101 1100 1000 0010 1011 0101 1001 0111 The final stage in the calculation of f is to do a permutation P of the S-box output to obtain the final value of f: f = P(S1(B1)S2(B2)…S8(B8))The permutation P is defined in the following table. P yields a 32-bit output from a 32-bit input by permuting the bits of the input block. Example: From the output of the eight S boxes: S1(B1)S2(B2)S3(B3)S4(B4)S5(B5)S6(B6)S7(B7)S8(B8) = 0101 1100 1000 0010 1011 0101 1001 0111we get f = 0010 0011 0100 1010 1010 1001 1011 1011R1 = L0 + f(R0 , K1 )= 1100 1100 0000 0000 1100 1100 1111 1111 0010 0011 0100 1010 1010 1001 1011 1011= 1110 1111 0100 1010 0110 0101 0100 0100In the next round, we will have L2 = R1, which is the block we just calculated, and then we must calculate R2 =L1 + f(R1, K2), and so on for 16 rounds. At the end of the sixteenth round we have the blocks L16 and R16. We then reverse the order of the two blocks into the 64-bit block R16L16and apply a final permutation IP-1 as defined by the following table: That is, the output of the algorithm has bit 40 of the preoutput block as its first bit, bit 8 as its second bit, and so on, until bit 25 of the preoutput block is the last bit of the output. Example: If we process all 16 blocks using the method defined previously, we get, on the 16th round, L16 = 0100 0011 0100 0010 0011 0010 0011 0100R16 = 0000 1010 0100 1100 1101 1001 1001 0101 We reverse the order of these two blocks and apply the final permutation to R16L16 = 00001010 01001100 11011001 10010101 01000011 01000010 00110010 00110100 IP-1 = 10000101 11101000 00010011 01010100 00001111 00001010 10110100 00000101 which in hexadecimal format is 85E813540F0AB405. This is the encrypted form of M = 0123456789ABCDEF: namely, C = 85E813540F0AB405. Decryption is simply the inverse of encryption, follwing the same steps as above, but reversing the order in which the subkeys are applied. DES Modes of Operation The DES algorithm turns a 64-bit message block M into a 64-bit cipher block C. If each 64-bit block is encrypted individually, then the mode of encryption is called Electronic Code Book (ECB) mode. There are two other modes of DES encryption, namely Chain Block Coding (CBC) and Cipher Feedback (CFB), which make each cipher block dependent on all the previous messages blocks through an initial XOR operation. Cracking DES Before DES was adopted as a national standard, during the period NBS was soliciting comments on the proposed algorithm, the creators of public key cryptography, Martin Hellman and Whitfield Diffie, registered some objections to the use of DES as an encryption algorithm. Hellman wrote: “Whit Diffie and I have become concerned that the proposed data encryption standard, while probably secure against commercial assault, may be extremely vulnerable to attack by an intelligence organization” (letter to NBS, October 22, 1975). Diffie and Hellman then outlined a “brute force” attack on DES. (By “brute force” is meant that you try as many of the 2^56 possible keys as you have to before decrypting the ciphertext into a sensible plaintext message.) They proposed a special purpose “parallel computer using one million chips to try one million keys each” per second, and estimated the cost of such a machine at $20 million. Fast forward to 1998. Under the direction of John Gilmore of the EFF, a team spent $220,000 and built a machine that can go through the entire 56-bit DES key space in an average of 4.5 days. On July 17, 1998, they announced they had cracked a 56-bit key in 56 hours. The computer, called Deep Crack, uses 27 boards each containing 64 chips, and is capable of testing 90 billion keys a second. Despite this, as recently as June 8, 1998, Robert Litt, principal associate deputy attorney general at the Department of Justice, denied it was possible for the FBI to crack DES: “Let me put the technical problem in context: It took 14,000 Pentium computers working for four months to decrypt a single message . . . . We are not just talking FBI and NSA [needing massive computing power], we are talking about every police department.” Responded cryptograpy expert Bruce Schneier: “ . . . the FBI is either incompetent or lying, or both.” Schneier went on to say: “The only solution here is to pick an algorithm with a longer key; there isn’t enough silicon in the galaxy or enough time before the sun burns out to brute- force triple-DES” (Crypto-Gram, Counterpane Systems, August 15, 1998). Triple-DES Triple-DES is just DES with two 56-bit keys applied. Given a plaintext message, the first key is used to DES- encrypt the message. The second key is used to DES-decrypt the encrypted message. (Since the second key is not the right key, this decryption just scrambles the data further.) The twice-scrambled message is then encrypted again with the first key to yield the final ciphertext. This three-step procedure is called triple-DES. Triple-DES is just DES done three times with two keys used in a particular order. (Triple-DES can also be done with three separate keys instead of only two. In either case the resultant key space is about 2^112.) General References“Cryptographic Algorithms for Protection of Computer Data During Transmission and Dormant Storage,” Federal Register 38, No. 93 (May 15, 1973). Data Encryption Standard, Federal Information Processing Standard (FIPS) Publication 46, National Bureau of Standards, U.S. Department of Commerce, Washington D.C. (January 1977). Carl H. Meyer and Stephen M. Matyas, Cryptography: A New Dimension in Computer Data Security, John Wiley &amp; Sons, New York, 1982. Dorthy Elizabeth Robling Denning, Cryptography and Data Security, Addison-Wesley Publishing Company, Reading, Massachusetts, 1982. D.W. Davies and W.L. Price, Security for Computer Networks: An Introduction to Data Security in Teleprocessing and Electronics Funds Transfer, Second Edition, John Wiley &amp; Sons, New York, 1984, 1989. Miles E. Smid and Dennis K. Branstad, “The Data Encryption Standard: Past and Future,” in Gustavus J. Simmons, ed., Contemporary Cryptography: The Science of Information Integrity, IEEE Press, 1992. Douglas R. Stinson, Cryptography: Theory and Practice, CRC Press, Boca Raton, 1995. Bruce Schneier, Applied Cryptography, Second Edition, John Wiley &amp; Sons, New York, 1996. Alfred J. Menezes, Paul C. van Oorschot, and Scott A. Vanstone, Handbook of Applied Cryptography, CRC Press, Boca Raton, 1997."},{"title":"初识Shark——SQLite在iOS上的ORM实现","date":"2016-07-20T15:39:35.000Z","url":"/undefined/shark-intro-i/","tags":[["iOS","/tags/iOS/"],["SQLite","/tags/SQLite/"],["Shark","/tags/Shark/"],["SharkORM","/tags/SharkORM/"]],"categories":[["iOS","/categories/iOS/"]],"content":"Shark是我觉得目前最好用的SQLite在iOS上的ORM实现。 我的选择一直以来，iOS上的数据库ORM实现方案都不太合我意。大家主流用到的数据库存储方案大多如下： CoreData FMDB的衍生类库 Realm NSCoding序列化 Plist序列化 项目中我用比较多的是CoreData及FMDB，Realm因为是新生数据库引擎、尚在demo/调研阶段，keyarchived以及plist已经不作为主要持久化手段了。 CoreData是苹果在iOS3.0（那些说5.0引入的[微笑]）引入的数据持久化框架，虽然支持使用SQLite作为存储后端，但它事实上不是为SQLite而来的；CoreData在设计上就有着存储后端、存储协调、对象上下文、对象模型明确分层的结构，奔着对象图管理（Object-Graph-Management）而非ORM的目标来实现。 Realm是从YC孵化团队推出的自称跨平台（SQLite不跨平台吗？）、高效、使用简单的用于替代CoreData/SQLite的移动数据库引擎，声称比SQLite要快。因为没看到他的评测报告也没了解实现细节（引擎核心还是闭源，据说使用mmap），其他就不说了。但跨线程处理貌似还不如CoreData、模型对象不可跨线程传递就瞬间无爱，暂且略过。 而FMDB实际上仅仅是一个SQLite Wrapper，把C/C++的sqlite接口转换为OC接口而已。所以实际很多人是FMDBxModel(runtime)模型化或者FMDBxMantle直接对接JSON。之前项目中虽然不是基于FMDB但也是基于SQLite+runtime做了property-&gt;sqlite.table的映射，这样本已可以满足一般的数据存储需求了。 当初放弃FMDBx系列是状态同步、数据唯一性问题。先以微信业务举个栗子，个人详情页面修改了备注昵称，我期望的是能以数据驱动的方式驱动通信录、会话列表、聊天页面所涉及个人昵称/备注的UI显示数据的修改，方案要求同一条数据库记录在内存中应该是同一个实例。而以当时的方案来说（包括FMDBx系列以及现在Shark）并没能支持，查询的结果集中每一个都是在内存中新创建的一个实例。结果就是，那时(2014-15)简直是通知乱飞的时代（要不就是一条巨长的delegate调用链、壮观的场面）。想象一下，一条数据河流主干（我们假设为数据存储控制中心）、若干二/三级支流（业务层），当业务层引起数据变动时，“通知”意味着杂乱穿插水管引流到各个与之有关联的其他支流。而直观来看，数据从支流回到主干、再流动到其他分支是否更合理（也就是，业务层驱动数据/存储层变动，再通知数据管理层及其他业务层） 至于准备放弃CoreData。。是因为旧项目CoreData操作太过繁琐，而多线程处理上经常挖坑埋坑。顺便，CoreData的多线程上，在两三年前大神就指出了Context Stack的方式效率还不如Context Merge；Magical Record似乎没有很好的处理到，最近发现了个比较有趣的第三方库Core Store，但旧项目主Objc就用不上了。算下来当下已经没几个适合用的了，然后就发现了Shark。除了对象唯一性问题，Shark算是满足我的大部分需求了。 DBAccess: Shark的前世DBAccess，作者Adrian Herridge，一年前在github开放使用（非开源）。按github上的介绍，DBAccess甚至提供了CoreData数据迁移方法。我竟然一直没听说过这个库。。囧。目前官网上已声明废弃、替代品为Shark。 Shark官网:  算是因缘巧合，在Info上恰巧看到采访稿按作者的说法Shark具有与DBAccess近乎一致的操作规范，由于公司高层不同意开源DBAccess暴露业务逻辑，才在DBAccess上进行重构开源的Shark。DBAccess作为一个闭源的framework，根据CocoaPods的统计总下载量达到近9k，采用的app有135个(160720)。也是不错的成绩了。（Realm已经下载220+w次，App安装接近4w，Star8.2k，不容忽略=.=） Shark根据目前CocoaPods上面的统计，目前总下载量166，app使用数目35，star为29。 今天简单写了个Shark的demo，使用还是相当简便的！ 简单测试CURD 简单测试多线程：Object传递、存储 简单测试事务操作 需要说明（跟进）的问题有： 数据表唯一键的问题，组合primary key貌似没找到说明 多线程传递Object是安全的！ 多线程操作Object最终的结果仅依赖于提交的次序 嵌套事务存在bug：如果同一个对象在不同transaction中被提交，将会产生多条数据库记录。【待修复】 我希望添加的特性：Context维护数据的唯一性，目前实现是每个Object都有内部关联一个context！ demo待补充上传，其他留坑待填。。"},{"title":"Much To Be Done","date":"2016-07-17T06:30:27.000Z","url":"/undefined/much-to-be-done/","tags":[["随想","/tags/随想/"]],"categories":[[" ",""]],"content":"人生段段旅途，每天点点滴滴。站在当下，多往后看看起点，也向前看看前路。 不一定能做好每一个抉择，但要活好每一个当下。 "},{"title":"categories","date":"2016-06-10T15:38:59.000Z","url":"/categories/index.html","categories":[[" ",""]]},{"title":"about","date":"2016-06-10T15:44:29.000Z","url":"/about/index.html","categories":[[" ",""]],"content":"联系请email，见信则回。 如果您需要使用GPG，以下是我的GPG公钥： "},{"title":"tags","date":"2016-06-10T12:48:59.000Z","url":"/tags/index.html","categories":[[" ",""]]},{"title":"search","date":"2021-11-17T03:46:24.000Z","url":"/search/index.html","categories":[[" ",""]]}]